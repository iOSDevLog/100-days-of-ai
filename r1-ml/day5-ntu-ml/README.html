<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <link href="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Styles/ebook.css" type="text/css" rel="stylesheet" />

</head>

<body>
    <h1>机器学习基石</h1>
    <h1>

        1 -- The Learning Problem

    </h1>
    <div class="markdown_views">
        <p>最近在看NTU林轩田的《机器学习基石》课程，个人感觉讲的非常好。整个基石课程分成四个部分：</p>

        <ul>
            <li>
                <p>When Can Machine Learn? </p>
            </li>
            <li>
                <p>Why Can Machine Learn? </p>
            </li>
            <li>
                <p>How Can Machine Learn?</p>
            </li>
            <li>
                <p>How Can Machine Learn Better?</p>
            </li>
        </ul>

        <p>每个部分由四节课组成，总共有16节课。那么，从这篇开始，我们将连续对这门课做课程笔记，共16篇，希望能对正在看这们课的童鞋有所帮助。下面开始第一节课的笔记：The Learning Problem。</p>

        <h3 id="一what-is-machine-learning" class="sigil_not_in_toc"><strong>一、What is Machine Learning</strong></h3>

        <p>什么是“学习”？学习就是人类通过观察、积累经验，掌握某项技能或能力。就好像我们从小学习识别字母、认识汉字，就是学习的过程。而机器学习（Machine
            Learning），顾名思义，就是让机器（计算机）也能向人类一样，通过观察大量的数据和训练，发现事物规律，获得某种分析问题、解决问题的能力。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9dd2cad8a66f29e53a6318e40a7412ef.jpg" alt="这里写图片描述" title="" /></p>

        <p>机器学习可以被定义为：Improving some performance measure with experence computed from data.
            也就是机器从数据中总结经验，从数据中找出某种规律或者模型，并用它来解决实际问题。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6bfe4b629d4641ce715c2f2abf8a015d.jpg" alt="这里写图片描述" title="" /></p>

        <p>什么情况下会使用机器学习来解决问题呢？其实，目前机器学习的应用非常广泛，基本上任何场合都能够看到它的身影。其应用场合大致可归纳为三个条件：</p>

        <ul>
            <li>
                <p>事物本身存在某种潜在规律</p>
            </li>
            <li>
                <p>某些问题难以使用普通编程解决</p>
            </li>
            <li>
                <p>有大量的数据样本可供使用</p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a592a711c257203636aa7cd6b10efcd7.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="二applications-of-machine-learning" class="sigil_not_in_toc"><strong>二、Applications of Machine Learning</strong></h3>

        <p>机器学习在我们的衣、食、住、行、教育、娱乐等各个方面都有着广泛的应用，我们的生活处处都离不开机器学习。比如，打开购物网站，网站就会给我们自动推荐我们可能会喜欢的商品；电影频道会根据用户的浏览记录和观影记录，向不同用户推荐他们可能喜欢的电影等等，到处都有机器学习的影子。</p>

        <h3 id="三components-of-machine-learning" class="sigil_not_in_toc"><strong>三、Components of Machine Learning</strong></h3>

        <p>本系列的课程对机器学习问题有一些基本的术语需要注意一下：</p>

        <ul>
            <li>
                <p>输入x</p>
            </li>
            <li>
                <p>输出y</p>
            </li>
            <li>
                <p>目标函数f，即最接近实际样本分布的规律</p>
            </li>
            <li>
                <p>训练样本data</p>
            </li>
            <li>
                <p>假设hypothesis，一个机器学习模型对应了很多不同的hypothesis，通过演算法A，选择一个最佳的hypothesis对应的函数称为矩g，g能最好地表示事物的内在规律，也是我们最终想要得到的模型表达式。</p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/44da41b76a6ba9a827af7d7f41236640.jpg" alt="这里写图片描述" title="" /></p>

        <p>实际中，机器学习的流程图可以表示为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c4fa6c9095756476fa7259076381f958.jpg" alt="这里写图片描述" title="" /></p>

        <p>对于理想的目标函数f，我们是不知道的，我们手上拿到的是一些训练样本D，假设是监督式学习，其中有输入x，也有输出y。机器学习的过程，就是根据先验知识选择模型，该模型对应的hypothesis
            set（用H表示），H中包含了许多不同的hypothesis，通过演算法A，在训练样本D上进行训练，选择出一个最好的hypothes，对应的函数表达式g就是我们最终要求的。一般情况下，g能最接近目标函数f，这样，机器学习的整个流程就完成了。</p>

        <h3 id="四machine-learning-and-other-fields" class="sigil_not_in_toc"><strong>四、Machine Learning and Other
                Fields</strong></h3>

        <p>与机器学习相关的领域有：</p>

        <ul>
            <li>
                <p>数据挖掘（Data Mining）</p>
            </li>
            <li>
                <p>人工智能（Artificial Intelligence）</p>
            </li>
            <li>
                <p>统计（Statistics）</p>
            </li>
        </ul>

        <p>其实，机器学习与这三个领域是相通的，基本类似，但也不完全一样。机器学习是这三个领域中的有力工具，而同时，这三个领域也是机器学习可以广泛应用的领域，总得来说，他们之间没有十分明确的界线。</p>

        <h3 id="五总结" class="sigil_not_in_toc"><strong>五、总结</strong></h3>

        <p>本节课主要介绍了什么是机器学习，什么样的场合下可以使用机器学习解决问题，然后用流程图的形式展示了机器学习的整个过程，最后把机器学习和数据挖掘、人工智能、统计这三个领域做个比较。本节课的内容主要是概述性的东西，比较简单，所以笔记也相对比较简略。</p>

        <p>这里附上林轩田（Hsuan-Tien Lin）关于这门课的主页： <br />
            <a href="http://www.csie.ntu.edu.tw/~htlin/">http://www.csie.ntu.edu.tw/~htlin/</a></p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习基石》课程。</p>
    </div>

    <h1>
        2 -- Learning to Answer Yes/No

    </h1>
    <div class="markdown_views">
        <p>上节课，我们主要简述了机器学习的定义及其重要性，并用流程图的形式介绍了机器学习的整个过程：根据模型H，使用演算法A，在训练样本D上进行训练，得到最好的h，其对应的g就是我们最后需要的机器学习的模型函数，一般g接近于目标函数f。本节课将继续深入探讨机器学习问题，介绍感知机Perceptron模型，并推导课程的第一个机器学习算法：Perceptron
            Learning Algorithm（PLA）。</p>

        <h3 id="一perceptron-hypothesis-set" class="sigil_not_in_toc"><strong>一、Perceptron Hypothesis Set</strong></h3>

        <p>引入这样一个例子：某银行要根据用户的年龄、性别、年收入等情况来判断是否给该用户发信用卡。现在有训练样本D，即之前用户的信息和是否发了信用卡。这是一个典型的机器学习问题，我们要根据D，通过A，在H中选择最好的h，得到g，接近目标函数f，也就是根据先验知识建立是否给用户发信用卡的模型。银行用这个模型对以后用户进行判断：发信用卡（+1），不发信用卡（-1）。</p>

        <p>在这个机器学习的整个流程中，有一个部分非常重要：就是模型选择，即Hypothesis Set。选择什么样的模型，很大程度上会影响机器学习的效果和表现。下面介绍一个简单常用的Hypothesis
            Set：感知机（Perceptron）。</p>

        <p>还是刚才银行是否给用户发信用卡的例子，我们把用户的个人信息作为特征向量x，令总共有d个特征，每个特征赋予不同的权重w，表示该特征对输出（是否发信用卡）的影响有多大。那所有特征的加权和的值与一个设定的阈值threshold进行比较：大于这个阈值，输出为+1，即发信用卡；小于这个阈值，输出为-1，即不发信用卡。感知机模型，就是当特征加权和与阈值的差大于或等于0，则输出h(x)=1；当特征加权和与阈值的差小于0，则输出h(x)=-1，而我们的目的就是计算出所有权值w和阈值threshold。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b82f5722a3ab38fa777a0941ce313102.jpg" alt="这里写图片描述" title="" /></p>

        <p>为了计算方便，通常我们将阈值threshold当做<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/80aba44293dd8bc07d580471772db0d3.jpg" />，引入一个<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ba8e90ec3b50f66d895b239f68d3b97e.jpg" />的量与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/80aba44293dd8bc07d580471772db0d3.jpg" />相乘，这样就把threshold也转变成了权值<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/80aba44293dd8bc07d580471772db0d3.jpg" />，简化了计算。h(x)的表达式做如下变换：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b0388ac66d4e814cf2ecc1c4aebc2799.jpg" alt="这里写图片描述" title="" /></p>

        <p>为了更清晰地说明感知机模型，我们假设Perceptrons在二维平面上，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9da10bd554efbaa3d9f62efed8cb7834.jpg" />。其中，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/80aba44293dd8bc07d580471772db0d3.jpg" />是平面上一条分类直线，直线一侧是正类（+1），直线另一侧是负类（-1）。权重w不同，对应于平面上不同的直线。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6eb760b955af84cb1123dd680eb4b559.jpg" alt="这里写图片描述" title="" /></p>

        <p>那么，我们所说的Perceptron，在这个模型上就是一条直线，称之为linear(binary)
            classifiers。注意一下，感知器线性分类不限定在二维空间中，在3D中，线性分类用平面表示，在更高维度中，线性分类用超平面表示，即只要是形如<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b060a4879c8127c91fe14a0a743ca23d.jpg" />的线性模型就都属于linear(binary)
            classifiers。</p>

        <p>同时，需要注意的是，这里所说的linear(binary) classifiers是用简单的感知器模型建立的，线性分类问题还可以使用logistic regression来解决，后面将会介绍。</p>

        <h3 id="二perceptron-learning-algorithmpla" class="sigil_not_in_toc"><strong>二、Perceptron Learning
                Algorithm(PLA)</strong></h3>

        <p>根据上一部分的介绍，我们已经知道了hypothesis set由许多条直线构成。接下来，我们的目的就是如何设计一个演算法A，来选择一个最好的直线，能将平面上所有的正类和负类完全分开，也就是找到最好的g，使<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/061263d047d98f81c1e18f8f49c57003.jpg" />。</p>

        <p>如何找到这样一条最好的直线呢？我们可以使用逐点修正的思想，首先在平面上随意取一条直线，看看哪些点分类错误。然后开始对第一个错误点就行修正，即变换直线的位置，使这个错误点变成分类正确的点。接着，再对第二个、第三个等所有的错误分类点就行直线纠正，直到所有的点都完全分类正确了，就得到了最好的直线。这种“逐步修正”，就是PLA思想所在。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75217f1e29be523c4e5b655d738984a2.jpg" alt="这里写图片描述" title="" /></p>

        <p>下面介绍一下PLA是怎么做的。首先随机选择一条直线进行分类。然后找到第一个分类错误的点，如果这个点表示正类，被误分为负类，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4042fc2c320d85292df45d0c2633965e.jpg" />，那表示w和x夹角大于90度，其中w是直线的法向量。所以，x被误分在直线的下侧（相对于法向量，法向量的方向即为正类所在的一侧），修正的方法就是使w和x夹角小于90度。通常做法是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cdb3c7bd482f1beb34c202eef937eefd.jpg" />，如图右上角所示，一次或多次更新后的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9cfd891e8acb93d51d15087897f73aa2.jpg" />与x夹角小于90度，能保证x位于直线的上侧，则对误分为负类的错误点完成了直线修正。</p>

        <p>同理，如果是误分为正类的点，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7e16316a1d9c7fd686cdb66b9f09f630.jpg" />，那表示w和x夹角小于90度，其中w是直线的法向量。所以，x被误分在直线的上侧，修正的方法就是使w和x夹角大于90度。通常做法是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25df598a47ca943cce43cee3f072d4e9.jpg" />，如图右下角所示，一次或多次更新后的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9cfd891e8acb93d51d15087897f73aa2.jpg" />与x夹角大于90度，能保证x位于直线的下侧，则对误分为正类的错误点也完成了直线修正。</p>

        <p>按照这种思想，遇到个错误点就进行修正，不断迭代。要注意一点：每次修正直线，可能使之前分类正确的点变成错误点，这是可能发生的。但是没关系，不断迭代，不断修正，最终会将所有点完全正确分类（PLA前提是线性可分的）。这种做法的思想是“知错能改”，有句话形容它：“A
            fault confessed is half redressed.”</p>

        <p>实际操作中，可以一个点一个点地遍历，发现分类错误的点就进行修正，直到所有点全部分类正确。这种被称为Cyclic PLA。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a01f86d78da3a4c18e65c580dcbc3034.jpg" alt="这里写图片描述" title="" /></p>

        <p>下面用图解的形式来介绍PLA的修正过程：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e0d499510e79ae414ba6d8fd0e2b8873.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4c2ee658095b1de81eef6462835ccff5.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/eade122d2714fd8f022ed5750dac7ebb.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ee9dfb1122ece819e36dfa0dffa3d710.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0907de3645464656b10156121be5ca29.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3588fd87a025943f3a44dda267611783.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a0efb902fa72d856e691be2b58d367c8.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/31868f4e7c73a3c6172e1feb72168f5f.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e54782823ec6e1465008d4c91cdc7924.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/83392b3b4e2f3481d33b79efaed3ec11.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a7e3b39ad0a959c6a37bc3b4ab350504.jpg" alt="这里写图片描述" title="" /></p>

        <p>对PLA，我们需要考虑以下两个问题：</p>

        <ul>
            <li>
                <p>PLA迭代一定会停下来吗？如果线性不可分怎么办？</p>
            </li>
            <li>
                <p>PLA停下来的时候，是否能保证<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4e89dc8628aa25992aee4c27f454472b.jpg" />？如果没有停下来，是否有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4e89dc8628aa25992aee4c27f454472b.jpg" />？</p>
            </li>
        </ul>

        <h3 id="三guarantee-of-pla" class="sigil_not_in_toc"><strong>三、Guarantee of PLA</strong></h3>

        <p>PLA什么时候会停下来呢？根据PLA的定义，当找到一条直线，能将所有平面上的点都分类正确，那么PLA就停止了。要达到这个终止条件，就必须保证D是线性可分（linear
            separable）。如果是非线性可分的，那么，PLA就不会停止。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/eed8a5d3f418163842ee06008346de06.jpg" alt="这里写图片描述" title="" /></p>

        <p>对于线性可分的情况，如果有这样一条直线，能够将正类和负类完全分开，令这时候的目标权重为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40de538fbc9692d37d7d1b7ab8958efb.jpg" />，则对每个点，必然满足<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e70d3b173167e8a06cb87df08df81c73.jpg" />，即对任一点：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e13d51359e00687861a9c469e7e0f8d8.jpg" alt="这里写图片描述" title="" /></p>

        <p>PLA会对每次错误的点进行修正，更新权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75cc738213b9d738d2f3b8b323d07aef.jpg" />的值，如果<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75cc738213b9d738d2f3b8b323d07aef.jpg" />与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40de538fbc9692d37d7d1b7ab8958efb.jpg" />越来越接近，数学运算上就是内积越大，那表示<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75cc738213b9d738d2f3b8b323d07aef.jpg" />是在接近目标权重<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40de538fbc9692d37d7d1b7ab8958efb.jpg" />，证明PLA是有学习效果的。所以，我们来计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75cc738213b9d738d2f3b8b323d07aef.jpg" />与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40de538fbc9692d37d7d1b7ab8958efb.jpg" />的内积：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/522dc5f7b352e150c9704f00ad795cca.jpg" alt="这里写图片描述" title="" /></p>

        <p>从推导可以看出，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75cc738213b9d738d2f3b8b323d07aef.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40de538fbc9692d37d7d1b7ab8958efb.jpg" />的内积跟<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2a7c3c74c112ab824335ff317c785f4e.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40de538fbc9692d37d7d1b7ab8958efb.jpg" />的内积相比更大了。似乎说明了<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75cc738213b9d738d2f3b8b323d07aef.jpg" />更接近<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40de538fbc9692d37d7d1b7ab8958efb.jpg" />，但是内积更大，可能是向量长度更大了，不一定是向量间角度更小。所以，下一步，我们还需要证明<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75cc738213b9d738d2f3b8b323d07aef.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2a7c3c74c112ab824335ff317c785f4e.jpg" />向量长度的关系：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d316f70f72b7ea87e40817e2cd9f5543.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2a7c3c74c112ab824335ff317c785f4e.jpg" />只会在分类错误的情况下更新，最终得到的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/be9452610f340ddcd227d32452da883b.jpg" />相比<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/392d2051d8acd806804208c33704175a.jpg" />的增量值不超过<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/46294e55f4b6c554e691470ae7ec3d2a.jpg" />。也就是说，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2a7c3c74c112ab824335ff317c785f4e.jpg" />的增长被限制了，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75cc738213b9d738d2f3b8b323d07aef.jpg" />与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2a7c3c74c112ab824335ff317c785f4e.jpg" />向量长度不会差别太大！</p>

        <p>如果令初始权值<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/80aba44293dd8bc07d580471772db0d3.jpg" />，那么经过T次错误修正后，有如下结论：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-42">\frac{w_f^T}{||w_f||}\frac{w_T}{w_T}\geq \sqrt T\cdot constant</script>
        </p>

        <p>下面贴出来该结论的具体推导过程：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9499cd5bc28ac0c3d524f8115ef09a46.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/182b2ba169926a57c9bb35d350c6d04f.jpg" alt="这里写图片描述" title="" /></p>

        <p>上述不等式左边其实是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2ed3b41c02e21f3224f54ab912153516.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40de538fbc9692d37d7d1b7ab8958efb.jpg" />夹角的余弦值，随着T增大，该余弦值越来越接近1，即<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2ed3b41c02e21f3224f54ab912153516.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40de538fbc9692d37d7d1b7ab8958efb.jpg" />越来越接近。同时，需要注意的是，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2b1582bb9dd36767edc8638d5142f4a6.jpg" />，也就是说，迭代次数T是有上界的。根据以上证明，我们最终得到的结论是：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75cc738213b9d738d2f3b8b323d07aef.jpg" />与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40de538fbc9692d37d7d1b7ab8958efb.jpg" />的是随着迭代次数增加，逐渐接近的。而且，PLA最终会停下来（因为T有上界），实现对线性可分的数据集完全分类。</p>

        <h3 id="四non-separable-data" class="sigil_not_in_toc"><strong>四、Non-Separable Data</strong></h3>

        <p>上一部分，我们证明了线性可分的情况下，PLA是可以停下来并正确分类的，但对于非线性可分的情况，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40de538fbc9692d37d7d1b7ab8958efb.jpg" />实际上并不存在，那么之前的推导并不成立，PLA不一定会停下来。所以，PLA虽然实现简单，但也有缺点：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/184006fbd0c94062a9bad5aecdb2b705.jpg" alt="这里写图片描述" title="" /></p>

        <p>对于非线性可分的情况，我们可以把它当成是数据集D中掺杂了一下noise，事实上，大多数情况下我们遇到的D，都或多或少地掺杂了noise。这时，机器学习流程是这样的：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5ca498908766c95678b857366c359ede.jpg" alt="这里写图片描述" title="" /></p>

        <p>在非线性情况下，我们可以把条件放松，即不苛求每个点都分类正确，而是容忍有错误点，取错误点的个数最少时的权重w：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/459e9ae9fb763c5285e4b3d6e7017446.jpg" alt="这里写图片描述" title="" /></p>

        <p>事实证明，上面的解是NP-hard问题，难以求解。然而，我们可以对在线性可分类型中表现很好的PLA做个修改，把它应用到非线性可分类型中，获得近似最好的g。</p>

        <p>修改后的PLA称为Packet Algorithm。它的算法流程与PLA基本类似，首先初始化权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/80aba44293dd8bc07d580471772db0d3.jpg" />，计算出在这条初始化的直线中，分类错误点的个数。然后对错误点进行修正，更新w，得到一条新的直线，在计算其对应的分类错误的点的个数，并与之前错误点个数比较，取个数较小的直线作为我们当前选择的分类直线。之后，再经过n次迭代，不断比较当前分类错误点个数与之前最少的错误点个数比较，选择最小的值保存。直到迭代次数完成后，选取个数最少的直线对应的w，即为我们最终想要得到的权重值。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5d5060a872bbddfe2d5fb0263407ee05.jpg" alt="这里写图片描述" title="" /></p>

        <p>如何判断数据集D是不是线性可分？对于二维数据来说，通常还是通过肉眼观察来判断的。一般情况下，Pocket Algorithm要比PLA速度慢一些。</p>

        <h3 id="五总结" class="sigil_not_in_toc"><strong>五、总结</strong></h3>

        <p>本节课主要介绍了线性感知机模型，以及解决这类感知机分类问题的简单算法：PLA。我们详细证明了对于线性可分问题，PLA可以停下来并实现完全正确分类。对于不是线性可分的问题，可以使用PLA的修正算法Pocket
            Algorithm来解决。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习基石》课程。</p>
    </div>

    <h1>
        3 -- Types of Learning

    </h1>
    <div class="markdown_views">
        <p>上节课我们主要介绍了解决线性分类问题的一个简单的方法：PLA。PLA能够在平面中选择一条直线将样本数据完全正确分类。而对于线性不可分的情况，可以使用Pocket
            Algorithm来处理。本节课将主要介绍一下机器学习有哪些种类，并进行归纳。</p>

        <h3 id="一learning-with-different-output-space-y" class="sigil_not_in_toc"><strong>一、Learning with Different
                Output Space Y</strong></h3>

        <p>我们在上节课引入的银行根据用户个人情况判断是否给他发信用卡的例子，这是一个典型的二元分类（binary classification）问题。也就是说输出只有两个，一般y={-1,
            +1}，-1代表不发信用卡（负类），+1代表发信用卡（正类）。</p>

        <p>二元分类的问题很常见，包括信用卡发放、垃圾邮件判别、患者疾病诊断、答案正确性估计等等。二元分类是机器学习领域非常核心和基本的问题。二元分类有线性模型也有非线性模型，根据实际问题情况，选择不同的模型。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5c6d3459fba2b7d3da1fe29dda9a8c09.jpg" alt="这里写图片描述" title="" /></p>

        <p>除了二元分类，也有多元分类（Multiclass Classification）问题。顾名思义，多元分类的输出多于两个，y={1, 2, … , K}, K&gt;2.
            一般多元分类的应用有数字识别、图片内容识别等等。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/33b3456668ed201b68aafa318ce5685b.jpg" alt="这里写图片描述" title="" /></p>

        <p>二元分类和多元分类都属于分类问题，它们的输出都是离散值。二对于另外一种情况，比如训练模型，预测房屋价格、股票收益多少等，这类问题的输出y=R，即范围在整个实数空间，是连续的。这类问题，我们把它叫做回归（Regression）。最简单的线性回归是一种典型的回归模型。</p>

        <p>除了分类和回归问题，在自然语言处理等领域中，还会用到一种机器学习问题：结构化学习（Structured
            Learning）。结构化学习的输出空间包含了某种结构在里面，它的一些解法通常是从多分类问题延伸而来的，比较复杂。本系列课程不会详细介绍Structured
            Learning，有兴趣的读者可以自行对它进行更深入的研究。</p>

        <p>简单总结一下，机器学习按照输出空间划分的话，包括二元分类、多元分类、回归、结构化学习等不同的类型。其中二元分类和回归是最基础、最核心的两个类型，也是我们课程主要介绍的部分。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/42f7b7f9525d0b9dec6cb751ae179553.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="二learning-with-different-data-label-yn" class="sigil_not_in_toc"><strong>二、Learning with Different Data
                Label yn</strong></h3>

        <p>如果我们拿到的训练样本D既有输入特征x，也有输出yn，那么我们把这种类型的学习称为监督式学习（Supervised
            Learning）。监督式学习可以是二元分类、多元分类或者是回归，最重要的是知道输出标签yn。与监督式学习相对立的另一种类型是非监督式学习（Unsupervised
            learning）。非监督式学习是没有输出标签yn的，典型的非监督式学习包括：聚类（clustering）问题，比如对网页上新闻的自动分类；密度估计，比如交通路况分析；异常检测，比如用户网络流量监测。通常情况下，非监督式学习更复杂一些，而且非监督的问题很多都可以使用监督式学习的一些算法思想来实现。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/027cbda81af889745bbd0bf08263a48e.jpg" alt="这里写图片描述" title="" /></p>

        <p>介于监督式和非监督式学习之间的叫做半监督式学习（Semi-supervised
            Learning）。顾名思义，半监督式学习就是说一部分数据有输出标签yn，而另一部分数据没有输出标签yn。在实际应用中，半监督式学习有时候是必须的，比如医药公司对某些药物进行检测，考虑到成本和实验人群限制等问题，只有一部分数据有输出标签yn。</p>

        <p>监督式、非监督式、半监督式学习是机器学习领域三个主要类型。除此之外，还有一种非常重要的类型：增强学习（Reinforcement
            Learning）。增强学习中，我们给模型或系统一些输入，但是给不了我们希望的真实的输出y，根据模型的输出反馈，如果反馈结果良好，更接近真实输出，就给其正向激励，如果反馈结果不好，偏离真实输出，就给其反向激励。不断通过“反馈-修正”这种形式，一步一步让模型学习的更好，这就是增强学习的核心所在。增强学习可以类比成训练宠物的过程，比如我们要训练狗狗坐下，但是狗狗无法直接听懂我们的指令“sit
            down”。在训练过程中，我们给狗狗示意，如果它表现得好，我们就给他奖励，如果它做跟sit
            down完全无关的动作，我们就给它小小的惩罚。这样不断修正狗狗的动作，最终能让它按照我们的指令来行动。实际生活中，增强学习的例子也很多，比如根据用户点击、选择而不断改进的广告系统</p>

        <p>简单总结一下，机器学习按照数据输出标签yn划分的话，包括监督式学习、非监督式学习、半监督式学习和增强学习等。其中，监督式学习应用最为广泛。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1890d66a62f112b767f018cde3e2e55c.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="三learning-with-different-protocol-fxnyn" class="sigil_not_in_toc"><strong>三、Learning with Different
                Protocol f(xn,yn)</strong></h3>

        <p>按照不同的协议，机器学习可以分为三种类型：</p>

        <ul>
            <li>
                <p>Batch Learning</p>
            </li>
            <li>
                <p>Online</p>
            </li>
            <li>
                <p>Active Learning</p>
            </li>
        </ul>

        <p>batch learning是一种常见的类型。batch learning获得的训练数据D是一批的，即一次性拿到整个D，对其进行学习建模，得到我们最终的机器学习模型。batch learning在实际应用中最为广泛。</p>

        <p>online是一种在线学习模型，数据是实时更新的，根据数据一个个进来，同步更新我们的算法。比如在线邮件过滤系统，根据一封一封邮件的内容，根据当前算法判断是否为垃圾邮件，再根据用户反馈，及时更新当前算法。这是一个动态的过程。之前我们介绍的PLA和增强学习都可以使用online模型。</p>

        <p>active learning是近些年来新出现的一种机器学习类型，即让机器具备主动问问题的能力，例如手写数字识别，机器自己生成一个数字或者对它不确定的手写字主动提问。active
            learning优势之一是在获取样本label比较困难的时候，可以节约时间和成本，只对一些重要的label提出需求。</p>

        <p>简单总结一下，按照不同的协议，机器学习可以分为batch, online, active。这三种学习类型分别可以类比为：填鸭式，老师教学以及主动问问题。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/301228323e003e92233237706a958f91.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="四learning-with-different-input-space-x" class="sigil_not_in_toc"><strong>四、Learning with Different
                Input Space X</strong></h3>

        <p>上面几部分介绍的机器学习分类都是根据输出来分类的，比如根据输出空间进行分类，根据输出y的标记进行分类，根据取得数据和标记的方法进行分类。这部分，我们将谈谈输入X有哪些类型。</p>

        <p>输入X的第一种类型就是concrete features。比如说硬币分类问题中硬币的尺寸、重量等；比如疾病诊断中的病人信息等具体特征。concrete features对机器学习来说最容易理解和使用。</p>

        <p>第二种类型是raw features。比如说手写数字识别中每个数字所在图片的mxn维像素值；比如语音信号的频谱等。raw features一般比较抽象，经常需要人或者机器来转换为其对应的concrete
            features，这个转换的过程就是Feature Transform。</p>

        <p>第三种类型是abstract
            features。比如某购物网站做购买预测时，提供给参赛者的是抽象加密过的资料编号或者ID，这些特征X完全是抽象的，没有实际的物理含义。所以对于机器学习来说是比较困难的，需要对特征进行更多的转换和提取。</p>

        <p>简单总结一下，根据输入X类型不同，可以分为concetet, raw, abstract。将一些抽象的特征转换为具体的特征，是机器学习过程中非常重要的一个环节。在《机器学习技法》课程中，我们再详细介绍。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5b8e649119d0311023e13eff815c3c2c.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="五总结" class="sigil_not_in_toc"><strong>五、总结：</strong></h3>

        <p>本节课主要介绍了机器学习的类型，包括Out Space、Data Label、Protocol、Input Space四种类型。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd9d6af0a6c24e051f85de8085dde493.jpg" alt="这里写图片描述" title="" /></p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习基石》课程。</p>
    </div>

    <h1>
        4 -- Feasibility of Learning

    </h1>
    <div class="markdown_views">
        <p>上节课，我们主要介绍了根据不同的设定，机器学习可以分为不同的类型。其中，监督式学习中的二元分类和回归分析是最常见的也是最重要的机器学习问题。本节课，我们将介绍机器学习的可行性，讨论问题是否可以使用机器学习来解决。</p>

        <h3 id="一learning-is-impossible" class="sigil_not_in_toc"><strong>一、Learning is Impossible</strong></h3>

        <p>首先，考虑这样一个例子，如下图所示，有3个label为-1的九宫格和3个label为+1的九宫格。根据这6个样本，提取相应label下的特征，预测右边九宫格是属于-1还是+1？结果是，如果依据对称性，我们会把它归为+1；如果依据九宫格左上角是否是黑色，我们会把它归为-1。除此之外，还有根据其它不同特征进行分类，得到不同结果的情况。而且，这些分类结果貌似都是正确合理的，因为对于6个训练样本来说，我们选择的模型都有很好的分类效果。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c4912fc4b106a71eb0a6bbaab4bfe73f.jpg" alt="这里写图片描述" title="" /></p>

        <p>再来看一个比较数学化的二分类例子，输入特征x是二进制的、三维的，对应有8种输入，其中训练样本D有5个。那么，根据训练样本对应的输出y，假设有8个hypothesis，这8个hypothesis在D上，对5个训练样本的分类效果效果都完全正确。但是在另外3个测试数据上，不同的hypothesis表现有好有坏。在已知数据D上，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/777c1c6806abe7e3635c0e5443932447.jpg" />；但是在D以外的未知数据上，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/777c1c6806abe7e3635c0e5443932447.jpg" />不一定成立。而机器学习目的，恰恰是希望我们选择的模型能在未知数据上的预测与真实结果是一致的，而不是在已知的数据集D上寻求最佳效果。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8cb724d6c8907309ce8e3c668babf164.jpg" alt="这里写图片描述" title="" /></p>

        <p>这个例子告诉我们，我们想要在D以外的数据中更接近目标函数似乎是做不到的，只能保证对D有很好的分类结果。机器学习的这种特性被称为没有免费午餐（No Free
            Lunch）定理。NFL定理表明没有一个学习算法可以在任何领域总是产生最准确的学习器。不管采用何种学习算法，至少存在一个目标函数，能够使得随机猜测算法是更好的算法。平常所说的一个学习算法比另一个算法更“优越”，效果更好，只是针对特定的问题，特定的先验信息，数据的分布，训练样本的数目，代价或奖励函数等。从这个例子来看，NFL说明了无法保证一个机器学习算法在D以外的数据集上一定能分类或预测正确，除非加上一些假设条件，我们以后会介绍。</p>

        <h3 id="二probability-to-the-rescue" class="sigil_not_in_toc"><strong>二、Probability to the Rescue</strong></h3>

        <p>从上一节得出的结论是：在训练集D以外的样本上，机器学习的模型是很难，似乎做不到正确预测或分类的。那是否有一些工具或者方法能够对未知的目标函数f做一些推论，让我们的机器学习模型能够变得有用呢？</p>

        <p>如果有一个装有很多（数量很大数不过来）橙色球和绿色球的罐子，我们能不能推断橙色球的比例u？统计学上的做法是，从罐子中随机取出N个球，作为样本，计算这N个球中橙色球的比例v，那么就估计出罐子中橙色球的比例约为v。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/15f9d2722823307c158559957d378254.jpg" alt="这里写图片描述" title="" /></p>

        <p>这种随机抽取的做法能否说明罐子里橙色球的比例一定是v呢？答案是否定的。但是从概率的角度来说，样本中的v很有可能接近我们未知的u。下面从数学推导的角度来看v与u是否相近。</p>

        <p>已知u是罐子里橙色球的比例，v是N个抽取的样本中橙色球的比例。当N足够大的时候，v接近于u。这就是Hoeffding’s inequality：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-3">P[|v-u|>\epsilon]\leq 2exp(-2\epsilon^2N)</script>
        </p>

        <p>Hoeffding不等式说明当N很大的时候，v与u相差不会很大，它们之间的差值被限定在<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3ceac491143c898df94d6ebb92cfa25f.jpg" />之内。我们把结论v=u称为probably
            approximately correct(PAC)。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f64fab987011ed7db0989e5053384b39.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="三connection-to-learning" class="sigil_not_in_toc"><strong>三、Connection to Learning</strong></h3>

        <p>下面，我们将罐子的内容对应到机器学习的概念上来。机器学习中hypothesis与目标函数相等的可能性，类比于罐子中橙色球的概率问题；罐子里的一颗颗弹珠类比于机器学习样本空间的x；橙色的弹珠类比于h(x)与f不相等；绿色的弹珠类比于h(x)与f相等；从罐子中抽取的N个球类比于机器学习的训练样本D，且这两种抽样的样本与总体样本之间都是独立同分布的。所以呢，如果样本N够大，且是独立同分布的，那么，从样本中<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/014d5d4e87c2d86bbc8f5f93ab9f0ef7.jpg" />的概率就能推导在抽样样本外的所有样本中<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/014d5d4e87c2d86bbc8f5f93ab9f0ef7.jpg" />的概率是多少。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/422a4a4e35abaca291d0594bbc78966a.jpg" alt="这里写图片描述" title="" /></p>

        <p>映射中最关键的点是讲抽样中橙球的概率理解为样本数据集D上h(x)错误的概率，以此推算出在所有数据上h(x)错误的概率，这也是机器学习能够工作的本质，即我们为啥在采样数据上得到了一个假设，就可以推到全局呢？因为两者的错误率是PAC的，只要我们保证前者小，后者也就小了。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6ab071e96063c210af9dad03d7890ab2.jpg" alt="这里写图片描述" title="" /></p>

        <p>这里我们引入两个值<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d7456181e4a1dc67ec0595e27aa6cb2a.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fe9b1118427000a29a9f9e54d288c701.jpg" />。<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d7456181e4a1dc67ec0595e27aa6cb2a.jpg" />表示在抽样样本中，h(x)与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/48d037eec62d870708acff75f000806d.jpg" />不相等的概率；<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fe9b1118427000a29a9f9e54d288c701.jpg" />表示实际所有样本中，h(x)与f(x)不相等的概率是多少。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cbd827a026cbac360360200496b6ace4.jpg" alt="这里写图片描述" title="" /></p>

        <p>同样，它的Hoeffding’s inequality可以表示为：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-12">P[|E_{in}(h)-E_{out}(h)|>\epsilon]\leq 2exp(-2\epsilon^2N)</script>
        </p>

        <p>该不等式表明，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d7456181e4a1dc67ec0595e27aa6cb2a.jpg" />也是PAC的。如果<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d7456181e4a1dc67ec0595e27aa6cb2a.jpg" />，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d7456181e4a1dc67ec0595e27aa6cb2a.jpg" />很小，那么就能推断出<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fe9b1118427000a29a9f9e54d288c701.jpg" />很小，也就是说在该数据分布P下，h与f非常接近，机器学习的模型比较准确。</p>

        <p>一般地，h如果是固定的，N很大的时候，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d7456181e4a1dc67ec0595e27aa6cb2a.jpg" />，但是并不意味着<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/777c1c6806abe7e3635c0e5443932447.jpg" />。因为h是固定的，不能保证<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d7456181e4a1dc67ec0595e27aa6cb2a.jpg" />足够小，即使<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d7456181e4a1dc67ec0595e27aa6cb2a.jpg" />，也可能使<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fe9b1118427000a29a9f9e54d288c701.jpg" />偏大。所以，一般会通过演算法A，选择最好的h，使<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d7456181e4a1dc67ec0595e27aa6cb2a.jpg" />足够小，从而保证<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fe9b1118427000a29a9f9e54d288c701.jpg" />很小。固定的h，使用新数据进行测试，验证其错误率是多少。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e1489a185d2f234739f2d60cd11f93db.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="四connection-to-real-learning" class="sigil_not_in_toc"><strong>四、Connection to Real Learning</strong></h3>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75f824b59ab187340120505c35679e38.jpg" alt="这里写图片描述" title="" /></p>

        <p>假设现在有很多罐子M个（即有M个hypothesis），如果其中某个罐子抽样的球全是绿色，那是不是应该选择这个罐子呢？我们先来看这样一个例子：150个人抛硬币，那么其中至少有一个人连续5次硬币都是正面朝上的概率是</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-24">1-(\frac{31}{32})^{150}>99\%</script>
        </p>

        <p>可见这个概率是很大的，但是能否说明5次正面朝上的这个硬币具有代表性呢？答案是否定的！并不能说明该硬币单次正面朝上的概率很大，其实都是0.5。一样的道理，抽到全是绿色求的时候也不能一定说明那个罐子就全是绿色球。当罐子数目很多或者抛硬币的人数很多的时候，可能引发Bad
            Sample，Bad Sample就是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c4d371480622b6ea2e62ad466017e7c9.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/02ff91b1115630455f0eaac83fd1a6f4.jpg" />差别很大，即选择过多带来的负面影响，选择过多会恶化不好的情形。</p>

        <p>根据许多次抽样的到的不同的数据集D，Hoeffding’s inequality保证了大多数的D都是比较好的情形（即对于某个h，保证<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c4d371480622b6ea2e62ad466017e7c9.jpg" />），但是也有可能出现Bad
            Data，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c4d371480622b6ea2e62ad466017e7c9.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/02ff91b1115630455f0eaac83fd1a6f4.jpg" />差别很大的数据集D，这是小概率事件。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/975737cb37c1124aa9e8d5ff644ea1f3.jpg" alt="这里写图片描述" title="" /></p>

        <p>也就是说，不同的数据集<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7147db75452155b77c4f943044ef30c4.jpg" />，对于不同的hypothesis，有可能成为Bad Data。只要<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7147db75452155b77c4f943044ef30c4.jpg" />在某个hypothesis上是Bad Data，那么<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7147db75452155b77c4f943044ef30c4.jpg" />就是Bad
            Data。只有当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7147db75452155b77c4f943044ef30c4.jpg" />在所有的hypothesis上都是好的数据，才说明<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7147db75452155b77c4f943044ef30c4.jpg" />不是Bad
            Data，可以自由选择演算法A进行建模。那么，根据Hoeffding’s inequality，Bad Data的上界可以表示为连级（union bound）的形式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3e987fcc8d8ee3395d800efa97d30a76.jpg" alt="这里写图片描述" title="" /></p>

        <p>其中，M是hypothesis的个数，N是样本D的数量，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3ceac491143c898df94d6ebb92cfa25f.jpg" />是参数。该union
            bound表明，当M有限，且N足够大的时候，Bad Data出现的概率就更低了，即能保证D对于所有的h都有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c4d371480622b6ea2e62ad466017e7c9.jpg" />，满足PAC，演算法A的选择不受限制。那么满足这种union
            bound的情况，我们就可以和之前一样，选取一个合理的演算法（PLA/pocket），选择使<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c4d371480622b6ea2e62ad466017e7c9.jpg" />最小的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/805c7ce97d4ef084bcbe43d0b12d7d0f.jpg" />作为矩g，一般能够保证<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/777c1c6806abe7e3635c0e5443932447.jpg" />，即有不错的泛化能力。</p>

        <p>所以，如果hypothesis的个数M是有限的，N足够大，那么通过演算法A任意选择一个矩g，都有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c4d371480622b6ea2e62ad466017e7c9.jpg" />成立；同时，如果找到一个矩g，使<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c4d371480622b6ea2e62ad466017e7c9.jpg" />，PAC就能保证<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/02ff91b1115630455f0eaac83fd1a6f4.jpg" />。至此，就证明了机器学习是可行的。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ac553e6c89d844665df47903b119eab5.jpg" alt="这里写图片描述" title="" /></p>

        <p>但是，如上面的学习流程图右下角所示，如果M是无数个，例如之前介绍的PLA直线有无数条，是否这些推论就不成立了呢？是否机器就不能进行学习呢？这些内容和问题，我们下节课再介绍。</p>

        <h3 id="五总结" class="sigil_not_in_toc"><strong>五、总结</strong></h3>

        <p>本节课主要介绍了机器学习的可行性。首先引入NFL定理，说明机器学习无法找到一个矩g能够完全和目标函数f一样。接着介绍了可以采用一些统计上的假设，例如Hoeffding不等式，建立<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c4d371480622b6ea2e62ad466017e7c9.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/02ff91b1115630455f0eaac83fd1a6f4.jpg" />的联系，证明对于某个h，当N足够大的时候，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c4d371480622b6ea2e62ad466017e7c9.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/02ff91b1115630455f0eaac83fd1a6f4.jpg" />是PAC的。最后，对于h个数很多的情况，只要有h个数M是有限的，且N足够大，就能保证<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c4d371480622b6ea2e62ad466017e7c9.jpg" />，证明机器学习是可行的。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习基石》课程。</p>
    </div>

    <h1>
        5 -- Training versus Testing

    </h1>
    <div class="markdown_views">
        <p>上节课，我们主要介绍了机器学习的可行性。首先，由NFL定理可知，机器学习貌似是不可行的。但是，随后引入了统计学知识，如果样本数据足够大，且hypothesis个数有限，那么机器学习一般就是可行的。本节课将讨论机器学习的核心问题，严格证明为什么机器可以学习。从上节课最后的问题出发，即当hypothesis的个数是无限多的时候，机器学习的可行性是否仍然成立？</p>

        <h3 id="一recap-and-preview" class="sigil_not_in_toc"><strong>一、Recap and Preview</strong></h3>

        <p>我们先来看一下基于统计学的机器学习流程图：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d4d611e1cde44e47a847daee299e34aa.jpg" alt="这里写图片描述" title="" /></p>

        <p>该流程图中，训练样本D和最终测试h的样本都是来自同一个数据分布，这是机器能够学习的前提。另外，训练样本D应该足够大，且hypothesis set的个数是有限的，这样根据霍夫丁不等式，才不会出现Bad Data，保证<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/10a4dae1cec5139479645b24e2d5bac7.jpg" />，即有很好的泛化能力。同时，通过训练，得到使<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/88932c7439f7a0027095882f92530e11.jpg" />最小的h，作为模型最终的矩g，g接近于目标函数。</p>

        <p>这里，我们总结一下前四节课的主要内容：第一节课，我们介绍了机器学习的定义，目标是找出最好的矩g，使<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7752b07a006d650d158f817d75bd73b2.jpg" />，保证<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/31fe209114ce4d8ba43e0a1ed9bb700c.jpg" />；第二节课，我们介绍了如何让<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/88932c7439f7a0027095882f92530e11.jpg" />，可以使用PLA、pocket等演算法来实现；第三节课，我们介绍了机器学习的分类，我们的训练样本是批量数据（batch），处理监督式（supervised）二元分类（binary
            classification）问题；第四节课，我们介绍了机器学习的可行性，通过统计学知识，把<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/88932c7439f7a0027095882f92530e11.jpg" />与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4418c9184ff74a48310d23cad2779bbb.jpg" />联系起来，证明了在一些条件假设下，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/88932c7439f7a0027095882f92530e11.jpg" />成立。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4a3a79987b60d91f6dff1723fa5cc43f.jpg" alt="这里写图片描述" title="" /></p>

        <p>这四节课总结下来，我们把机器学习的主要目标分成两个核心的问题：</p>

        <ul>
            <li>
                <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/88932c7439f7a0027095882f92530e11.jpg" /></p>
            </li>
            <li>
                <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/88932c7439f7a0027095882f92530e11.jpg" />足够小</p>
            </li>
        </ul>

        <p>上节课介绍的机器学习可行的一个条件是hypothesis set的个数M是有限的，那M跟上面这两个核心问题有什么联系呢？</p>

        <p>我们先来看一下，当M很小的时候，由上节课介绍的霍夫丁不等式，得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/88932c7439f7a0027095882f92530e11.jpg" />，即能保证第一个核心问题成立。但M很小时，演算法A可以选择的hypothesis有限，不一定能找到使<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/88932c7439f7a0027095882f92530e11.jpg" />足够小的hypothesis，即不能保证第二个核心问题成立。当M很大的时候，同样由霍夫丁不等式，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/88932c7439f7a0027095882f92530e11.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4418c9184ff74a48310d23cad2779bbb.jpg" />的差距可能比较大，第一个核心问题可能不成立。而M很大，使的演算法A的可以选择的hypothesis就很多，很有可能找到一个hypothesis，使<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/88932c7439f7a0027095882f92530e11.jpg" />足够小，第二个核心问题可能成立。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/515657ef4f74ecb1e625faf55c2561f5.jpg" alt="这里写图片描述" title="" /></p>

        <p>从上面的分析来看，M的选择直接影响机器学习两个核心问题是否满足，M不能太大也不能太小。那么如果M无限大的时候，是否机器就不可以学习了呢？例如PLA算法中直线是无数条的，但是PLA能够很好地进行机器学习，这又是为什么呢？如果我们能将无限大的M限定在一个有限的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/492c221de7c92ebe91289195611c018d.jpg" />内，问题似乎就解决了。</p>

        <h3 id="二effective-number-of-line" class="sigil_not_in_toc"><strong>二、Effective Number of Line</strong></h3>

        <p>我们先看一下上节课推导的霍夫丁不等式：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-17">P[|E_{in}(g)-E_{out}(g)|>\epsilon]\leq 2\cdot M\cdot exp(-2\epsilon^2N)</script>
        </p>

        <p>其中，M表示hypothesis的个数。每个hypothesis下的BAD events <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6d273c6f30ef79a7f95288318ceb74fa.jpg" />级联的形式满足下列不等式：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-19">P[B_1\ or\ B_2\ or\ \cdots B_M]\leq P[B_1]+P[B_2]+\cdots+P[B_M]</script>
        </p>

        <p>当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c1903a9f9905c6ff6e894fd0d56e0bba.jpg" />时，上面不等式右边值将会很大，似乎说明BAD events很大，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/88932c7439f7a0027095882f92530e11.jpg" />与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4418c9184ff74a48310d23cad2779bbb.jpg" />也并不接近。但是BAD events <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6d273c6f30ef79a7f95288318ceb74fa.jpg" />级联的形式实际上是扩大了上界，union
            bound过大。这种做法假设各个hypothesis之间没有交集，这是最坏的情况，可是实际上往往不是如此，很多情况下，都是有交集的，也就是说M实际上没那么大，如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5b3bc7e09c268c58482ab0a9d2694515.jpg" alt="这里写图片描述" title="" /></p>

        <p>也就是说union bound被估计过高了（over-estimating）。所以，我们的目的是找出不同BAD events之间的重叠部分，也就是将无数个hypothesis分成有限个类别。</p>

        <p>如何将无数个hypothesis分成有限类呢？我们先来看这样一个例子，假如平面上用直线将点分开，也就跟PLA一样。如果平面上只有一个点x1，那么直线的种类有两种：一种将x1划为+1，一种将x1划为-1：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/10f1124294e47c6e25f06b8112df0375.jpg" alt="这里写图片描述" title="" /></p>

        <p>如果平面上有两个点x1、x2，那么直线的种类共4种：x1、x2都为+1，x1、x2都为-1，x1为+1且x2为-1，x1为-1且x2为+1：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/343b2affaea086aa393dc4728514c6f5.jpg" alt="这里写图片描述" title="" /></p>

        <p>如果平面上有三个点x1、x2、x3，那么直线的种类共8种：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cfc2fa7880a02679c63f6863ae6dc4aa.jpg" alt="这里写图片描述" title="" /></p>

        <p>但是，在三个点的情况下，也会出现不能用一条直线划分的情况：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9e6dad04106cafdddc7c53fb11073fb3.jpg" alt="这里写图片描述" title="" /></p>

        <p>也就是说，对于平面上三个点，不能保证所有的8个类别都能被一条直线划分。那如果是四个点x1、x2、x3、x4，我们发现，平面上找不到一条直线能将四个点组成的16个类别完全分开，最多只能分开其中的14类，即直线最多只有14种：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2cb0459146a5948ee0b85bd32a897f36.jpg" alt="这里写图片描述" title="" /></p>

        <p>经过分析，我们得到平面上线的种类是有限的，1个点最多有2种线，2个点最多有4种线，3个点最多有8种线，4个点最多有14（<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4243463ae8bbaad7b7ab9f781d0b0424.jpg" />）种线等等。我们发现，有效直线的数量总是满足<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3c884fbbada83b4df889aa99e7ab5941.jpg" />，其中，N是点的个数。所以，如果我们可以用effective(N)代替M，霍夫丁不等式可以写成：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-26">P[|E_{in}(g)-E_{out}(g)|>\epsilon]\leq 2\cdot effective(N)\cdot exp(-2\epsilon^2N)</script>
        </p>

        <p>已知effective(N)&lt;<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/159eaf12f34ccf7fa235f448748ec23b.jpg" />，如果能够保证effective(N)&lt;&lt;<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/159eaf12f34ccf7fa235f448748ec23b.jpg" />，即不等式右边接近于零，那么即使M无限大，直线的种类也很有限，机器学习也是可能的。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/894b9209fae5660943ca79dadf141471.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="三effective-number-of-hypotheses" class="sigil_not_in_toc"><strong>三、Effective Number of Hypotheses</strong></h3>

        <p>接下来先介绍一个新名词：二分类（dichotomy）。dichotomy就是将空间中的点（例如二维平面）用一条直线分成正类（蓝色o）和负类（红色x）。令H是将平面上的点用直线分开的所有hypothesis
            h的集合，dichotomy H与hypotheses H的关系是：hypotheses H是平面上所有直线的集合，个数可能是无限个，而dichotomy H是平面上能将点完全用直线分开的直线种类，它的上界是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/159eaf12f34ccf7fa235f448748ec23b.jpg" />。接下来，我们要做的就是尝试用dichotomy代替M。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/80fef61e7ef1c22b65b111edc0d44b84.jpg" alt="这里写图片描述" title="" /></p>

        <p>再介绍一个新的名词：成长函数（growth function），记为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/492c221de7c92ebe91289195611c018d.jpg" />。成长函数的定义是：对于由N个点组成的不同集合中，某集合对应的dichotomy最大，那么这个dichotomy值就是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/492c221de7c92ebe91289195611c018d.jpg" />，它的上界是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/159eaf12f34ccf7fa235f448748ec23b.jpg" />：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b9b6be119129e41c22d02cd57df58eb7.jpg" alt="这里写图片描述" title="" /></p>

        <p>成长函数其实就是我们之前讲的effective lines的数量最大值。根据成长函数的定义，二维平面上，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/492c221de7c92ebe91289195611c018d.jpg" />随N的变化关系是：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f2089254d3581f0327f559b18a38bbfb.jpg" alt="这里写图片描述" title="" /></p>

        <p>接下来，我们讨论如何计算成长函数。先看一个简单情况，一维的Positive Rays：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b006be7b1e918f78dd6f9211023195ce.jpg" alt="这里写图片描述" title="" /></p>

        <p>若有N个点，则整个区域可分为N+1段，很容易得到其成长函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/492c221de7c92ebe91289195611c018d.jpg" />。注意当N很大时，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/eb2a34db68421a63aa6751d9d25d7c7f.jpg" />，这是我们希望看到的。</p>

        <p>另一种情况是一维的Positive Intervals：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dfc7d98d33e91b28688d996844a7c1ab.jpg" alt="这里写图片描述" title="" /></p>

        <p>它的成长函数可以由下面推导得出：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/01ca5ad564ffd99d6f9bf0b29552032f.jpg" alt="这里写图片描述" title="" /></p>

        <p>这种情况下，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/492c221de7c92ebe91289195611c018d.jpg" />，在N很大的时候，仍然是满足的。</p>

        <p>再来看这个例子，假设在二维空间里，如果hypothesis是凸多边形或类圆构成的封闭曲线，如下图所示，左边是convex的，右边不是convex的。那么，它的成长函数是多少呢？</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fda778820036a7d6c87d960bc99f27cc.jpg" alt="这里写图片描述" title="" /></p>

        <p>当数据集D按照如下的凸分布时，我们很容易计算得到它的成长函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/492c221de7c92ebe91289195611c018d.jpg" />。这种情况下，N个点所有可能的分类情况都能够被hypotheses
            set覆盖，我们把这种情形称为shattered。也就是说，如果能够找到一个数据分布集，hypotheses set对N个输入所有的分类情况都做得到，那么它的成长函数就是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/159eaf12f34ccf7fa235f448748ec23b.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8e877ce4ae32d59208285b20183577c5.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="四break-point" class="sigil_not_in_toc"><strong>四、Break Point</strong></h3>

        <p>上一小节，我们介绍了四种不同的成长函数，分别是：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a67ab6e15d74a733b70fcd8c8f8d18c7.jpg" alt="这里写图片描述" title="" /></p>

        <p>其中，positive rays和positive intervals的成长函数都是polynomial的，如果用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/492c221de7c92ebe91289195611c018d.jpg" />代替M的话，这两种情况是比较好的。而convex
            sets的成长函数是exponential的，即等于M，并不能保证机器学习的可行性。那么，对于2D perceptrons，它的成长函数究竟是polynomial的还是exponential的呢？</p>

        <p>对于2D perceptrons，我们之前分析了3个点，可以做出8种所有的dichotomy，而4个点，就无法做出所有16个点的dichotomy了。所以，我们就把4称为2D perceptrons的break
            point（5、6、7等都是break point）。令有k个点，如果k大于等于break point时，它的成长函数一定小于2的k次方。</p>

        <p>根据break point的定义，我们知道满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/492c221de7c92ebe91289195611c018d.jpg" />的k的最小值就是break
            point。对于我们之前介绍的四种成长函数，他们的break point分别是：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/464bc2b6cc1c88d2ca74f3d31071e434.jpg" alt="这里写图片描述" title="" /></p>

        <p>通过观察，我们猜测成长函数可能与break point存在某种关系：对于convex sets，没有break point，它的成长函数是2的N次方；对于positive rays，break point
            k=2，它的成长函数是O(N)；对于positive intervals，break point k=3，它的成长函数是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9dfa6d1f3f1817b8a29acbc48a98f25d.jpg" />。则根据这种推论，我们猜测2D
            perceptrons，它的成长函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/492c221de7c92ebe91289195611c018d.jpg" /> 。如果成立，那么就可以用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/492c221de7c92ebe91289195611c018d.jpg" />代替M，就满足了机器能够学习的条件。关于上述猜测的证明，我们下节课再详细介绍。</p>

        <h3 id="五总结" class="sigil_not_in_toc"><strong>五、总结</strong></h3>

        <p>本节课，我们更深入地探讨了机器学习的可行性。我们把机器学习拆分为两个核心问题：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/88932c7439f7a0027095882f92530e11.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/88932c7439f7a0027095882f92530e11.jpg" />。对于第一个问题，我们探讨了M个hypothesis到底可以划分为多少种，也就是成长函数<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/492c221de7c92ebe91289195611c018d.jpg" />。并引入了break point的概念，给出了break
            point的计算方法。下节课，我们将详细论证对于2D perceptrons，它的成长函数与break point是否存在多项式的关系，如果是这样，那么机器学习就是可行的。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习基石》课程。</p>
    </div>

    <h1>
        6 -- Theory of Generalization

    </h1>
    <div class="markdown_views">
        <p>上一节课，我们主要探讨了当M的数值大小对机器学习的影响。如果M很大，那么就不能保证机器学习有很好的泛化能力，所以问题转换为验证M有限，即最好是按照多项式成长。然后通过引入了成长函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />和dichotomy以及break
            point的概念，提出2D perceptrons的成长函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />是多项式级别的猜想。这就是本节课将要深入探讨和证明的内容。</p>

        <h3 id="一restriction-of-break-point" class="sigil_not_in_toc"><strong>一、Restriction of Break Point</strong></h3>

        <p>我们先回顾一下上节课的内容，四种成长函数与break point的关系：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/04f493664b201b8df9c53b61298cab13.jpg" alt="这里写图片描述" title="" /></p>

        <p>下面引入一个例子，如果k=2，那么当N取不同值的时候，计算其成长函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />是多少。很明显，当N=1时，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />=2,；当N=2时，由break
            point为2可知，任意两点都不能被shattered（shatter的意思是对N个点，能够分解为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7cd97d730040fe395178281c9bcd2896.jpg" />种dichotomies）；<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />最大值只能是3；当N=3时，简单绘图分析可得其<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />，即最多只有4种dichotomies。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e35fe0cc5f978367608fbe0832b89876.jpg" alt="这里写图片描述" title="" /></p>

        <p>所以，我们发现当N&gt;k时，break point限制了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />值的大小，也就是说影响成长函数<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />的因素主要有两个：</p>

        <ul>
            <li>
                <p>抽样数据集N</p>
            </li>
            <li>
                <p>break point k（这个变量确定了假设的类型）</p>
            </li>
        </ul>

        <p>那么，如果给定N和k，能够证明其<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />的最大值的上界是多项式的，则根据霍夫丁不等式，就能用<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />代替M，得到机器学习是可行的。所以，证明<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />的上界是poly(N)，是我们的目标。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d93b83928aca7ad49c974a734e903c75.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="二bounding-function-basic-cases" class="sigil_not_in_toc"><strong>二、Bounding Function: Basic Cases</strong></h3>

        <p>现在，我们引入一个新的函数：bounding function，B(N,k)。Bound Function指的是当break point为k的时候，成长函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />可能的最大值。也就是说B(N,k)是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />的上界，对应<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />最多有多少种dichotomy。那么，我们新的目标就是证明：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-16">B(N,k)\leq poly(N)</script>
        </p>

        <p>这里值得一提的是，B(N,k)的引入不考虑是1D postive intrervals问题还是2D perceptrons问题，而只关心成长函数的上界是多少，从而简化了问题的复杂度。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8b0d2ebec1dc8e39584706453f0e95ea.jpg" alt="这里写图片描述" title="" /></p>

        <p>求解B(N,k)的过程十分巧妙：</p>

        <ul>
            <li>
                <p>当k=1时，B(N,1)恒为1。</p>
            </li>
            <li>
                <p>当N &lt; k时，根据break point的定义，很容易得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/458d09662b917b59905548a3993e96cc.jpg" />。</p>
            </li>
            <li>
                <p>当N = k时，此时N是第一次出现不能被shatter的值，所以最多只能有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7cd97d730040fe395178281c9bcd2896.jpg" />个dichotomies，则<img
                        src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/458d09662b917b59905548a3993e96cc.jpg" />。</p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3b23bef628d9fbafbf28bc252d02cb09.jpg" alt="这里写图片描述" title="" /></p>

        <p>到此，bounding function的表格已经填了一半了，对于最常见的N&gt;k的情况比较复杂，推导过程下一小节再详细介绍。</p>

        <h3 id="三bounding-function-inductive-cases" class="sigil_not_in_toc"><strong>三、Bounding Function: Inductive
                Cases</strong></h3>

        <p>N &gt; k的情况较为复杂，下面给出推导过程：</p>

        <p>以B(4,3)为例，首先想着能否构建B(4,3)与B(3,x)之间的关系。</p>

        <p>首先，把B(4,3)所有情况写下来，共有11组。也就是说再加一种dichotomy，任意三点都能被shattered，11是极限。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2c425af1bda39d5d4fdb515dba5f683c.jpg" alt="这里写图片描述" title="" /></p>

        <p>对这11种dichotomy分组，目前分成两组，分别是orange和purple，orange的特点是，x1,x2和x3是一致的，x4不同并成对，例如1和5，2和8等，purple则是单一的，x1,x2,x3都不同，如6,7,9三组。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a28d9ac1bc94143c369fa4385a0c8606.jpg" alt="这里写图片描述" title="" /></p>

        <p>将Orange去掉x4后去重得到4个不同的vector并成为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4b816d9a6c9d8dc65312017e305289d0.jpg" />，相应的purple为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/19eb420f01ddee8a442203359e539f63.jpg" />。那么<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/26491f4fd30de6f0330fd2bd7e364b44.jpg" />，这个是直接转化。紧接着，由定义，B(4,3)是不能允许任意三点shatter的，所以由<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4b816d9a6c9d8dc65312017e305289d0.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/19eb420f01ddee8a442203359e539f63.jpg" />构成的所有三点组合也不能shatter（alpha经过去重），即<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4b816d9a6c9d8dc65312017e305289d0.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0f72079b59b2c590934d6fbc97f49b86.jpg" alt="这里写图片描述" title="" /></p>

        <p>另一方面，由于<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4b816d9a6c9d8dc65312017e305289d0.jpg" />中x4是成对存在的，且<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4b816d9a6c9d8dc65312017e305289d0.jpg" />是不能被任意三点shatter的，则能推导出<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4b816d9a6c9d8dc65312017e305289d0.jpg" />是不能被任意两点shatter的。这是因为，如果<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4b816d9a6c9d8dc65312017e305289d0.jpg" />是不能被任意两点shatter，而x4又是成对存在的，那么x1、x2、x3、x4组成的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4b816d9a6c9d8dc65312017e305289d0.jpg" />必然能被三个点shatter。这就违背了条件的设定。这个地方的推导非常巧妙，也解释了为什么会这样分组。此处得到的结论是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4b816d9a6c9d8dc65312017e305289d0.jpg" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/62b7e9853cf1e2c93e36e734684ffedc.jpg" alt="这里写图片描述" title="" /></p>

        <p>由此得出B(4,3)与B(3,x)的关系为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b70c0e4f3f5acaff10bb2ed9b63af571.jpg" alt="这里写图片描述" title="" /></p>

        <p>最后，推导出一般公式为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/16f8ad8a2b62816f059ac3bf3ed190a5.jpg" alt="这里写图片描述" title="" /></p>

        <p>根据推导公式，下表给出B(N,K)值</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ae00d20e35b7b5ba26fda3c392c3be6d.jpg" alt="这里写图片描述" title="" /></p>

        <p>根据递推公式，推导出B(N,K)满足下列不等式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ff23be6e6b260123571f2b06d03610d1.jpg" alt="这里写图片描述" title="" /></p>

        <p>上述不等式的右边是最高阶为k-1的N多项式，也就是说成长函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />的上界B(N,K)的上界满足多项式分布poly(N)，这就是我们想要得到的结果。</p>

        <p>得到了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />的上界B(N,K)的上界满足多项式分布poly(N)后，我们回过头来看看之前介绍的几种类型它们的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />与break point的关系：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b274867af01a89518824fc6395aa4e50.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们得到的结论是，对于2D perceptrons，break point为k=4，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />的上界是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e8576a0230698c0e77c5527cd1727568.jpg" />。推广一下，也就是说，如果能找到一个模型的break
            point，且是有限大的，那么就能推断出其成长函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />有界。</p>

        <h3 id="四a-pictorial-proof" class="sigil_not_in_toc"><strong>四、A Pictorial Proof</strong></h3>

        <p>我们已经知道了成长函数的上界是poly(N)的，下一步，如果能将<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />代替M，代入到Hoffding不等式中，就能得到<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/775a32097a04956d0512e64ffb9c0fb4.jpg" />的结论：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/56bdd9b5ca1eb9619f4b4bed3a1be4e0.jpg" alt="这里写图片描述" title="" /></p>

        <p>实际上并不是简单的替换就可以了，正确的表达式为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2335ae24f94e920920f39ab0664a756d.jpg" alt="这里写图片描述" title="" /></p>

        <p>该推导的证明比较复杂，我们可以简单概括为三个步骤来证明：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e0333ab9074c1b4afadfd11d448a5f53.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7b8f0bee962842fa8de95a3990251150.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/862f46fc4f65abf0ef3e91350620320d.jpg" alt="这里写图片描述" title="" /></p>

        <p>这部分内容，我也只能听个大概内容，对具体的证明过程有兴趣的童鞋可以自行研究一下，研究的结果记得告诉一下我哦。</p>

        <p>最终，我们通过引入成长函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b119518687af4f52fd05706b858d5b4e.jpg" />，得到了一个新的不等式，称为Vapnik-Chervonenkis(VC)
            bound：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bfe096b23bc59dc545bade37df21c182.jpg" alt="这里写图片描述" title="" /></p>

        <p>对于2D perceptrons，它的break point是4，那么成长函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />。所以，我们可以说2D
            perceptrons是可以进行机器学习的，只要找到hypothesis能让<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1737a139505385980c969238ed819727.jpg" />，就能保证<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8bc76a1f5706eb9d7282ce1655f95eb4.jpg" />。</p>

        <h3 id="五总结" class="sigil_not_in_toc"><strong>五、总结</strong></h3>

        <p>本节课我们主要介绍了只要存在break point，那么其成长函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />就满足poly(N)。推导过程是先引入<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />的上界B(N,k)，B(N,k)的上界是N的k-1阶多项式，从而得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />的上界就是N的k-1阶多项式。然后，我们通过简单的三步证明，将<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5dfc1d72d3bc59070321b6dc617fce2.jpg" />代入了Hoffding不等式中，推导出了Vapnik-Chervonenkis(VC)
            bound，最终证明了只要break point存在，那么机器学习就是可行的。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习基石》课程。</p>
    </div>

    <h1>
        7 -- The VC Dimension

    </h1>
    <div class="markdown_views">
        <p>前几节课着重介绍了机器能够学习的条件并做了详细的推导和解释。机器能够学习必须满足两个条件：</p>

        <ul>
            <li><strong>假设空间H的Size M是有限的，即当N足够大的时候，那么对于假设空间中任意一个假设g，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f414f6c0d01c45a4656efaecfbcce3e9.jpg" /></strong>。</li>
            <li><strong>利用算法A从假设空间H中，挑选一个g，使<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e6d085f2f5b3c5ac156b93b931cf1aaf.jpg" />，则<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fabc6ef6eee191794e6e61f6b3fa8453.jpg" /></strong>。</li>
        </ul>

        <p>这两个条件，正好对应着test和trian两个过程。train的目的是使损失期望<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e6d085f2f5b3c5ac156b93b931cf1aaf.jpg" />；test的目的是使将算法用到新的样本时的损失期望也尽可能小，即<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fabc6ef6eee191794e6e61f6b3fa8453.jpg" />。</p>

        <p>正因为如此，上次课引入了break point，并推导出只要break point存在，则M有上界，一定存在<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f414f6c0d01c45a4656efaecfbcce3e9.jpg" />。</p>

        <p>本次笔记主要介绍VC Dimension的概念。同时也是总结VC Dimension与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e6d085f2f5b3c5ac156b93b931cf1aaf.jpg" />，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fabc6ef6eee191794e6e61f6b3fa8453.jpg" />，Model Complexity Penalty（下面会讲到）的关系。</p>

        <h3 id="一definition-of-vc-dimension" class="sigil_not_in_toc"><strong>一、Definition of VC Dimension</strong></h3>

        <p>首先，我们知道如果一个假设空间H有break point k，那么它的成长函数是有界的，它的上界称为Bound function。根据数学归纳法，Bound function也是有界的，且上界为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1c802837e2ff8555d27b6c504fa4aaa0.jpg" />。从下面的表格可以看出，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d585e715f76b1770b71b39ec58406698.jpg" />比B(N,k)松弛很多。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/65438447a6404dacb7adf69ce1b84c57.jpg" alt="这里写图片描述" title="" /></p>

        <p>则根据上一节课的推导，VC bound就可以转换为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1a241a5e97470e36b6e837ca1c6b7c8f.jpg" alt="这里写图片描述" title="" /></p>

        <p>这样，不等式只与k和N相关了，一般情况下样本N足够大，所以我们只考虑k值。有如下结论：</p>

        <ul>
            <li>
                <p><strong>若假设空间H有break point k，且N足够大，则根据VC bound理论，算法有良好的泛化能力</strong></p>
            </li>
            <li>
                <p><strong>在假设空间中选择一个矩g，使<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d89ccd61d9eb513dd34ee152f11e6f1e.jpg" />，则其在全集数据中的错误率会较低</strong></p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a5ca7210e5d1a3867c442706075b3364.jpg" alt="这里写图片描述" title="" /></p>

        <p>下面介绍一个新的名词：VC Dimension。VC Dimension就是某假设集H能够shatter的最多inputs的个数，即最大完全正确的分类能力。（注意，只要存在一种分布的inputs能够正确分类也满足）。</p>

        <p>shatter的英文意思是“粉碎”，也就是说对于inputs的所有情况都能列举出来。例如对N个输入，如果能够将<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b2c6525e1b53f5de75304b2103b8f5a2.jpg" />种情况都列出来，则称该N个输入能够被假设集H
            shatter。</p>

        <p>根据之前break point的定义：假设集不能被shatter任何分布类型的inputs的最少个数。则VC Dimension等于break point的个数减一。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d9c6888aa7b6a1aeab0b966821eaf7f7.jpg" alt="这里写图片描述" title="" /></p>

        <p>现在，我们回顾一下之前介绍的四种例子，它们对应的VC Dimension是多少：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/68d0bc0cf15ef728557a7a402eda4333.jpg" alt="这里写图片描述" title="" /></p>

        <p>用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />代替k，那么VC bound的问题也就转换为与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />和N相关了。同时，如果一个假设集H的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />确定了，则就能满足机器能够学习的第一个条件<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f414f6c0d01c45a4656efaecfbcce3e9.jpg" />，与算法、样本数据分布和目标函数都没有关系。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/494b1b5f42ccd206e34c5bf81d269b8e.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="二vc-dimension-of-perceptrons" class="sigil_not_in_toc"><strong>二、VC Dimension of Perceptrons </strong></h3>

        <p>回顾一下我们之前介绍的2D下的PLA算法，已知Perceptrons的k=4，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />。根据VC
            Bound理论，当N足够大的时候，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0cb06285659684a121aa7e03b9d43134.jpg" />。如果找到一个g，使<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5f7fa28afc832c40a19b20c56cd5497d.jpg" />，那么就能证明PLA是可以学习的。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c39a6ed2181b71cd40194ec64f9df985.jpg" alt="这里写图片描述" title="" /></p>

        <p>这是在2D情况下，那如果是多维的Perceptron，它对应的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />又等于多少呢？</p>

        <p>已知在1D Perceptron，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />，在2D Perceptrons，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />，那么我们有如下假设：<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />，其中d为维数。</p>

        <p>要证明的话，只需分两步证明：</p>

        <ul>
            <li><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" /></li>
            <li><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" /></li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b77632a86d53ec6e0992ff34b5f47ac3.jpg" alt="这里写图片描述" title="" /></p>

        <p>首先证明第一个不等式：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />。</p>

        <p>在d维里，我们只要找到某一类的d+1个inputs可以被shatter的话，那么必然得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />。所以，我们有意构造一个d维的矩阵<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1147960c1c23d8dc45d182a5f97785a4.jpg" />能够被shatter就行。<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1147960c1c23d8dc45d182a5f97785a4.jpg" />是d维的，有d+1个inputs，每个inputs加上第零个维度的常数项1，得到<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1147960c1c23d8dc45d182a5f97785a4.jpg" />的矩阵：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d343eaf7d931622ab9c5a18bcb2da7c3.jpg" alt="这里写图片描述" title="" /></p>

        <p>矩阵中，每一行代表一个inputs，每个inputs是d+1维的，共有d+1个inputs。这里构造的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1147960c1c23d8dc45d182a5f97785a4.jpg" />很明显是可逆的。shatter的本质是假设空间H对<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1147960c1c23d8dc45d182a5f97785a4.jpg" />的所有情况的判断都是对的，即总能找到权重W，满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1147960c1c23d8dc45d182a5f97785a4.jpg" />，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/402b6f3e239916446e4ddb6dfb487d13.jpg" />。由于这里我们构造的矩阵<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1147960c1c23d8dc45d182a5f97785a4.jpg" />的逆矩阵存在，那么d维的所有inputs都能被shatter，也就证明了第一个不等式。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/846ab1576112dba66499d6bbd45cddd7.jpg" alt="这里写图片描述" title="" /></p>

        <p>然后证明第二个不等式：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />。</p>

        <p>在d维里，如果对于任何的d+2个inputs，一定不能被shatter，则不等式成立。我们构造一个任意的矩阵<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1147960c1c23d8dc45d182a5f97785a4.jpg" />，其包含d+2个inputs，该矩阵有d+1列，d+2行。这d+2个向量的某一列一定可以被另外d+1个向量线性表示，例如对于向量<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1147960c1c23d8dc45d182a5f97785a4.jpg" />，可表示为： <br />
            <script type="math/tex; mode=display" id="MathJax-Element-39">X_{d+2}=a_1\ast X_1+a_2\ast X_2+\cdots+a_d\ast X_d</script>
        </p>

        <p>其中，假设<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ed4df0177082a678ddda7cf9f1b763cd.jpg" />，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4a42f9a7dcd77596f77d07806401e190.jpg" />.</p>

        <p>那么如果<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1147960c1c23d8dc45d182a5f97785a4.jpg" />是正类，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1147960c1c23d8dc45d182a5f97785a4.jpg" />均为负类，则存在<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/207b8020a44212d6583b9a9a508eaf27.jpg" />，得到如下表达式： <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1147960c1c23d8dc45d182a5f97785a4.jpg" />
            <font color="#0000ff"><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/87f48f3e65043ed2ce3c7be04fb1b2fa.jpg" /></font>+<font color="#ff0000"><img
                    src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d15fd89e8ee09367b46f5d67b8deafc2.jpg" /></font>+<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bfcaf05c391bf5e95b0123077b1793bb.jpg" />+<font
                color="#ff0000"><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d59543d0e11f3be964667fa1cd0aa6f1.jpg" /></font><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e06d0d70da65d0d75d43554b0fcfd918.jpg" />
        </p>

        <p>因为其中蓝色项大于0，代表正类；红色项小于0，代表负类。所有对于这种情况，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1147960c1c23d8dc45d182a5f97785a4.jpg" />一定是正类，无法得到负类的情况。也就是说，d+2个inputs无法被shatter。证明完毕！</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7b63d1d73456e3b08d3d8528dd085985.jpg" alt="这里写图片描述" title="" /></p>

        <p>综上证明可得<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />。</p>

        <h3 id="三physical-intuition-vc-dimension" class="sigil_not_in_toc"><strong>三、Physical Intuition VC Dimension</strong></h3>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/11bfe1c44d49f8d52587556bd70a9dfb.jpg" alt="这里写图片描述" title="" /></p>

        <p>上节公式中<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/207b8020a44212d6583b9a9a508eaf27.jpg" />又名features，即自由度。自由度是可以任意调节的，如同上图中的旋钮一样，可以调节。VC
            Dimension代表了假设空间的分类能力，即反映了H的自由度，产生dichotomy的数量，也就等于features的个数，但也不是绝对的。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/79fb72999312ff07fbe285f50b3a39cc.jpg" alt="这里写图片描述" title="" /></p>

        <p>例如，对2D Perceptrons，线性分类，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />，则<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/207b8020a44212d6583b9a9a508eaf27.jpg" />，也就是说只要3个features就可以进行学习，自由度为3。</p>

        <p>介绍到这，我们发现M与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />是成正比的，从而得到如下结论：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1a5f49dd0cd8d8428ba57e52fdc7e7e3.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="四interpreting-vc-dimension" class="sigil_not_in_toc"><strong>四、Interpreting VC Dimension</strong></h3>

        <p>下面，我们将更深入地探讨VC Dimension的意义。首先，把VC Bound重新写到这里：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/659f73151c15a98ed0d96b332cc9b5b1.jpg" alt="这里写图片描述" title="" /></p>

        <p>根据之前的泛化不等式，如果<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1061e3cbc87053b56ae2b1573a2f6451.jpg" />，即出现bad坏的情况的概率最大不超过<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e43bd121c6fef869baa12e9adf4a201a.jpg" />。那么反过来，对于good好的情况发生的概率最小为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b4330fb1bb4c0e475155f0d398d0ce3b.jpg" />，则对上述不等式进行重新推导：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/baca48fe5828da7f116ce70f49419886.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a385c3bea2dcb00656993bbdebe340d8.jpg" />表现了假设空间H的泛化能力，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a385c3bea2dcb00656993bbdebe340d8.jpg" />越小，泛化能力越大。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7216f7a0afaea0c4553f33039295dce8.jpg" alt="这里写图片描述" title="" /></p>

        <p>至此，已经推导出泛化误差<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4707f2d200bb617863f7161e0de612c5.jpg" />的边界，因为我们更关心其上界（<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4707f2d200bb617863f7161e0de612c5.jpg" />可能的最大值），即：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9fcc49a165eccfae45b7e9feb6800a83.jpg" alt="这里写图片描述" title="" /></p>

        <p>上述不等式的右边第二项称为模型复杂度，其模型复杂度与样本数量N、假设空间H(<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />)、<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a385c3bea2dcb00656993bbdebe340d8.jpg" />有关。<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4707f2d200bb617863f7161e0de612c5.jpg" />由<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/571ed3fcbee703f5e037a62366e1e1d8.jpg" />共同决定。下面绘出<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4707f2d200bb617863f7161e0de612c5.jpg" />、model complexity、<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/571ed3fcbee703f5e037a62366e1e1d8.jpg" />随<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />变化的关系：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ada572ce18dcc85587581450123083f2.jpg" alt="这里写图片描述" title="" /></p>

        <p>通过该图可以得出如下结论：</p>

        <ul>
            <li>
                <p><strong><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />越大，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/571ed3fcbee703f5e037a62366e1e1d8.jpg" />越小，<img
                            src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bfd231c1490723e852948a84827e8b04.jpg" />越大（复杂）</strong>。</p>
            </li>
            <li>
                <p><strong><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />越小，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/571ed3fcbee703f5e037a62366e1e1d8.jpg" />越大，<img
                            src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bfd231c1490723e852948a84827e8b04.jpg" />越小（简单）</strong>。</p>
            </li>
            <li>
                <p><strong>随着<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />增大，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4707f2d200bb617863f7161e0de612c5.jpg" />会先减小再增大</strong>。</p>
            </li>
        </ul>

        <p>所以，为了得到最小的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4707f2d200bb617863f7161e0de612c5.jpg" />，不能一味地增大<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />以减小<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/571ed3fcbee703f5e037a62366e1e1d8.jpg" />，因为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/571ed3fcbee703f5e037a62366e1e1d8.jpg" />太小的时候，模型复杂度会增加，造成<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4707f2d200bb617863f7161e0de612c5.jpg" />变大。也就是说，选择合适的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />，选择的features个数要合适。</p>

        <p>下面介绍一个概念：样本复杂度（Sample Complexity）。如果选定<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />，样本数据D选择多少合适呢？通过下面一个例子可以帮助我们理解：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/55ac247926db04a7937ad6bcc1740683.jpg" alt="这里写图片描述" title="" /></p>

        <p>通过计算得到N=29300，刚好满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e43bd121c6fef869baa12e9adf4a201a.jpg" />的条件。N大约是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />的10000倍。这个数值太大了，实际中往往不需要这么多的样本数量，大概只需要<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />的10倍就够了。N的理论值之所以这么大是因为VC Bound
            过于宽松了，我们得到的是一个比实际大得多的上界。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2d342e1b5628209372a217cdb60e4177.jpg" alt="这里写图片描述" title="" /></p>

        <p>值得一提的是，VC Bound是比较宽松的，而如何收紧它却不是那么容易，这也是机器学习的一大难题。但是，令人欣慰的一点是，VC
            Bound基本上对所有模型的宽松程度是基本一致的，所以，不同模型之间还是可以横向比较。从而，VC Bound宽松对机器学习的可行性还是没有太大影响。</p>

        <h3 id="五总结" class="sigil_not_in_toc"><strong>五、总结</strong></h3>

        <p>本节课主要介绍了VC Dimension的概念就是最大的non-break point。然后，我们得到了Perceptrons在d维度下的VC Dimension是d+1。接着，我们在物理意义上，将<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />与自由度联系起来。最终得出结论<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25e9ecbb8e04e03e89d61c3f36457c57.jpg" />不能过大也不能过小。选取合适的值，才能让<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4707f2d200bb617863f7161e0de612c5.jpg" />足够小，使假设空间H具有良好的泛化能力。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习基石》课程</p>
    </div>

    <h1>
        8 -- Noise and Error

    </h1>
    <div class="markdown_views">
        <p>上一节课，我们主要介绍了VC Dimension的概念。如果Hypotheses set的VC Dimension是有限的，且有足够多N的资料，同时能够找到一个hypothesis使它的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3f9b919897da6adfb854d4b7516bde39.jpg" />，那么就能说明机器学习是可行的。本节课主要讲了数据集有Noise的情况下，是否能够进行机器学习，并且介绍了假设空间H下演算法A的Error估计。</p>

        <h3 id="一noise-and-probablistic-target" class="sigil_not_in_toc"><strong>一、Noise and Probablistic target</strong></h3>

        <p>上节课推导VC Dimension的数据集是在没有Noise的情况下，本节课讨论如果数据集本身存在Noise，那VC Dimension的推导是否还成立呢？</p>

        <p>首先，Data Sets的Noise一般有三种情况：</p>

        <ul>
            <li>
                <p><strong>由于人为因素，正类被误分为负类，或者负类被误分为正类；</strong></p>
            </li>
            <li>
                <p><strong>同样特征的样本被模型分为不同的类；</strong></p>
            </li>
            <li>
                <p><strong>样本的特征被错误记录和使用。</strong></p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4c9a1892e76d6e495adf33ea3aefa6f8.jpg" alt="这里写图片描述" title="" /></p>

        <p>之前的数据集是确定的，即没有Noise的，我们称之为Deterministic。现在有Noise了，也就是说在某点处不再是确定分布，而是概率分布了，即对每个(x，y)出现的概率是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/12d12c819c2467c289e4a700f3623212.jpg" />。</p>

        <p>因为Noise的存在，比如在x点，有0.7的概率y=1，有0.3的概率y=0，即y是按照<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/12d12c819c2467c289e4a700f3623212.jpg" />分布的。数学上可以证明如果数据集按照<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/12d12c819c2467c289e4a700f3623212.jpg" />概率分布且是iid的，那么以前证明机器可以学习的方法依然奏效，VC
            Dimension有限即可推断<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/719cb690171fbdd7415aa6085c0b4b68.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6bbd5053ee6227f783df8773f0f9264a.jpg" />是近似的。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/66c7bf35e055d26d9d4d717c9a551baf.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/12d12c819c2467c289e4a700f3623212.jpg" />称之为目标分布（Target
            Distribution）。它实际上告诉我们最好的选择是什么，同时伴随着多少noise。其实，没有noise的数据仍然可以看成“特殊”的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/12d12c819c2467c289e4a700f3623212.jpg" />概率分布，即概率仅是1和0.对于以前确定的数据集：
            <br />
            <script type="math/tex; mode=display" id="MathJax-Element-9">P(y|x)=1,for \space y=f(x)</script> <br />
            <script type="math/tex; mode=display" id="MathJax-Element-10">P(y|x)=0,for \space y\neq f(x)</script>
        </p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e02323671eeb29acd0c899755082c731.jpg" alt="这里写图片描述" title="" /></p>

        <p>在引入noise的情况下，新的学习流程图如下所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/42294271589ff348f2f12ae827fc9e1a.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="二error-measure" class="sigil_not_in_toc"><strong>二、ERROR Measure</strong></h3>

        <p>机器学习需要考虑的问题是找出的矩g与目标函数f有多相近，我们一直使用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6351a210e7296714df1442ef4e184cec.jpg" />进行误差的估计，那一般的错误测量有哪些形式呢？</p>

        <p>我们介绍的矩g对错误的衡量有三个特性：</p>

        <ul>
            <li>
                <p><strong>out-of-sample：样本外的未知数据</strong></p>
            </li>
            <li>
                <p><strong>pointwise：对每个数据点x进行测试</strong></p>
            </li>
            <li>
                <p><strong>classification：看prediction与target是否一致，classification error通常称为0/1 error</strong></p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3f229952e5a8f34c47b6589210f89d64.jpg" alt="这里写图片描述" title="" /></p>

        <p>PointWise error实际上就是对数据集的每个点计算错误并计算平均，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/719cb690171fbdd7415aa6085c0b4b68.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6bbd5053ee6227f783df8773f0f9264a.jpg" />的pointwise
            error的表达式为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/957e433a36b59985b512793f0428cf4f.jpg" alt="这里写图片描述" title="" /></p>

        <p>pointwise error是机器学习中最常用也是最简单的一种错误衡量方式，未来课程中，我们主要考虑这种方式。pointwise error一般可以分成两类：0/1 error和squared error。0/1
            error通常用在分类（classification）问题上，而squared error通常用在回归（regression）问题上。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f731d065e6e70a4fdce5f1e4c5d4d595.jpg" alt="这里写图片描述" title="" /></p>

        <p>Ideal Mini-Target由<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/12d12c819c2467c289e4a700f3623212.jpg" />和err共同决定，0/1 error和squared
            error的Ideal Mini-Target计算方法不一样。例如下面这个例子，分别用0/1 error和squared error来估计最理想的mini-target是多少。0/1
            error中的mini-target是取P(y|x)最大的那个类，而squared error中的mini-target是取所有类的加权平方和。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b0662d287b1cc9bcb80e114c28395d35.jpg" alt="这里写图片描述" title="" /></p>

        <p>有了错误衡量，就会知道当前的矩g是好还是不好，并会让演算法不断修正，得到更好的矩g，从而使得g与目标函数更接近。所以，引入error measure后，学习流程图如下所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b128d02e9f95b0547a0fc9a18f917da1.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="三algorithmic-error-measure" class="sigil_not_in_toc"><strong>三、Algorithmic Error Measure</strong></h3>

        <p>Error有两种：false accept和false reject。false accept意思是误把负类当成正类，false reject是误把正类当成负类。 根据不同的机器学习问题，false
            accept和false reject应该有不同的权重，这根实际情况是符合的，比如是超市优惠，那么false reject应该设的大一些；如果是安保系统，那么false accept应该设的大一些。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/974807506c5372a2b9f110fbdc400d3a.jpg" alt="这里写图片描述" title="" /></p>

        <p>机器学习演算法A的cost function error估计有多种方法，真实的err一般难以计算，常用的方法可以采用plausible或者friendly，根据具体情况而定。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/025babd803f88f4853938e41e8a8760b.jpg" alt="这里写图片描述" title="" /></p>

        <p>引入algorithm error measure之后，学习流程图如下：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9372381d33584d56600ab575c309b396.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="四weighted-classification" class="sigil_not_in_toc"><strong>四、Weighted Classification</strong></h3>

        <p>实际上，机器学习的Cost Function即来自于这些error，也就是算法里面的迭代的目标函数，通过优化使得Error（Ein）不断变小。 <br />
            cost function中，false accept和false reject赋予不同的权重，在演算法中体现。对不同权重的错误惩罚，可以选用virtual copying的方法。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40a94eee7b2d4e550d9af8d1d161e13b.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/833bdaad78d2e0081c2546e66738a10f.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="五总结" class="sigil_not_in_toc"><strong>五、总结</strong></h3>

        <p>本节课主要讲了在有Noise的情况下，即数据集按照<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/12d12c819c2467c289e4a700f3623212.jpg" />概率分布，那么VC
            Dimension仍然成立，机器学习算法推导仍然有效。机器学习cost function常用的Error有0/1 error和squared error两类。实际问题中，对false accept和false
            reject应该选择不同的权重。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习基石》课程。</p>
    </div>

    <h1>
        9 -- Linear Regression

    </h1>
    <div class="markdown_views">
        <p>上节课，我们主要介绍了在有noise的情况下，VC Bound理论仍然是成立的。同时，介绍了不同的error measure方法。本节课介绍机器学习最常见的一种算法：Linear Regression.</p>

        <h3 id="一线性回归问题" class="sigil_not_in_toc"><strong>一、线性回归问题</strong></h3>

        <p>在之前的Linear Classification课程中，讲了信用卡发放的例子，利用机器学习来决定是否给用户发放信用卡。本节课仍然引入信用卡的例子，来解决给用户发放信用卡额度的问题，这就是一个线性回归（Linear
            Regression）问题。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c72c0eda29fa5c940a85001c0a40ba1d.jpg" alt="这里写图片描述" title="" /></p>

        <p>令用户特征集为d维的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/60ef7ffc7ee9f8c9f54a54940001c8b9.jpg" />，加上常数项，维度为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/42e98d2659cfeeeccf8e0918c54734e6.jpg" />，与权重<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f12c5a9ac27d1343c1771a3ae3bdd808.jpg" />的线性组合即为Hypothesis,记为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a9f755cd0c77c33b451f9ba084291cd0.jpg" />。线性回归的预测函数取值在整个实数空间，这跟线性分类不同。</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-5">h(x)=w^TX</script>
        </p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6872c83bee6f736a9cbad525406cbf8c.jpg" alt="这里写图片描述" title="" /></p>

        <p>根据上图，在一维或者多维空间里，线性回归的目标是找到一条直线（对应一维）、一个平面（对应二维）或者更高维的超平面，使样本集中的点更接近它，也就是残留误差Residuals最小化。</p>

        <p>一般最常用的错误测量方式是基于最小二乘法，其目标是计算误差的最小平方和对应的权重w，即上节课介绍的squared error：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0ed74ab22a9571be1d368ff97a16cb10.jpg" alt="这里写图片描述" title="" /></p>

        <p>这里提一点，最小二乘法可以解决线性问题和非线性问题。线性最小二乘法的解是closed-form，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/60ef7ffc7ee9f8c9f54a54940001c8b9.jpg" />，而非线性最小二乘法没有closed-form，通常用迭代法求解。本节课的解就是closed-form的。关于最小二乘法的一些介绍，请参见我的另一篇博文：</p>

        <p><a href="http://blog.csdn.net/red_stone1/article/details/70306403">最小二乘法和梯度下降法的一些总结</a></p>

        <h3 id="二线性回归算法" class="sigil_not_in_toc"><strong>二、线性回归算法</strong></h3>

        <p>样本数据误差<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0b0efbc51f6174787220f3866f14ec85.jpg" />是权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f12c5a9ac27d1343c1771a3ae3bdd808.jpg" />的函数，因为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/60ef7ffc7ee9f8c9f54a54940001c8b9.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3977bbae8ef99d4eef1ec15793c43a49.jpg" />都是已知的。我们的目标就是找出合适的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f12c5a9ac27d1343c1771a3ae3bdd808.jpg" />，使<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0b0efbc51f6174787220f3866f14ec85.jpg" />能够最小。那么如何计算呢？</p>

        <p>首先，运用矩阵转换的思想，将<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0b0efbc51f6174787220f3866f14ec85.jpg" />计算转换为矩阵的形式。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1b7aeebc9e8b9f00f8e25d37f34148b7.jpg" alt="这里写图片描述" title="" /></p>

        <p>然后，对于此类线性回归问题，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0b0efbc51f6174787220f3866f14ec85.jpg" />一般是个凸函数。凸函数的话，我们只要找到一阶导数等于零的位置，就找到了最优解。那么，我们将<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1a3f08969fcb7fcf103ea7390e080cbb.jpg" />对每个<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f12c5a9ac27d1343c1771a3ae3bdd808.jpg" />求偏导，偏导为零的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f12c5a9ac27d1343c1771a3ae3bdd808.jpg" />，即为最优化的权重值分布。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6ba3f882240cc725877d5d014556a5f8.jpg" alt="这里写图片描述" title="" /></p>

        <p>根据梯度的思想，对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1a3f08969fcb7fcf103ea7390e080cbb.jpg" />进行矩阵话求偏导处理：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8f1cd29b15384558023e7a5482efb3d5.jpg" alt="这里写图片描述" title="" /></p>

        <p>令偏导为零，最终可以计算出权重向量<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f12c5a9ac27d1343c1771a3ae3bdd808.jpg" />为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/30587f21ddf5ce888864a307215fb964.jpg" alt="这里写图片描述" title="" /></p>

        <p>最终，我们推导得到了权重向量<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f12c5a9ac27d1343c1771a3ae3bdd808.jpg" />，这是上文提到的closed-form解。其中，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e4de4ad48331112538ad0a3397a245e1.jpg" />又称为伪逆矩阵pseudo-inverse，记为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/60ef7ffc7ee9f8c9f54a54940001c8b9.jpg" />，维度是(d+1)xN。</p>

        <p>但是，我们注意到，伪逆矩阵中有逆矩阵的计算，逆矩阵<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6bfe52a24feb6712b6d9b99b569dd8ac.jpg" />是否一定存在？一般情况下，只要满足样本数量N远大于样本特征维度d+1，就能保证矩阵的逆是存在的，称之为非奇异矩阵。但是如果是奇异矩阵，不可逆怎么办呢？其实，大部分的计算逆矩阵的软件程序，都可以处理这个问题，也会计算出一个逆矩阵。所以，一般伪逆矩阵是可解的。</p>

        <h3 id="三泛化问题" class="sigil_not_in_toc"><strong>三、泛化问题</strong></h3>

        <p>现在，可能有这样一个疑问，就是这种求解权重向量的方法是机器学习吗？或者说这种方法满足我们之前推导VC Bound，即是否泛化能力强<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0b0efbc51f6174787220f3866f14ec85.jpg" />？</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f046ec9fd76daa84549ec1323b209b06.jpg" alt="这里写图片描述" title="" /></p>

        <p>有两种观点：1、这不属于机器学习范畴。因为这种closed-form解的形式跟一般的机器学习算法不一样，而且在计算最小化误差的过程中没有用到迭代。2、这属于机器学习范畴。因为从结果上看，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0b0efbc51f6174787220f3866f14ec85.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b72ebcb54db6e93755e362a2c758e0ab.jpg" />都实现了最小化，而且实际上在计算逆矩阵的过程中，也用到了迭代。</p>

        <p>其实，只从结果来看，这种方法的确实现了机器学习的目的。下面通过介绍一种更简单的方法，证明linear regression问题是可以通过线下最小二乘法方法计算得到好的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0b0efbc51f6174787220f3866f14ec85.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b72ebcb54db6e93755e362a2c758e0ab.jpg" />的。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b6bf4e022b3e912aa88d0a8ca58dcba1.jpg" alt="这里写图片描述" title="" /></p>

        <p>首先，我们根据平均误差的思想，把<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0b0efbc51f6174787220f3866f14ec85.jpg" />写成如图的形式，经过变换得到: <br />
            <script type="math/tex; mode=display" id="MathJax-Element-30">E_{in}(w_{LIN})=\frac1N||(I-XX^+)y||^2=\frac1N||(I-H)y||^2</script>
        </p>

        <p>我们称<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/60ef7ffc7ee9f8c9f54a54940001c8b9.jpg" />为帽子矩阵，用H表示。</p>

        <p>下面从几何图形的角度来介绍帽子矩阵H的物理意义。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2996b1d3a288bc9e9c4e911827b63d9f.jpg" alt="这里写图片描述" title="" /></p>

        <p>图中，y是N维空间的一个向量，粉色区域表示输入矩阵X乘以不同权值向量w所构成的空间，根据所有w的取值，预测输出都被限定在粉色的空间中。向量<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d703dd9459aded7d1177d1ebd655166f.jpg" />就是粉色空间中的一个向量，代表预测的一种。y是实际样本数据输出值。</p>

        <p>机器学习的目的是在粉色空间中找到一个<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d703dd9459aded7d1177d1ebd655166f.jpg" />，使它最接近真实的y，那么我们只要将y在粉色空间上作垂直投影即可，投影得到的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d703dd9459aded7d1177d1ebd655166f.jpg" />即为在粉色空间内最接近y的向量。这样即使平均误差<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f7965e606c453854be7ff54494b5b6f0.jpg" />最小。</p>

        <p>从图中可以看出，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d703dd9459aded7d1177d1ebd655166f.jpg" />是y的投影，已知<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d703dd9459aded7d1177d1ebd655166f.jpg" />，那么H表示的就是将y投影到<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d703dd9459aded7d1177d1ebd655166f.jpg" />的一种操作。图中绿色的箭头<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3977bbae8ef99d4eef1ec15793c43a49.jpg" />是向量y与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d703dd9459aded7d1177d1ebd655166f.jpg" />相减，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3977bbae8ef99d4eef1ec15793c43a49.jpg" />垂直于粉色区域。已知<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9ffdfb49e66c0e94c27b49c114576d6c.jpg" />那么I-H表示的就是将y投影到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3977bbae8ef99d4eef1ec15793c43a49.jpg" />即垂直于粉色区域的一种操作。这样的话，我们就赋予了H和I-H不同但又有联系的物理意义。</p>

        <p>这里trace(I-H)称为I-H的迹，值为N-(d+1)。这条性质很重要，一个矩阵的 trace等于该矩阵的所有特征值(Eigenvalues)之和。下面给出简单证明：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/259a8ff675911e046d50624b0f264100.jpg" /> <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/73f675cb02947f18734259a6ba136c82.jpg" /> <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1b7ae0053f3d9a51bd9a6e8da7189d50.jpg" /> <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a95e59395b14a2cf3d94915afbcf570a.jpg" /></p>

        <p>介绍下该I-H这种转换的物理意义：原来有一个有N个自由度的向量y，投影到一个有d+1维的空间x（代表一列的自由度，即单一输入样本的参数，如图中粉色区域），而余数剩余的自由度最大只有N-(d+1)种。</p>

        <p>在存在noise的情况下，上图变为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/56a536ccdd11a635b6ceaeab7eb56b0d.jpg" alt="这里写图片描述" title="" /></p>

        <p>图中，粉色空间的红色箭头是目标函数f(x)，虚线箭头是noise，可见，真实样本输出y由f(x)和noise相加得到。由上面推导，已知向量y经过I-H转换为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3977bbae8ef99d4eef1ec15793c43a49.jpg" />，而noise与y是线性变换关系，那么根据线性函数知识，我们推导出noise经过I-H也能转换为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3977bbae8ef99d4eef1ec15793c43a49.jpg" />。则对于样本平均误差，有下列推导成立：</p>

        <p></p>
        <div class="MathJax_Display" role="textbox" aria-readonly="true"></div>
        <script type="math/tex; mode=display" id="MathJax-Element-50">E_{in}(w_{LIN})=\frac1N||y-\hat y||^2=\frac1N||(I-H)noise||^2=\frac1N(N-(d+1))||noise||^2</script>
        <p></p>

        <p>即</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-51">\overline E_{in}=noise level\ast (1-\frac{d+1}N) </script>
        </p>

        <p>同样，对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b72ebcb54db6e93755e362a2c758e0ab.jpg" />有如下结论：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-53">\overline E_{out}=noise level\ast (1+\frac{d+1}N) </script>
        </p>

        <p>这个证明有点复杂，但是我们可以这样理解：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f7965e606c453854be7ff54494b5b6f0.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f7965e606c453854be7ff54494b5b6f0.jpg" />形式上只差了<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/731e77bb5a621e147548bb15adc2fd53.jpg" />项，从哲学上来说，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f7965e606c453854be7ff54494b5b6f0.jpg" />是我们看得到的样本的平均误差，如果有noise，我们把预测往noise那边偏一点，让<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f7965e606c453854be7ff54494b5b6f0.jpg" />好看一点点，所以减去<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/731e77bb5a621e147548bb15adc2fd53.jpg" />项。那么同时，新的样本<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f7965e606c453854be7ff54494b5b6f0.jpg" />是我们看不到的，如果noise在反方向，那么<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f7965e606c453854be7ff54494b5b6f0.jpg" />就应该加上<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/731e77bb5a621e147548bb15adc2fd53.jpg" />项。</p>

        <p>我们把<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f7965e606c453854be7ff54494b5b6f0.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f7965e606c453854be7ff54494b5b6f0.jpg" />画出来，得到学习曲线：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/87b2f843a95e1a5bdead402256110413.jpg" alt="这里写图片描述" title="" /></p>

        <p>当N足够大时，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f7965e606c453854be7ff54494b5b6f0.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f7965e606c453854be7ff54494b5b6f0.jpg" />逐渐接近，满足<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f7965e606c453854be7ff54494b5b6f0.jpg" />，且数值保持在noise
            level。这就类似VC理论，证明了当N足够大的时候，这种线性最小二乘法是可以进行机器学习的，算法有效！</p>

        <h3 id="四linear-regression方法解决linear-classification问题" class="sigil_not_in_toc"><strong>四、Linear
                Regression方法解决Linear Classification问题</strong></h3>

        <p>之前介绍的Linear Classification问题使用的Error Measure方法用的是0/1 error，那么Linear Regression的squared error是否能够应用到Linear
            Classification问题？</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fb89c1cd7596fae9133445344506e1d.jpg" alt="这里写图片描述" title="" /></p>

        <p>下图展示了两种错误的关系，一般情况下，squared error曲线在0/1 error曲线之上。即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a0f84e990fb192032733a4e2d0f3682c.jpg" />.</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1bbb3f870c17b34992ad7649ada15597.jpg" alt="这里写图片描述" title="" /></p>

        <p>根据之前的VC理论，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b72ebcb54db6e93755e362a2c758e0ab.jpg" />的上界满足：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8ac66be2c22433316a9fbc085ec8d6dc.jpg" alt="这里写图片描述" title="" /></p>

        <p>从图中可以看出，用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/00dff8bf6e32c56fa828c55e40b4c44f.jpg" />代替<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b406a8f466b66fbe008d1af8dfe5240b.jpg" />，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b72ebcb54db6e93755e362a2c758e0ab.jpg" />仍然有上界，只不过是上界变得宽松了。也就是说用线性回归方法仍然可以解决线性分类问题，效果不会太差。二元分类问题得到了一个更宽松的上界，但是也是一种更有效率的求解方式。</p>

        <h3 id="五总结" class="sigil_not_in_toc"><strong>五、总结</strong></h3>

        <p>本节课，我们主要介绍了Linear Regression。首先，我们从问题出发，想要找到一条直线拟合实际数据值；然后，我们利用最小二乘法，用解析形式推导了权重w的closed-form解；接着，用图形的形式得到<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b72ebcb54db6e93755e362a2c758e0ab.jpg" />，证明了linear regression是可以进行机器学习的，；最后，我们证明linear
            regressin这种方法可以用在binary classification上，虽然上界变宽松了，但是仍然能得到不错的学习方法。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习基石》课程</p>
    </div>

    <h1>
        10 -- Logistic Regression

    </h1>
    <div class="markdown_views">
        <p>上一节课，我们介绍了Linear Regression线性回归，以及用平方错误来寻找最佳的权重向量w，获得最好的线性预测。本节课将介绍Logistic Regression逻辑回归问题。</p>

        <h3 id="一logistic-regression-problem" class="sigil_not_in_toc"><strong>一、Logistic Regression Problem</strong></h3>

        <p>一个心脏病预测的问题：根据患者的年龄、血压、体重等信息，来预测患者是否会有心脏病。很明显这是一个二分类问题，其输出y只有{-1,1}两种情况。</p>

        <p>二元分类，一般情况下，理想的目标函数f(x)&gt;0.5，则判断为正类1；若f(x)&lt;0.5，则判断为负类-1。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a62d3d608b956e0c0157b33f6d07b26c.jpg" alt="这里写图片描述" title="" /></p>

        <p>但是，如果我们想知道的不是患者有没有心脏病，而是到底患者有多大的几率是心脏病。这表示，我们更关心的是目标函数的值（分布在0,1之间），表示是正类的概率（正类表示是心脏病）。这跟我们原来讨论的二分类问题不太一样，我们把这个问题称为软性二分类问题（’soft’
            binary classification）。这个值越接近1，表示正类的可能性越大；越接近0，表示负类的可能性越大。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b968cb65873dcec5948cbd6423406623.jpg" alt="这里写图片描述" title="" /></p>

        <p>对于软性二分类问题，理想的数据是分布在[0,1]之间的具体值，但是实际中的数据只可能是0或者1，我们可以把实际中的数据看成是理想数据加上了噪声的影响。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cab07af3b8e9b21b7e318e7e296bb02a.jpg" alt="这里写图片描述" title="" /></p>

        <p>如果目标函数是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/41d27a7fd83c6e26af7b6859364cb49f.jpg" />的话，我们如何找到一个好的Hypothesis跟这个目标函数很接近呢？</p>

        <p>首先，根据我们之前的做法，对所有的特征值进行加权处理。计算的结果s，我们称之为’risk score’：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/118b641a894ff6c2ec2c602f52cc6f18.jpg" alt="这里写图片描述" title="" /></p>

        <p>但是特征加权和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5fac02bb7c0dc1f050159f40b254aa1f.jpg" />，如何将s值限定在[0,1]之间呢？一个方法是使用sigmoid
            Function，记为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/70347051068937d1d9f55806c9c83c15.jpg" />。那么我们的目标就是找到一个hypothesis：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/51c6c4253f728a91b431ee87201d2767.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3e60dc67cfcb397d1fe593241525edae.jpg" alt="这里写图片描述" title="" /></p>

        <p>Sigmoid Function函数记为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/70347051068937d1d9f55806c9c83c15.jpg" />，满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2cb14c9b98853f1b19ea5e02d757ca1d.jpg" />，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd65a58a1f5dd55dd89adc05726d6953.jpg" />，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b23f0deb6a9de9114d7955b2d2028da7.jpg" />。这个函数是平滑的、单调的S型函数。则对于逻辑回归问题，hypothesis就是这样的形式：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-9">h(x)=\frac1{1+e^{-w^Tx}}</script>
        </p>

        <p>那我们的目标就是求出这个预测函数h(x)，使它接近目标函数f(x)。</p>

        <h3 id="二logistic-regression-error" class="sigil_not_in_toc"><strong>二、Logistic Regression Error</strong></h3>

        <p>现在我们将Logistic Regression与之前讲的Linear Classification、Linear Regression做个比较：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bfe45f2f9daf6bfc0413537d98518b59.jpg" alt="这里写图片描述" title="" /></p>

        <p>这三个线性模型都会用到线性scoring function <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1766437ebeef6f9f34934af4df70d78f.jpg" />。linear
            classification的误差使用的是0/1 err；linear regression的误差使用的是squared err。那么logistic regression的误差该如何定义呢？</p>

        <p>先介绍一下“似然性”的概念。目标函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/417c444cdd27e3a8720f901d62f00d38.jpg" />，如果我们找到了hypothesis很接近target
            function。也就是说，在所有的Hypothesis集合中找到一个hypothesis与target
            function最接近，能产生同样的数据集D，包含y输出label，则称这个hypothesis是最大似然likelihood。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8ccc2a7f1c30012797073931feeb93cc.jpg" alt="这里写图片描述" title="" /></p>

        <p>logistic function: <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/51c6c4253f728a91b431ee87201d2767.jpg" />满足一个性质：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/76c1848fde1f18040a7b7b2a223f839a.jpg" />。那么，似然性h:</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-14">likelihood(h)=P(x_1)h(+x_1)\times P(x_2)h(-x_2)\times \cdots P(x_N)h(-x_N)</script>
        </p>

        <p>因为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/af443a67434ce6e2fcb484ce50e43ac9.jpg" />对所有的h来说，都是一样的，所以我们可以忽略它。那么我们可以得到logistic
            h正比于所有的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c41d5001c6d9f2779d904b25ed3c1e3f.jpg" />乘积。我们的目标就是让乘积值最大化。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1808f84b0f3196d54f04c204bc5b2fa7.jpg" alt="这里写图片描述" title="" /></p>

        <p>如果将w代入的话：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c161ef70b9c994e4cde7ec416b4f8bad.jpg" alt="这里写图片描述" title="" /></p>

        <p>为了把连乘问题简化计算，我们可以引入ln操作，让连乘转化为连加：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/53a1c6f6bc89d08860ac841fe1a0d5ee.jpg" alt="这里写图片描述" title="" /></p>

        <p>接着，我们将maximize问题转化为minimize问题，添加一个负号就行，并引入平均数操作<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7dc6d0af4e9649e880651a0164c15c03.jpg" />：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/51473a82241562066bf7fafe5b414433.jpg" alt="这里写图片描述" title="" /></p>

        <p>将logistic function的表达式带入，那么minimize问题就会转化为如下形式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f037ab828c2bfdaf41bfede49640a1b2.jpg" alt="这里写图片描述" title="" /></p>

        <p>至此，我们得到了logistic regression的err function，称之为cross-entropy error交叉熵误差：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/89a22492d5cf7c0395f4d6a3e9ea49e7.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="三gradient-of-logistic-regression-error" class="sigil_not_in_toc"><strong>三、Gradient of Logistic
                Regression Error</strong></h3>

        <p>我们已经推导了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d53537a9fd3d004184f3feaf07b3fd34.jpg" />的表达式，那接下来的问题就是如何找到合适的向量w，让<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d53537a9fd3d004184f3feaf07b3fd34.jpg" />最小。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3d4fd7008e03b9f11ab5278f13e63579.jpg" alt="这里写图片描述" title="" /></p>

        <p>Logistic Regression的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d53537a9fd3d004184f3feaf07b3fd34.jpg" />是连续、可微、二次可微的凸曲线（开口向上），根据之前Linear
            Regression的思路，我们只要计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d53537a9fd3d004184f3feaf07b3fd34.jpg" />的梯度为零时的w，即为最优解。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/29fe34b866aef9ce35e6615b46431af1.jpg" alt="这里写图片描述" title="" /></p>

        <p>对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d53537a9fd3d004184f3feaf07b3fd34.jpg" />计算梯度，学过微积分的都应该很容易计算出来：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/82807dd6db78e0a6a5fb81cc915661cc.jpg" alt="这里写图片描述" title="" /></p>

        <p>最终得到的梯度表达式为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/86d524e26cf5109df12114bb22de7d00.jpg" alt="这里写图片描述" title="" /></p>

        <p>为了计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d53537a9fd3d004184f3feaf07b3fd34.jpg" />最小值，我们就要找到让<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/18bb20e9c4b9f13aa1bf1ae4c98f7902.jpg" />等于0的位置。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/97b5bc63285565f3822573b315f1568b.jpg" alt="这里写图片描述" title="" /></p>

        <p>上式可以看成<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4cf91e9cef35d03bcbb859c9bc4b51c9.jpg" />是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3cca114c4b46e778743527e6ce4573b7.jpg" />的线性加权。要求<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4cf91e9cef35d03bcbb859c9bc4b51c9.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3cca114c4b46e778743527e6ce4573b7.jpg" />的线性加权和为0，那么一种情况是线性可分，如果所有的权重<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4cf91e9cef35d03bcbb859c9bc4b51c9.jpg" />为0，那就能保证<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/18bb20e9c4b9f13aa1bf1ae4c98f7902.jpg" />为0。<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4cf91e9cef35d03bcbb859c9bc4b51c9.jpg" />是sigmoid function，根据其特性，只要让<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3be5ae5c387d7b1e805a95159f3e28c3.jpg" />，即<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2ff5dd10987b183197e3d1c1e6dfb707.jpg" />。<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2ff5dd10987b183197e3d1c1e6dfb707.jpg" />表示对于所有的点，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3c9ea39d24b4cbca9a352ceebb099051.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/97160f729af879f33f6c9376bcbc0ee6.jpg" />都是同号的，这表示数据集D必须是全部线性可分的才能成立。</p>

        <p>然而，保证所有的权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4cf91e9cef35d03bcbb859c9bc4b51c9.jpg" />为0是不太现实的，总有不等于0的时候，那么另一种常见的情况是非线性可分，只能通过使加权和为零，来求解w。这种情况没有closed-form解，与Linear
            Regression不同，只能用迭代方法求解。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b687706131bfc1a3143e7def6f62ca87.jpg" alt="这里写图片描述" title="" /></p>

        <p>之前所说的Linear Regression有closed-form解，可以说是“一步登天”的；但是PLA算法是一步一步修正迭代进行的，每次对错误点进行修正，不断更新w值。PLA的迭代优化过程表示如下：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6f81fbbd2a583c71f5db98706430a67e.jpg" alt="这里写图片描述" title="" /></p>

        <p>w每次更新包含两个内容：一个是每次更新的方向<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3c9ea39d24b4cbca9a352ceebb099051.jpg" />，用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4518d62dd616c7117ed0867ca41d62b3.jpg" />表示，另一个是每次更新的步长<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/23487c6fb6f01b8e086be914c051fc2e.jpg" />。参数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/956770eb609290b6d8d8751e49f8f959.jpg" />和终止条件决定了我们的迭代优化算法。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5a1c43ae8ce8c51043185cf99e819323.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="四gradient-descent" class="sigil_not_in_toc"><strong>四、Gradient Descent</strong></h3>

        <p>根据上一小节PLA的思想，迭代优化让每次w都有更新：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/17e2ae237e67f2c65350099c2802d72d.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们把<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d53537a9fd3d004184f3feaf07b3fd34.jpg" />曲线看做是一个山谷的话，要求<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d53537a9fd3d004184f3feaf07b3fd34.jpg" />最小，即可比作下山的过程。整个下山过程由两个因素影响：一个是下山的单位方向<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4518d62dd616c7117ed0867ca41d62b3.jpg" />；另外一个是下山的步长<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/23487c6fb6f01b8e086be914c051fc2e.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/453c0f9c00d390b413452f83e523bf68.jpg" alt="这里写图片描述" title="" /></p>

        <p>利用微分思想和线性近似，假设每次下山我们只前进一小步，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/23487c6fb6f01b8e086be914c051fc2e.jpg" />很小，那么根据泰勒Taylor一阶展开，可以得到：
            <br />
            <script type="math/tex; mode=display" id="MathJax-Element-47">E_{in}(w_t+\eta v)\approx E_{in}(w_t)+\eta v^T\nabla E_{in}(w_t)</script>
        </p>

        <p>关于Taylor展开的介绍，可参考我另一篇博客： <br />
            <a href="http://blog.csdn.net/red_stone1/article/details/70260070">多元函数的泰勒(Taylor)展开式</a></p>

        <p>迭代的目的是让<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d53537a9fd3d004184f3feaf07b3fd34.jpg" />越来越小，即让<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d53537a9fd3d004184f3feaf07b3fd34.jpg" />。<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/23487c6fb6f01b8e086be914c051fc2e.jpg" />是标量，因为如果两个向量方向相反的话，那么他们的内积最小（为负），也就是说如果方向<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4518d62dd616c7117ed0867ca41d62b3.jpg" />与梯度<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d327be654d84911f4e0bcb1620b43767.jpg" />反向的话，那么就能保证每次迭代<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d53537a9fd3d004184f3feaf07b3fd34.jpg" />都成立。则，我们令下降方向<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4518d62dd616c7117ed0867ca41d62b3.jpg" />为：
            <br />
            <script type="math/tex; mode=display" id="MathJax-Element-55">v=-\frac{\nabla E_{in}(w_t)}{||\nabla E_{in}(w_t)||}</script>
        </p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4518d62dd616c7117ed0867ca41d62b3.jpg" />是单位向量，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4518d62dd616c7117ed0867ca41d62b3.jpg" />每次都是沿着梯度的反方向走，这种方法称为梯度下降（gradient
            descent）算法。那么每次迭代公式就可以写成： <br />
            <script type="math/tex; mode=display" id="MathJax-Element-58">w_{t+1}\leftarrow w_t-\eta\frac{\nabla E_{in}(w_t)}{||\nabla E_{in}(w_t)||}</script>
        </p>

        <p>下面讨论一下<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/23487c6fb6f01b8e086be914c051fc2e.jpg" />的大小对迭代优化的影响：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/23487c6fb6f01b8e086be914c051fc2e.jpg" />如果太小的话，那么下降的速度就会很慢；<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/23487c6fb6f01b8e086be914c051fc2e.jpg" />如果太大的话，那么之前利用Taylor展开的方法就不准了，造成下降很不稳定，甚至会上升。因此，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/23487c6fb6f01b8e086be914c051fc2e.jpg" />应该选择合适的值，一种方法是在梯度较小的时候，选择小的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/23487c6fb6f01b8e086be914c051fc2e.jpg" />，梯度较大的时候，选择大的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/23487c6fb6f01b8e086be914c051fc2e.jpg" />，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/23487c6fb6f01b8e086be914c051fc2e.jpg" />正比于<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9efb63341adf28f6dc5d37e00a72aacc.jpg" />。这样保证了能够快速、稳定地得到最小值<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d53537a9fd3d004184f3feaf07b3fd34.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c096a48b4ff6339c8afd52e46cd6621a.jpg" alt="这里写图片描述" title="" /></p>

        <p>对学习速率<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/23487c6fb6f01b8e086be914c051fc2e.jpg" />做个更修正，梯度下降算法的迭代公式可以写成： <br />
            <script type="math/tex; mode=display" id="MathJax-Element-69">w_{t+1}\leftarrow w_t-\eta'\nabla E_{in}(w_t)</script>
            <br />
            其中： <br />
            <script type="math/tex; mode=display" id="MathJax-Element-70">\eta'=\frac{\eta}{||\nabla E_{in}(w_t)||}</script>
        </p>

        <p>总结一下基于梯度下降的Logistic Regression算法步骤如下：</p>

        <ul>
            <li><strong>初始化<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/62c094df0983581deb7e41b7217d92c1.jpg" /></strong></li>
            <li><strong>计算梯度<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d327be654d84911f4e0bcb1620b43767.jpg" /></strong></li>
            <li><strong>迭代跟新<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6f1bf6ee56e78117572316f1f21796da.jpg" /></strong></li>
            <li><strong>满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/64d575651785ce9721297e5de4f67412.jpg" />或者达到迭代次数，迭代结束</strong></li>
        </ul>

        <h3 id="五总结" class="sigil_not_in_toc"><strong>五、总结</strong></h3>

        <p>我们今天介绍了Logistic Regression。首先，从逻辑回归的问题出发，将<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fbb32254bb8f2a57a0500bc1e957d45c.jpg" />作为目标函数，将<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a9b8f85a60ddaea5d413ba1da012846c.jpg" />作为hypothesis。接着，我们定义了logistic regression的err
            function，称之为cross-entropy error交叉熵误差。然后，我们计算logistic regression error的梯度，最后，通过梯度下降算法，计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d327be654d84911f4e0bcb1620b43767.jpg" />时对应的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5c934ee50e8ccde6112a6b81b8e76e5d.jpg" />值。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习基石》课程</p>
    </div>

    <h1>
        11 -- Linear Models for Classification

    </h1>
    <div class="markdown_views">
        <p>上一节课，我们介绍了Logistic Regression问题，建立cross-entropy error，并提出使用梯度下降算法gradient descnt来获得最好的logistic
            hypothesis。本节课继续介绍使用线性模型来解决分类问题。</p>

        <h3 id="一linear-models-for-binary-classification" class="sigil_not_in_toc"><strong>一、Linear Models for Binary
                Classification</strong></h3>

        <p>之前介绍几种线性模型都有一个共同点，就是都有样本特征x的加权运算，我们引入一个线性得分函数s：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-1">s=w^Tx</script>
        </p>

        <p>三种线性模型，第一种是linear classification。线性分类模型的hypothesis为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/194122caabfab3ac9b7b1f56f5954f50.jpg" />,取值范围为{-1,+1}两个值，它的err是0/1的，所以对应的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9638433f74bd4f2adddd3ca5cd5796d6.jpg" />是离散的，并不好解，这是个NP-hard问题。第二种是linear
            regression。线性回归模型的hypothesis为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1dea88293c28a721d3b163060c75f2f2.jpg" />，取值范围为整个实数空间，它的err是squared的，所以对应的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9638433f74bd4f2adddd3ca5cd5796d6.jpg" />是开口向上的二次曲线，其解是closed-form的，直接用线性最小二乘法求解即可。第三种是logistic
            regression。逻辑回归模型的hypothesis为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b111d3c3b221a19342c5e635470550b0.jpg" />，取值范围为(-1,1)之间，它的err是cross-entropy的，所有对应的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9638433f74bd4f2adddd3ca5cd5796d6.jpg" />是平滑的凸函数，可以使用梯度下降算法求最小值。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27c757691f79acec9915dd7b9228460e.jpg" alt="这里写图片描述" title="" /></p>

        <p>从上图中，我们发现，linear regression和logistic regression的error function都有最小解。那么可不可以用这两种方法来求解linear
            classification问题呢？下面，我们来对这三种模型的error function进行分析，看看它们之间有什么联系。</p>

        <p>对于linear classification，它的error function可以写成： <br />
            <script type="math/tex; mode=display" id="MathJax-Element-8">err_{0/1}(s,y)=|sign(s)\neq y|=|sign(ys)\neq 1|</script>
            <br />
            对于linear regression，它的error function可以写成： <br />
            <script type="math/tex; mode=display" id="MathJax-Element-9">err_{SQR}(s,y)=(s-y)^2=(ys-1)^2</script> <br />
            对于logistic regression，它的error function可以写成： <br />
            <script type="math/tex; mode=display" id="MathJax-Element-10">err_{CE}(s,y)=ln(1+exp(-ys))</script> <br />
            上述三种模型的error function都引入了ys变量，那么ys的物理意义是什么？ys就是指分类的正确率得分，其值越大越好，得分越高。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/89b100522f2dabd5fb11212b2803d707.jpg" alt="这里写图片描述" title="" /></p>

        <p>下面，我们用图形化的方式来解释三种模型的error function到底有什么关系：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/237eb330d17bfccb664e1c3b94160b82.jpg" alt="这里写图片描述" title="" /></p>

        <p>从上图中可以看出，ys是横坐标轴，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5f44e3458068a95f7182e11e626d4e9b.jpg" />是呈阶梯状的，在ys&gt;0时，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5f44e3458068a95f7182e11e626d4e9b.jpg" />恒取最小值0。<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/142cf2ffaa642a426a614784e05636c1.jpg" />呈抛物线形式，在ys=1时，取得最小值，且在ys=1左右很小区域内，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5f44e3458068a95f7182e11e626d4e9b.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/142cf2ffaa642a426a614784e05636c1.jpg" />近似。<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e30e66c910a2370174ba1b39cff3b3a7.jpg" />是呈指数下降的单调函数，ys越大，其值越小。同样在ys=1左右很小区域内，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5f44e3458068a95f7182e11e626d4e9b.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e30e66c910a2370174ba1b39cff3b3a7.jpg" />近似。但是我们发现<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e30e66c910a2370174ba1b39cff3b3a7.jpg" />并不是始终在<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5f44e3458068a95f7182e11e626d4e9b.jpg" />之上，所以为了计算讨论方便，我们把<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e30e66c910a2370174ba1b39cff3b3a7.jpg" />做幅值上的调整，引入<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dfe61bb2ec52b729d1f7b341cf5d53df.jpg" />，这样能保证<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d2bc7f12807f2cb1736fe6cd4dcdda8b.jpg" />始终在<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5f44e3458068a95f7182e11e626d4e9b.jpg" />上面，如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a7c17141fc9cfff751023519636f840f.jpg" alt="这里写图片描述" title="" /></p>

        <p>由上图可以看出： <br />
            <script type="math/tex; mode=display" id="MathJax-Element-25">err_{0/1}(s,y)\leq err_{SCE}(s,y)=\frac1{ln2}err_{CE}(s,y)</script>
            <br />
            <script type="math/tex; mode=display" id="MathJax-Element-26">E_{in}^{0/1}(w)\leq E_{in}^{SCE}(w)=\frac1{ln2}E_{in}^{CE}(w)</script>
            <br />
            <script type="math/tex; mode=display" id="MathJax-Element-27">E_{out}^{0/1}(w)\leq E_{out}^{SCE}(w)=\frac1{ln2}E_{out}^{CE}(w)</script>
            <br />
            那么由VC理论可以知道： <br />
            从0/1出发： <br />
            <script type="math/tex; mode=display" id="MathJax-Element-28">E_{out}^{0/1}(w)\leq E_{in}^{0/1}(w)+\Omega^{0/1}\leq \frac1{ln2}E_{in}^{CE}(w)+\Omega^{0/1}</script>
            <br />
            从CE出发： <br />
            <script type="math/tex; mode=display" id="MathJax-Element-29">E_{out}^{0/1}(w)\leq \frac1{ln2}E_{out}^{CE}(w)\leq \frac1{ln2}E_{in}^{CE}(w)+\frac1{ln2}\Omega^{CE}</script>
        </p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b791e071c4136999382dfe59014f0e9d.jpg" alt="这里写图片描述" title="" /></p>

        <p>通过上面的分析，我们看到err 0/1是被限定在一个上界中。这个上界是由logistic regression模型的error function决定的。而linear regression其实也是linear
            classification的一个upper bound，只是随着sy偏离1的位置越来越远，linear regression的error function偏差越来越大。综上所述，linear
            regression和logistic regression都可以用来解决linear classification的问题。</p>

        <p>下图列举了PLA、linear regression、logistic regression模型用来解linear classification问题的优点和缺点。通常，我们使用linear
            regression来获得初始化的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d943b76035db47ec7e03443f197e9aad.jpg" />，再用logistic
            regression模型进行最优化解。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1c3ea8c0a2610dd6810b65cacd2569a2.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="二stochastic-gradient-descent" class="sigil_not_in_toc"><strong>二、Stochastic Gradient Descent</strong></h3>

        <p>之前介绍的PLA算法和logistic regression算法，都是用到了迭代操作。PLA每次迭代只会更新一个点，它每次迭代的时间复杂度是O(1)；而logistic
            regression每次迭代要对所有N个点都进行计算，它的每时间复杂度是O(N)。为了提高logistic regression中gradient
            descent算法的速度，可以使用另一种算法：随机梯度下降算法(Stochastic Gradient Descent)。</p>

        <p>随机梯度下降算法每次迭代只找到一个点，计算该点的梯度，作为我们下一步更新w的依据。这样就保证了每次迭代的计算量大大减小，我们可以把整体的梯度看成这个随机过程的一个期望值。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/86c0e27f6c17f682f787bb3f08451138.jpg" alt="这里写图片描述" title="" /></p>

        <p>随机梯度下降可以看成是真实的梯度加上均值为零的随机噪声方向。单次迭代看，好像会对每一步找到正确梯度方向有影响，但是整体期望值上看，与真实梯度的方向没有差太多，同样能找到最小值位置。随机梯度下降的优点是减少计算量，提高运算速度，而且便于online学习；缺点是不够稳定，每次迭代并不能保证按照正确的方向前进，而且达到最小值需要迭代的次数比梯度下降算法一般要多。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/612bfa621be11aa3aa83dd9e3b04ff98.jpg" alt="这里写图片描述" title="" /></p>

        <p>对于logistic regression的SGD，它的表达式为： <br />
            <script type="math/tex; mode=display" id="MathJax-Element-31">w_{t+1}\leftarrow w_t+\eta\theta(-y_nw_t^Tx_n)(y_nx_n)</script>
        </p>

        <p>我们发现，SGD与PLA的迭代公式有类似的地方，如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4842d00db1052e615ea9827d3a5d2724.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们把SGD logistic regression称之为’soft’ PLA，因为PLA只对分类错误的点进行修正，而SGD logistic regression每次迭代都会进行或多或少的修正。另外，当<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/88e71838665669bf43e1b9437ae3e21b.jpg" />，且<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/eba356fd9b544667a3ec2407d7221ca0.jpg" />足够大的时候，PLA近似等于SGD。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/74299e865ab52f72bc76faa1e31b40e2.jpg" alt="这里写图片描述" title="" /></p>

        <p>除此之外，还有两点需要说明：1、SGD的终止迭代条件。没有统一的终止条件，一般让迭代次数足够多；2、学习速率<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/66a2f0e1a835a6f42e4d67fded836d29.jpg" />。<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/66a2f0e1a835a6f42e4d67fded836d29.jpg" />的取值是根据实际情况来定的，一般取值0.1就可以了。</p>

        <h3 id="三multiclass-via-logistic-regression" class="sigil_not_in_toc"><strong>三、Multiclass via Logistic
                Regression</strong></h3>

        <p>之前我们一直讲的都是二分类问题，本节主要介绍多分类问题，通过linear classification来解决。假设平面上有四个类，分别是正方形、菱形、三角形和星形，如何进行分类模型的训练呢？</p>

        <p>首先我们可以想到这样一个办法，就是先把正方形作为正类，其他三种形状都是负类，即把它当成一个二分类问题，通过linear
            classification模型进行训练，得出平面上某个图形是不是正方形，且只有{-1,+1}两种情况。然后再分别以菱形、三角形、星形为正类，进行二元分类。这样进行四次二分类之后，就完成了这个多分类问题。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d763f160a2b962c87b84cf1af30677de.jpg" alt="这里写图片描述" title="" /></p>

        <p>但是，这样的二分类会带来一些问题，因为我们只用{-1，+1}两个值来标记，那么平面上某些可能某些区域都被上述四次二分类模型判断为负类，即不属于四类中的任何一类；也可能会出现某些区域同时被两个类甚至多个类同时判断为正类，比如某个区域又判定为正方形又判定为菱形。那么对于这种情况，我们就无法进行多类别的准确判断，所以对于多类别，简单的binary
            classification不能解决问题。</p>

        <p>针对这种问题，我们可以使用另外一种方法来解决：soft软性分类，即不用{-1，+1}这种binary classification，而是使用logistic
            regression，计算某点属于某类的概率、可能性，去概率最大的值为那一类就好。</p>

        <p>soft
            classification的处理过程和之前类似，同样是分别令某类为正，其他三类为负，不同的是得到的是概率值，而不是{-1，+1}。最后得到某点分别属于四类的概率，取最大概率对应的哪一个类别就好。效果如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4efa905ce3576dfac738848c22102b30.jpg" alt="这里写图片描述" title="" /></p>

        <p>这种多分类的处理方式，我们称之为One-Versus-All(OVA) Decomposition。这种方法的优点是简单高效，可以使用logistic
            regression模型来解决；缺点是如果数据类别很多时，那么每次二分类问题中，正类和负类的数量差别就很大，数据不平衡unbalanced，这样会影响分类效果。但是，OVA还是非常常用的一种多分类算法。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/45a246dd1561b847598ae9ecf3ce79f7.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="四multiclass-via-binary-classification" class="sigil_not_in_toc"><strong>四、Multiclass via Binary
                Classification</strong></h3>

        <p>上一节，我们介绍了多分类算法OVA，但是这种方法存在一个问题，就是当类别k很多的时候，造成正负类数据unbalanced，会影响分类效果，表现不好。现在，我们介绍另一种方法来解决当k很大时，OVA带来的问题。</p>

        <p>这种方法呢，每次只取两类进行binary classification，取值为{-1，+1}。假如k=4，那么总共需要进行<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bb157cc825f7cbd55ad5ed2865b79450.jpg" />次binary
            classification。那么，六次分类之后，如果平面有个点，有三个分类器判断它是正方形，一个分类器判断是菱形，另外两个判断是三角形，那么取最多的那个，即判断它属于正方形，我们的分类就完成了。这种形式就如同k个足球对进行单循环的比赛，每场比赛都有一个队赢，一个队输，赢了得1分，输了得0分。那么总共进行了<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/de73928a535973fae06145572fcec306.jpg" />次的比赛，最终取得分最高的那个队就可以了。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/780a082ab12902b7215613d1c4e2aabb.jpg" alt="这里写图片描述" title="" /></p>

        <p>这种区别于OVA的多分类方法叫做One-Versus-One(OVO)。这种方法的优点是更加高效，因为虽然需要进行的分类次数增加了，但是每次只需要进行两个类别的比较，也就是说单次分类的数量减少了。而且一般不会出现数据unbalanced的情况。缺点是需要分类的次数多，时间复杂度和空间复杂度可能都比较高。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/287e6aa4fa3e99b7cab489e3d1406368.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="五总结" class="sigil_not_in_toc"><strong>五、总结</strong></h3>

        <p>本节课主要介绍了分类问题的三种线性模型：linear classification、linear regression和logistic regression。首先介绍了这三种linear
            models都可以来做binary classification。然后介绍了比梯度下降算法更加高效的SGD算法来进行logistic
            regression分析。最后讲解了两种多分类方法，一种是OVA，另一种是OVO。这两种方法各有优缺点，当类别数量k不多的时候，建议选择OVA，以减少分类次数。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习基石》课程</p>
    </div>

    <h1>
        12 -- Nonlinear Transformation

    </h1>
    <div class="markdown_views">
        <p>上一节课，我们介绍了分类问题的三种线性模型，可以用来解决binary classification和multiclass classification问题。本节课主要介绍非线性的模型来解决分类问题。</p>

        <h3 id="一quadratic-hypothesis" class="sigil_not_in_toc"><strong>一、Quadratic Hypothesis</strong></h3>

        <p>之前介绍的线性模型，在2D平面上是一条直线，在3D空间中是一个平面。数学上，我们用线性得分函数s来表示：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27abbf3017954dcba30b86ac07b43916.jpg" />。其中，x为特征值向量，w为权重，s是线性的。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d9a7196c215a8a63e37f278778f4f4d8.jpg" alt="这里写图片描述" title="" /></p>

        <p>线性模型的优点就是，它的VC Dimension比较小，保证了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4236321ed4ebd7bbef8c45a2a27e01e9.jpg" />。但是缺点也很明显，对某些非线性问题，可能会造成<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9c719640427bb747a1928886404350c0.jpg" />很大，虽然<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4236321ed4ebd7bbef8c45a2a27e01e9.jpg" />，但是也造成<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/078e128060018c90659bf99237fe3db0.jpg" />很大，分类效果不佳。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/61d8080c832465791e8dc9631a590acc.jpg" alt="这里写图片描述" title="" /></p>

        <p>为了解决线性模型的缺点，我们可以使用非线性模型来进行分类。例如数据集D不是线性可分的，而是圆形可分的，圆形内部是正类，外面是负类。假设它的hypotheses可以写成： <br />
            <script type="math/tex; mode=display" id="MathJax-Element-6">h_{SEP}(x)=sign(-x_1^2-x_2^2+0.6)</script> <br />
            基于这种非线性思想，我们之前讨论的PLA、Regression问题都可以有非线性的形式进行求解。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f35da92ec1aae62c804060128b9cf820.jpg" alt="这里写图片描述" title="" /></p>

        <p>下面介绍如何设计这些非线性模型的演算法。还是上面介绍的平面圆形分类例子，它的h(x)的权重w0=0.6，w1=-1，w2=-1，但是h(x)的特征不是线性模型的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/23f21045417ca4ec2d7980f146526acf.jpg" />，而是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/83144264087c3f220dda465ccd0f3236.jpg" />。我们令<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c96b43c76a27486c04105af2fd5f9b1b.jpg" />，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d42911a5af6de79f71961bc7ae80d03f.jpg" />，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bc4f9026a95c8fcdf9b9e8424c38a306.jpg" />，那么，h(x)变成：</p>

        <p></p>
        <div class="MathJax_Display" role="textbox" aria-readonly="true"></div>
        <script type="math/tex; mode=display" id="MathJax-Element-12">h(x)=sign(\breve{w}_0\cdot z_0+\breve{w}_1\cdot z_1+\breve{w}_2\cdot z_2)=sign(0.6\cdot z_0-1\cdot z_1-1\cdot z_2)=sign(\breve{w}^Tz)</script>
        <p></p>

        <p>这种<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/443bbd604918b6e58dc1d4b87dee6b4f.jpg" />的转换可以看成是x空间的点映射到z空间中去，而在z域中，可以用一条直线进行分类，也就是从x空间的圆形可分映射到z空间的线性可分。z域中的直线对应于x域中的圆形。因此，我们把<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/443bbd604918b6e58dc1d4b87dee6b4f.jpg" />这个过程称之为特征转换（Feature
            Transform）。通过这种特征转换，可以将非线性模型转换为另一个域中的线性模型。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f217098996d359808b6b5769e2268577.jpg" alt="这里写图片描述" title="" /></p>

        <p>已知x域中圆形可分在z域中是线性可分的，那么反过来，如果在z域中线性可分，是否在x域中一定是圆形可分的呢？答案是否定的。由于权重向量w取值不同，x域中的hypothesis可能是圆形、椭圆、双曲线等等多种情况。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/19f09135d3aad96555e46ade99f7ba75.jpg" alt="这里写图片描述" title="" /></p>

        <p>目前讨论的x域中的圆形都是圆心过原点的，对于圆心不过原点的一般情况，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/443bbd604918b6e58dc1d4b87dee6b4f.jpg" />映射公式包含的所有项为：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-16">\Phi_2(x)=(1,x_1,x_2,x_1^2,x_1x_2,x_2^2)</script>
        </p>

        <p>也就是说，对于二次hypothesis，它包含二次项、一次项和常数项1，z域中每一条线对应x域中的某二次曲线的分类方式，也许是圆，也许是椭圆，也许是双曲线等等。那么z域中的hypothesis可以写成：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b034e0c608f73a487e08b20ed0c421e8.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="二nonlinear-transform" class="sigil_not_in_toc"><strong>二、Nonlinear Transform</strong></h3>

        <p>上一部分我们定义了什么了二次hypothesis，那么这部分将介绍如何设计一个好的二次hypothesis来达到良好的分类效果。那么目标就是在z域中设计一个最佳的分类线。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/94a6727fce6e5fbbdaee9c5ed7df2de4.jpg" alt="这里写图片描述" title="" /></p>

        <p>其实，做法很简单，利用映射变换的思想，通过映射关系，把x域中的最高阶二次的多项式转换为z域中的一次向量，也就是从quardratic
            hypothesis转换成了perceptrons问题。用z值代替x多项式，其中向量z的个数与x域中x多项式的个数一致（包含常数项）。这样就可以在z域中利用线性分类模型进行分类训练。训练好的线性模型之后，再将z替换为x的多项式就可以了。具体过程如下：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/377c85162529769ec888bd1331a01d44.jpg" alt="这里写图片描述" title="" /></p>

        <p>整个过程就是通过映射关系，换个空间去做线性分类，重点包括两个：</p>

        <ul>
            <li>
                <p>特征转换</p>
            </li>
            <li>
                <p>训练线性模型</p>
            </li>
        </ul>

        <p>其实，我们以前处理机器学习问题的时候，已经做过类似的特征变换了。比如数字识别问题，我们从原始的像素值特征转换为一些实际的concrete特征，比如密度、对称性等等，这也用到了feature transform的思想。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c68f601fc3729387f05503f06f2563a4.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="三price-of-nonlinear-transform" class="sigil_not_in_toc"><strong>三、Price of Nonlinear Transform</strong></h3>

        <p>若x特征维度是d维的，也就是包含d个特征，那么二次多项式个数，即z域特征维度是： <br />
            <script type="math/tex; mode=display" id="MathJax-Element-17">\breve d=1+C_d^1+C_d^2+d=\frac{d(d+3)}2+1</script>
            <br />
            如果x特征维度是2维的，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ecbcbf34897464768bf6731e7d181590.jpg" />，那么它的二次多项式为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9ffab1af30c8a68a6e629cb869e5ec53.jpg" />，有6个。</p>

        <p>现在，如果阶数更高，假设阶数为Q，那么对于x特征维度是d维的，它的z域特征维度为： <br />
            <script type="math/tex; mode=display" id="MathJax-Element-20">\breve d=C_{Q+d}^Q=C_{Q+d}^d=O(Q^d)</script>
            <br />
            由上式可以看出，计算z域特征维度个数的时间复杂度是Q的d次方，随着Q和d的增大，计算量会变得很大。同时，空间复杂度也大。也就是说，这种特征变换的一个代价是计算的时间、空间复杂度都比较大。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ce784aafe9a3a2ea2390c2836f4e9315.jpg" alt="这里写图片描述" title="" /></p>

        <p>另一方面，z域中特征个数随着Q和d增加变得很大，同时权重w也会增大，即自由度增加，VC Dimension增大。令z域中的特征维度是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/937d7fcd7594fc406d8ebe66448c3544.jpg" />，则在在域中，任何<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6b9c09e85554343ce6ace4736edfb0f7.jpg" />的输入都不能被shattered；同样，在x域中，任何<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6b9c09e85554343ce6ace4736edfb0f7.jpg" />的输入也不能被shattered。<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25fbd9639473681a50a99bba3de0bd0a.jpg" />是VC Dimension的上界，如果<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25fbd9639473681a50a99bba3de0bd0a.jpg" />很大的时候，相应的VC
            Dimension就会很大。根据之前章节课程的讨论，VC Dimension过大，模型的泛化能力会比较差。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b96b5d43475682bf7312b714a09f3066.jpg" alt="这里写图片描述" title="" /></p>

        <p>下面通过一个例子来解释为什么VC Dimension过大，会造成不好的分类效果：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4dae0dca3bf0d84d1d50d117a0b04294.jpg" alt="这里写图片描述" title="" /></p>

        <p>上图中，左边是用直线进行线性分类，有部分点分类错误；右边是用四次曲线进行非线性分类，所有点都分类正确，那么哪一个分类效果好呢？单从平面上这些训练数据来看，四次曲线的分类效果更好，但是四次曲线模型很容易带来过拟合的问题，虽然它的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9c719640427bb747a1928886404350c0.jpg" />比较小，从泛化能力上来说，还是左边的分类器更好一些。也就是说VC
            Dimension过大会带来过拟合问题，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25fbd9639473681a50a99bba3de0bd0a.jpg" />不能太大了。</p>

        <p>那么如何选择合适的Q，来保证不会出现过拟合问题，使模型的泛化能力强呢？一般情况下，为了尽量减少特征自由度，我们会根据训练样本的分布情况，人为地减少、省略一些项。但是，这种人为地删减特征会带来一些“自我分析”代价，虽然对训练样本分类效果好，但是对训练样本外的样本，不一定效果好。所以，一般情况下，还是要保存所有的多项式特征，避免对训练样本的人为选择。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ebdbeebcca2616b660f6580fb985ac6d.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="四structured-hypothesis-sets" class="sigil_not_in_toc"><strong>四、Structured Hypothesis Sets</strong></h3>

        <p>下面，我们讨论一下从x域到z域的多项式变换。首先，如果特征维度只有1维的话，那么变换多项式只有常数项：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-28">\Phi_0(x)=(1)</script>
        </p>

        <p>如果特征维度是两维的，变换多项式包含了一维的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/62ca6b4f66fa3ee40d55bf34de5fe5bf.jpg" />：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-30">\Phi_1(x)=(\Phi_0(x),x_1,x_2,\ldots,x_d)</script>
        </p>

        <p>如果特征维度是三维的，变换多项式包含了二维的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/49c76fc2aaadf9ad39673948f1dc07e9.jpg" />：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-32">\Phi_2(x)=(\Phi_1(x),x_1^2,x_1x_2,\ldots,x_d^2)</script>
        </p>

        <p>以此类推，如果特征维度是Q次，那么它的变换多项式为：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-33">\Phi_Q(x)=(\Phi_{Q-1}(x),x_1^Q,x_1^{Q-1}x_2,\cdots,x_d^Q)</script>
        </p>

        <p>那么对于不同阶次构成的hypothesis有如下关系：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-34">H_{\Phi_0} \subset H_{\Phi_1} \subset H_{\Phi_2} \subset \cdots \subset H_{\Phi_Q}</script>
        </p>

        <p>我们把这种结构叫做Structured Hypothesis Sets：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/883b3cf822121f890b73de2d155501b8.jpg" alt="这里写图片描述" title="" /></p>

        <p>那么对于这种Structured Hypothesis Sets，它们的VC Dimension满足下列关系：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-35">d_{VC}(H_0)\leq d_{VC}(H_1)\leq d_{VC}(H_2)\leq \cdots \leq d_{VC}(H_Q)</script>
        </p>

        <p>它的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9c719640427bb747a1928886404350c0.jpg" />满足下列关系：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-37">E_{in}(g_0)\geq E_{in}(g_1)\geq E_{in}(g_2)\geq \cdots \geq E_{in}(g_Q)</script>
        </p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b28d2450f24b8ec052d6fe2dfce62eb1.jpg" alt="这里写图片描述" title="" /></p>

        <p>从上图中也可以看到，随着变换多项式的阶数增大，虽然<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9c719640427bb747a1928886404350c0.jpg" />逐渐减小，但是model
            complexity会逐渐增大，造成<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/078e128060018c90659bf99237fe3db0.jpg" />很大，所以阶数不能太高。</p>

        <p>那么，如果选择的阶数很大，确实能使<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9c719640427bb747a1928886404350c0.jpg" />接近于0，但是泛化能力通常很差，我们把这种情况叫做tempting
            sin。所以，一般最合适的做法是先从低阶开始，如先选择一阶hypothesis，看看<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9c719640427bb747a1928886404350c0.jpg" />是否很小，如果<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9c719640427bb747a1928886404350c0.jpg" />足够小的话就选择一阶，如果<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9c719640427bb747a1928886404350c0.jpg" />大的话，再逐渐增加阶数，直到满足要求为止。也就是说，尽量选择低阶的hypothes，这样才能得到较强的泛化能力。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7c8fa1cf76368fb9e519a3dfbfb62efd.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="五总结" class="sigil_not_in_toc"><strong>五、总结</strong></h3>

        <p>这节课主要介绍了非线性分类模型，通过非线性变换，将非线性模型映射到另一个空间，转换为线性模型，再来进行线性分类。本节课完整介绍了非线性变换的整体流程，以及非线性变换可能会带来的一些问题：时间复杂度和空间复杂度的增加。最后介绍了在要付出代价的情况下，使用非线性变换的最安全的做法，尽可能使用简单的模型，而不是模型越复杂越好。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习基石》课程</p>
    </div>

    <h1>
        13 -- Hazard of Overfitting

    </h1>
    <div class="markdown_views">
        <p>上节课我们主要介绍了非线性分类模型，通过非线性变换，将非线性模型映射到另一个空间，转换为线性模型，再来进行分类，分析了非线性变换可能会使计算复杂度增加。本节课介绍这种模型复杂度增加带来机器学习中一个很重要的问题：过拟合（overfitting）。</p>

        <h3 id="一what-is-overfitting" class="sigil_not_in_toc"><strong>一、What is Overfitting?</strong></h3>

        <p>首先，我们通过一个例子来介绍什么bad
            generalization。假设平面上有5个点，目标函数f(x)是2阶多项式，如果hypothesis是二阶多项式加上一些小的noise的话，那么这5个点很靠近这个hypothesis，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />很小。如果hypothesis是4阶多项式，那么这5点会完全落在hypothesis上，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />。虽然4阶hypothesis的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />比2阶hypothesis的要好很多，但是它的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />很大。因为根据VC Bound理论，阶数越大，即VC
            Dimension越大，就会让模型复杂度更高，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />更大。我们把这种<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />很小，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />很大的情况称之为bad generation，即泛化能力差。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8b35919d6c3847e9167dd790619244da.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们回过头来看一下VC曲线：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b4bcb9d82132b4546abb8d1f4fef3ff8.jpg" alt="这里写图片描述" title="" /></p>

        <p>hypothesis的阶数越高，表示VC Dimension越大。随着VC Dimension增大，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />是一直减小的，而<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />先减小后增大。在<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e78022899d14b399b40a5bcfb9aab01.jpg" />位置，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />取得最小值。在<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7c5d2026812edc7297d7c5c45babefd4.jpg" />右侧，随着VC
            Dimension越来越大，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />越来越小，接近于0，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />越来越大。即当VC
            Dimension很大的时候，这种对训练样本拟合过分好的情况称之为过拟合（overfitting）。另一方面，在<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7c5d2026812edc7297d7c5c45babefd4.jpg" />左侧，随着VC
            Dimension越来越小，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />都越来越大，这种情况称之为欠拟合（underfitting），即模型对训练样本的拟合度太差，VC
            Dimension太小了。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a67e598c89660e000ab15c2d05fc167e.jpg" alt="这里写图片描述" title="" /></p>

        <p>bad generation和overfitting的关系可以理解为：overfitting是VC Dimension过大的一个过程，bad generation是overfitting的结果。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4702d18415f53b0553433af5c00dac03.jpg" alt="这里写图片描述" title="" /></p>

        <p>一个好的fit，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />都比较小，尽管<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />没有足够接近零；而对overfitting来说，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />，但是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />很大。那么，overfitting的原因有哪些呢？</p>

        <p>我们举个开车的例子，把发生车祸比作成overfitting，那么造成车祸的原因包括：</p>

        <ul>
            <li>
                <p><strong>车速太快（VC Dimension太大）；</strong></p>
            </li>
            <li>
                <p><strong>道路崎岖（noise）；</strong></p>
            </li>
            <li>
                <p><strong>对路况的了解程度（训练样本数量N不够）；</strong></p>
            </li>
        </ul>

        <p>也就是说，VC Dimension、noise、N这三个因素是影响过拟合现象的关键。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/96d4d72c6e617ab15d9b5b84c66f3708.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="二the-role-of-noise-and-data-size" class="sigil_not_in_toc"><strong>二、The Role of Noise and Data Size</strong></h3>

        <p>为了尽可能详细地解释overfitting，我们进行这样一个实验，试验中的数据集不是很大。首先，在二维平面上，一个模型的分布由目标函数f(x)（x的10阶多项式）加上一些noise构成，下图中，离散的圆圈是数据集，目标函数是蓝色的曲线。数据没有完全落在曲线上，是因为加入了noise。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3e6736b18dc38fde10a9b6e71d187660.jpg" alt="这里写图片描述" title="" /></p>

        <p>然后，同样在二维平面上，另一个模型的分布由目标函数f(x)（x的50阶多项式）构成，没有加入noise。下图中，离散的圆圈是数据集，目标函数是蓝色的曲线。可以看出由于没有noise，数据集完全落在曲线上。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/82df761281cf8b19cc728efba567a38f.jpg" alt="这里写图片描述" title="" /></p>

        <p>现在，有两个学习模型，一个是2阶多项式，另一个是10阶多项式，分别对上面两个问题进行建模。首先，对于第一个目标函数是10阶多项式包含noise的问题，这两个学习模型的效果如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/78a0075247ede814a6a913fedb91976d.jpg" alt="这里写图片描述" title="" /></p>

        <p>由上图可知，2阶多项式的学习模型<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />；10阶多项式的学习模型<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />。虽然10阶模型的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />比2阶的小，但是其<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />要比2阶的大得多，而2阶的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />相差不大，很明显用10阶的模型发生了过拟合。</p>

        <p>然后，对于第二个目标函数是50阶多项式没有noise的问题，这两个学习模型的效果如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7ca36033ef44c93dd0d7743cd319ea9c.jpg" alt="这里写图片描述" title="" /></p>

        <p>由上图可知，2阶多项式的学习模型<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />；10阶多项式的学习模型<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />。虽然10阶模型的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />比2阶的小，但是其<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />要比2阶的大得多的多，而2阶的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />相差不大，很明显用10阶的模型仍然发生了明显的过拟合。</p>

        <p>上面两个问题中，10阶模型都发生了过拟合，反而2阶的模型却表现得相对不错。这好像违背了我们的第一感觉，比如对于目标函数是10阶多项式，加上noise的模型，按道理来说应该是10阶的模型更能接近于目标函数，因为它们阶数相同。但是，事实却是2阶模型泛化能力更强。这种现象产生的原因，从哲学上来说，就是“以退为进”。有时候，简单的学习模型反而能表现的更好。</p>

        <p>下面从learning curve来分析一下具体的原因，learning curve描述的是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />随着数据量N的变化趋势。下图中左边是2阶学习模型的learning
            curve，右边是10阶学习模型的learning curve。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7924b520aae63885cd2f5a916e52fe48.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们的第9次课的笔记<a href="http://blog.csdn.net/red_stone1/article/details/71599034"> NTU林轩田机器学习基石课程学习笔记9 – Linear
                Regression</a>已经介绍过了learning curve。在learning curve中，横轴是样本数量N，纵轴是Error。<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />可表示为：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-43">E_{in}=noise level\ast (1-\frac{d+1}N) </script>
        </p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-44">E_{out}=noise level\ast (1+\frac{d+1}N) </script>
        </p>

        <p>其中d为模型阶次，左图中d=2，右图中d=10。</p>

        <p>本节的实验问题中，数据量N不大，即对应于上图中的灰色区域。左图的灰色区域中，因为d=2，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />相对来说比较接近；右图中的灰色区域中，d=10，根据<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />的表达式，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />很小，而<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />很大。这就解释了之前2阶多项式模型的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />更接近<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />，泛化能力更好。</p>

        <p>值得一提的是，如果数据量N很大的时候，上面两图中<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />都比较接近，但是对于高阶模型，z域中的特征很多的时候，需要的样本数量N很大，且容易发生维度灾难。关于维度灾难的详细生动解释，请参考我另一篇博文：</p>

        <p><a href="http://blog.csdn.net/red_stone1/article/details/71692444">机器学习中的维度灾难</a></p>

        <p>另一个例子中，目标函数是50阶多项式，且没有加入noise。这种情况下，我们发现仍然是2阶的模型拟合的效果更好一些，明明没有noise，为什么是这样的结果呢？</p>

        <p>实际上，我们忽略了一个问题：这种情况真的没有noise吗？其实，当模型很复杂的时候，即50阶多项式的目标函数，无论是2阶模型还是10阶模型，都不能学习的很好，这种复杂度本身就会引入一种‘noise’。所以，这种高阶无noise的问题，也可以类似于10阶多项式的目标函数加上noise的情况，只是二者的noise有些许不同，下面一部分将会详细解释。</p>

        <h3 id="三deterministic-noise" class="sigil_not_in_toc"><strong>三、Deterministic Noise</strong></h3>

        <p>下面我们介绍一个更细节的实验来说明 什么时候小心overfit会发生。假设我们产生的数据分布由两部分组成：第一部分是目标函数f(x)，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ab65852c33efef0b8fc859c7b8dd7477.jpg" />阶多项式；第二部分是噪声<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/87dfe90cae1c6aed9a5c545eeda75b3c.jpg" />，服从Gaussian分布。接下来我们分析的是noise强度不同对overfitting有什么样的影响。总共的数据量是N。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a43d0243751ccbfcf0d620d8ff812b4e.jpg" alt="这里写图片描述" title="" /></p>

        <p>那么下面我们分析不同的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d70ddcfef0d29b2f82a44f442c6908f8.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a16f1c14231349b1f230b6808cf2ebb6.jpg" />对overfit的影响。overfit可以量化为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />。结果如下：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/88ae6b800f373c25aa80f3391583919f.jpg" alt="这里写图片描述" title="" /></p>

        <p>上图中，红色越深，代表overfit程度越高，蓝色越深，代表overfit程度越低。先看左边的图，左图中阶数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ab65852c33efef0b8fc859c7b8dd7477.jpg" />固定为20，横坐标代表样本数量N，纵坐标代表噪声水平<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/451a1b1a43098a6dd2cb1b36b31750f1.jpg" />。红色区域集中在N很小或者<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/451a1b1a43098a6dd2cb1b36b31750f1.jpg" />很大的时候，也就是说N越大，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/451a1b1a43098a6dd2cb1b36b31750f1.jpg" />越小，越不容易发生overfit。右边图中<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/451a1b1a43098a6dd2cb1b36b31750f1.jpg" />，横坐标代表样本数量N，纵坐标代表目标函数阶数<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ab65852c33efef0b8fc859c7b8dd7477.jpg" />。红色区域集中在N很小或者<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ab65852c33efef0b8fc859c7b8dd7477.jpg" />很大的时候，也就是说N越大，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ab65852c33efef0b8fc859c7b8dd7477.jpg" />越小，越不容易发生overfit。上面两图基本相似。</p>

        <p>从上面的分析，我们发现<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/451a1b1a43098a6dd2cb1b36b31750f1.jpg" />对overfit是有很大的影响的，我们把这种noise称之为stochastic
            noise。同样地，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ab65852c33efef0b8fc859c7b8dd7477.jpg" />即模型复杂度也对overfit有很大影响，而且二者影响是相似的，所以我们把这种称之为deterministic
            noise。之所以把它称为noise，是因为模型高复杂度带来的影响。</p>

        <p>总结一下，有四个因素会导致发生overfitting：</p>

        <ul>
            <li>
                <p><strong>data size N <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dd0fb357e171e58b92919b3fd5ac5602.jpg" /></strong></p>
            </li>
            <li>
                <p><strong>stochastic noise <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/451a1b1a43098a6dd2cb1b36b31750f1.jpg" /></strong></p>
            </li>
            <li>
                <p><strong>deterministic noise <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ab65852c33efef0b8fc859c7b8dd7477.jpg" /></strong></p>
            </li>
            <li>
                <p><strong>excessive power <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bead363a3a6de16821cb287cf998100e.jpg" /></strong></p>
            </li>
        </ul>

        <p>我们刚才解释了如果目标函数f(x)的复杂度很高的时候，那么跟有noise也没有什么两样。因为目标函数很复杂，那么再好的hypothesis都会跟它有一些差距，我们把这种差距称之为deterministic
            noise。deterministic noise与stochastic noise不同，但是效果一样。其实deterministic
            noise类似于一个伪随机数发生器，它不会产生真正的随机数，而只产生伪随机数。它的值与hypothesis有关，且固定点x的deterministic noise值是固定的。</p>

        <h3 id="四dealing-with-overfitting" class="sigil_not_in_toc"><strong>四、Dealing with Overfitting</strong></h3>

        <p>现在我们知道了什么是overfitting，和overfitting产生的原因，那么如何避免overfitting呢？避免overfitting的方法主要包括：</p>

        <ul>
            <li>
                <p><strong>start from simple model</strong></p>
            </li>
            <li>
                <p><strong>data cleaning/pruning</strong></p>
            </li>
            <li>
                <p><strong>data hinting</strong></p>
            </li>
            <li>
                <p><strong>regularization</strong></p>
            </li>
            <li>
                <p><strong>validataion</strong></p>
            </li>
        </ul>

        <p>这几种方法类比于之前举的开车的例子，对应如下：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fd663c95106a03b61bb80580cf26da08.jpg" alt="这里写图片描述" title="" /></p>

        <p>regularization和validation我们之后的课程再介绍，本节课主要介绍简单的data cleaning/pruning和data hinting两种方法。</p>

        <p>data cleaning/pruning就是对训练数据集里label明显错误的样本进行修正（data cleaning），或者对错误的样本看成是noise，进行剔除（data pruning）。data
            cleaning/pruning关键在于如何准确寻找label错误的点或者是noise的点，而且如果这些点相比训练样本N很小的话，这种处理效果不太明显。</p>

        <p>data hinting是针对N不够大的情况，如果没有办法获得更多的训练集，那么data
            hinting就可以对已知的样本进行简单的处理、变换，从而获得更多的样本。举个例子，数字分类问题，可以对已知的数字图片进行轻微的平移或者旋转，从而让N丰富起来，达到扩大训练集的目的。这种额外获得的例子称之为virtual
            examples。但是要注意一点的就是，新获取的virtual examples可能不再是iid某个distribution。所以新构建的virtual examples要尽量合理，且是独立同分布的。</p>

        <h3 id="五总结" class="sigil_not_in_toc"><strong>五、总结</strong></h3>

        <p>本节课主要介绍了overfitting的概念，即当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52a47d801ee7c4a5d41f5a74b365d330.jpg" />很小，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5b56c7c95405cd960d2ec9f02a442fd.jpg" />很大的时候，会出现overfitting。详细介绍了overfitting发生的四个常见原因data
            size N、stochastic noise、deterministic noise和excessive power。解决overfitting的方法有很多，本节课主要介绍了data
            cleaning/pruning和data hinting两种简单的方法，之后的课程将会详细介绍regularization和validataion两种更重要的方法。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习基石》课程</p>
    </div>

    <h1>
        14 -- Regularization

    </h1>
    <div class="markdown_views">
        <p>上节课我们介绍了过拟合发生的原因：excessive power, stochastic/deterministic noise 和limited
            data。并介绍了解决overfitting的简单方法。本节课，我们将介绍解决overfitting的另一种非常重要的方法：Regularization规则化。</p>

        <h3 id="一regularized-hypothesis-set" class="sigil_not_in_toc"><strong>一、Regularized Hypothesis Set</strong></h3>

        <p>先来看一个典型的overfitting的例子：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0628638c90c433fa742af5d2a184acf1.jpg" alt="这里写图片描述" title="" /></p>

        <p>如图所示，在数据量不够大的情况下，如果我们使用一个高阶多项式（图中红色曲线所示），例如10阶，对目标函数（蓝色曲线）进行拟合。拟合曲线波动很大，虽然<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f9a04b9f5a6d023002e116c8c6854dff.jpg" />很小，但是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/245882eb75d78bef2732bf34a68dbdd5.jpg" />很大，也就造成了过拟合现象。</p>

        <p>那么如何对过拟合现象进行修正，使hypothesis更接近于target function呢？一种方法就是regularized fit。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6a542844bf67ab123e8b5d250148c429.jpg" alt="这里写图片描述" title="" /></p>

        <p>这种方法得到的红色fit曲线，要比overfit的红色曲线平滑很多，更接近与目标函数，它的阶数要更低一些。那么问题就变成了我们要把高阶（10阶）的hypothesis sets转换为低阶（2阶）的hypothesis
            sets。通过下图我们发现，不同阶数的hypothesis存在如下包含关系：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ddf4b7683d609ae8e46bf7519c65cfc1.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们发现10阶多项式hypothesis sets里包含了2阶多项式hypothesis sets的所有项，那么在<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/487acc196899db05fb9c2c0bb2cdf37a.jpg" />中加入一些限定条件，使它近似为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4866d85ea0db0c723a655ede34a15bac.jpg" />即可。这种函数近似曾被称之为不适定问题（ill-posed problem）。</p>

        <p>如何从10阶转换为2阶呢？首先，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/487acc196899db05fb9c2c0bb2cdf37a.jpg" />可表示为： <br />
            <script type="math/tex; mode=display" id="MathJax-Element-6">H_{10}=w_0+w_1x+w_2x^2+w_3x^3+\cdots+w_{10}x^{10}</script>
        </p>

        <p>而<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4866d85ea0db0c723a655ede34a15bac.jpg" />可表示为： <br />
            <script type="math/tex; mode=display" id="MathJax-Element-8">H_2=w_0+w_1x+w_2x^2</script>
        </p>

        <p>所以，如果限定条件是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2c4e3e868326c65fa8336ad12e03250b.jpg" />，那么就有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4866d85ea0db0c723a655ede34a15bac.jpg" />。也就是说，对于高阶的hypothesis，为了防止过拟合，我们可以将其高阶部分的权重w限制为0，这样，就相当于从高阶的形式转换为低阶，fit波形更加平滑，不容易发生过拟合。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c21531648d050b73ef357391fcd3ae38.jpg" alt="这里写图片描述" title="" /></p>

        <p>那有一个问题，令<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/487acc196899db05fb9c2c0bb2cdf37a.jpg" />高阶权重w为0，为什么不直接使用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4866d85ea0db0c723a655ede34a15bac.jpg" />呢？这样做的目的是拓展我们的视野，为即将讨论的问题做准备。刚刚我们讨论的限制是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/487acc196899db05fb9c2c0bb2cdf37a.jpg" />高阶部分的权重w限制为0，这是比较苛刻的一种限制。下面，我们把这个限制条件变得更宽松一点，即令任意8个权重w为0，并不非要限定<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2c4e3e868326c65fa8336ad12e03250b.jpg" />，这个Looser Constraint可以写成： <br />
            <script type="math/tex; mode=display" id="MathJax-Element-15">\sum_{q=0}^{10}(w_q\neq0)\leq3</script>
        </p>

        <p>也就只是限定了w不为0的个数，并不限定必须是高阶的w。这种hypothesis记为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4866d85ea0db0c723a655ede34a15bac.jpg" />，称为sparse
            hypothesis set，它与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4866d85ea0db0c723a655ede34a15bac.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/487acc196899db05fb9c2c0bb2cdf37a.jpg" />的关系为：
            <br />
            <script type="math/tex; mode=display" id="MathJax-Element-19">H_2\subset H_2'\subset H_{10}</script>
        </p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/58d332e68011bd9a7587aa23e5af6e73.jpg" alt="这里写图片描述" title="" /></p>

        <p>Looser Constraint对应的hypothesis应该更好解一些，但事实是sparse hypothesis set <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4866d85ea0db0c723a655ede34a15bac.jpg" />被证明也是NP-hard，求解非常困难。所以，还要转换为另一种易于求解的限定条件。</p>

        <p>那么，我们寻找一种更容易求解的宽松的限定条件Softer Constraint，即：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-21">\sum_{q=0}^{10}w_q^2=||w||^2\leq C</script>
        </p>

        <p>其中，C是常数，也就是说，所有的权重w的平方和的大小不超过C，我们把这种hypothesis sets记为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/76ba84f2965d55b7076999ff997e88bc.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4866d85ea0db0c723a655ede34a15bac.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/76ba84f2965d55b7076999ff997e88bc.jpg" />的关系是，它们之间有重叠，有交集的部分，但是没有完全包含的关系，也不一定相等。对应<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/76ba84f2965d55b7076999ff997e88bc.jpg" />，C值越大，限定的范围越大，即越宽松：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-26">H(0)\subset H(1.126)\subset \cdots \subset H(1126)\subset \cdots \subset H(\infty)=H_{10}</script>
        </p>

        <p>当C无限大的时候，即限定条件非常宽松，相当于没有加上任何限制，就与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/487acc196899db05fb9c2c0bb2cdf37a.jpg" />没有什么两样。<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/76ba84f2965d55b7076999ff997e88bc.jpg" />称为regularized
            hypothesis set，这种形式的限定条件是可以进行求解的，我们把求解的满足限定条件的权重w记为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fb11694f0944d2eb1758f4cc4c364ff4.jpg" />。接下来就要探讨如何求解<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fb11694f0944d2eb1758f4cc4c364ff4.jpg" />。</p>

        <h3 id="二weight-decay-regularization" class="sigil_not_in_toc"><strong>二、Weight Decay Regularization</strong></h3>

        <p>现在，针对H(c)，即加上限定条件，我们的问题变成：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b892f677aa4097a85a0e4b94db4ec9d9.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们的目的是计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f9a04b9f5a6d023002e116c8c6854dff.jpg" />的最小值，限定条件是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c85f8597ddf70e009d31d40b2e717870.jpg" />。这个限定条件从几何角度上的意思是，权重w被限定在半径为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bf4f4dd5c7dee15c74e796844a782030.jpg" />的圆内，而球外的w都不符合要求，即便它是靠近<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f9a04b9f5a6d023002e116c8c6854dff.jpg" />梯度为零的w。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/57da8bcedfb8dbd0ee8f0b300461b013.jpg" alt="这里写图片描述" title="" /></p>

        <p>下面用一张图来解释在限定条件下，最小化<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f9a04b9f5a6d023002e116c8c6854dff.jpg" />的过程：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5d6299f58bb5b2c913a449372e182016.jpg" alt="这里写图片描述" title="" /></p>

        <p>如上图所示，假设在空间中的一点w，根据梯度下降算法，w会朝着<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e0c4f909b6260b7712228261220ea320.jpg" />的方向移动（图中蓝色箭头指示的方向），在没有限定条件的情况下，w最终会取得最小值<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/779c9fcfd1d162fd45bc520817c2d761.jpg" />，即“谷底”的位置。现在，加上限定条件，即w被限定在半径为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bf4f4dd5c7dee15c74e796844a782030.jpg" />的圆内，w距离原点的距离不能超过圆的半径，球如图中红色圆圈所示<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d0e69aef985f70d39cca96be12c5ab08.jpg" />。那么，这种情况下，w不能到达<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/779c9fcfd1d162fd45bc520817c2d761.jpg" />的位置，最大只能位于圆上，沿着圆的切线方向移动（图中绿色箭头指示的方向）。与绿色向量垂直的向量（图中红色箭头指示的方向）是圆切线的法向量，即w的方向，w不能靠近红色箭头方向移动。那么随着迭代优化过程，只要<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e0c4f909b6260b7712228261220ea320.jpg" />与w点切线方向不垂直，那么根据向量知识，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e0c4f909b6260b7712228261220ea320.jpg" />一定在w点切线方向上有不为零的分量，即w点会继续移动。只有当<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e0c4f909b6260b7712228261220ea320.jpg" />与绿色切线垂直，即与红色法向量平行的时候，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e0c4f909b6260b7712228261220ea320.jpg" />在切线方向上没有不为零的分量了，也就表示这时w达到了最优解的位置。</p>

        <p>有了这个平行的概念，我们就得到了获得最优解需要满足的性质：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-45">\nabla E_{in}(w_{REG})+\frac{2\lambda}{N}w_{REG}=0</script>
        </p>

        <p>上面公式中的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />称为Lagrange
            multiplier，是用来解有条件的最佳化问题常用的数学工具，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e399133eb1cc1132331b957c38495a00.jpg" />是方便后面公式推导。那么我们的目标就变成了求解满足上面公式的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fb11694f0944d2eb1758f4cc4c364ff4.jpg" />。</p>

        <p>之前我们推导过，线性回归的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f9a04b9f5a6d023002e116c8c6854dff.jpg" />的表达式为：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-50">E_{in}=\frac1N\sum_{n=1}^N(x_n^Tw-y_n)^2</script>
        </p>

        <p>计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f9a04b9f5a6d023002e116c8c6854dff.jpg" />梯度，并代入到平行条件中，得到：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-52">\frac2N(Z^TZw_{REG}-Z^Ty)+\frac{2\lambda}Nw_{REG}=0</script>
        </p>

        <p>这是一个线性方程式，直接得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fb11694f0944d2eb1758f4cc4c364ff4.jpg" />为：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-54">w_{REG}=(Z^TZ+\lambda I)^{-1}Z^Ty</script>
        </p>

        <p>上式中包含了求逆矩阵的过程，因为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/76af03082dab295bcef9cf5b63b515bd.jpg" />是半正定矩阵，如果<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />大于零，那么<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/76af03082dab295bcef9cf5b63b515bd.jpg" />一定是正定矩阵，即一定可逆。另外提一下，统计学上把这叫做ridge
            regression，可以看成是linear regression的进阶版。</p>

        <p>如果对于更一般的情况，例如逻辑回归问题中，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6b4234f8f0d806ba68f82156c014a89b.jpg" />不是线性的，那么将其代入平行条件中得到的就不是一个线性方程式，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fb11694f0944d2eb1758f4cc4c364ff4.jpg" />不易求解。下面我们从另一个角度来看一下平行等式：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-60">\nabla E_{in}(w_{REG})+\frac{2\lambda}{N}w_{REG}=0</script>
        </p>

        <p>已知<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6b4234f8f0d806ba68f82156c014a89b.jpg" />是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f9a04b9f5a6d023002e116c8c6854dff.jpg" />对<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fb11694f0944d2eb1758f4cc4c364ff4.jpg" />的导数，而<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8df252ee5425a41bf9b81505e6f28d9e.jpg" />也可以看成是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3dfa9878ad8ec413def029068dbdde22.jpg" />的导数。那么平行等式左边可以看成一个函数的导数，导数为零，即求该函数的最小值。也就是说，问题转换为最小化该函数：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-66">E_{aug}(w)=E_{in}(w)+\frac{\lambda}Nw^Tw</script>
        </p>

        <p>该函数中第二项就是限定条件regularizer，也称为weight-decay regularization。我们把这个函数称为Augmented Error，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/76e2d27174aa547bb043174899910745.jpg" />。</p>

        <p>如果<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />不为零，对应于加上了限定条件，若<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />等于零，则对应于没有任何限定条件，问题转换成之前的最小化<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f9a04b9f5a6d023002e116c8c6854dff.jpg" />。</p>

        <p>下面给出一个曲线拟合的例子，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />取不同的值时，得到的曲线也不相同：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/49c4ad53dd71f3006b345747775e309c.jpg" alt="这里写图片描述" title="" /></p>

        <p>从图中可以看出，当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />时，发生了过拟合；当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />时，拟合的效果很好；当<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />时，发生了欠拟合。我们可以把<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />看成是一种penality，即对hypothesis复杂度的惩罚，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />越大，w就越小，对应于C值越小，即这种惩罚越大，拟合曲线就会越平滑，高阶项就会削弱，容易发生欠拟合。<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />一般取比较小的值就能达到良好的拟合效果，过大过小都有问题，但究竟取什么值，要根据具体训练数据和模型进行分析与调试。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/01ae691b56f8abcd1ae6029f8d50c118.jpg" alt="这里写图片描述" title="" /></p>

        <p>事实上，这种regularization不仅可以用在多项式的hypothesis中，还可以应用在logistic regression等其他hypothesis中，都可以达到防止过拟合的效果。</p>

        <p>我们目前讨论的多项式是形如<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a19e53f3d0993b6262026c86ea7afffd.jpg" />的形式，若x的范围限定在[-1,1]之间，那么可能导致<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fc2348cccc5b4caae74f9510440de722.jpg" />相对于低阶的值要小得多，则其对于的w非常大，相当于要给高阶项设置很大的惩罚。为了避免出现这种数据大小差别很大的情况，可以使用Legendre
            Polynomials代替<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a19e53f3d0993b6262026c86ea7afffd.jpg" />这种形式，Legendre
            Polynomials各项之间是正交的，用它进行多项式拟合的效果更好。关于Legendre Polynomials的概念这里不详细介绍，有兴趣的童鞋可以看一下<a href="https://en.wikipedia.org/wiki/Legendre_polynomials">维基百科</a>。</p>

        <h3 id="三regularization-and-vc-theory" class="sigil_not_in_toc"><strong>三、Regularization and VC Theory</strong></h3>

        <p>下面我们研究一下Regularization与VC理论之间的关系。Augmented Error表达式如下：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-82">E_{aug}(w)=E_{in}(w)+\frac{\lambda}Nw^Tw</script>
        </p>

        <p>VC Bound表示为：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-83">E_{out}(w)\leq E_{in}(w)+\Omega(H)</script>
        </p>

        <p>其中<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d98819125c64e9033cba9be34ddf5d7e.jpg" />表示的是单个hypothesis的复杂度，记为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/eae3474bffb2c48404d4a99814d8bb40.jpg" />；而<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3b273b44626e7829a870a146ba0696c1.jpg" />表示整个hypothesis set的复杂度。根据Augmented Error和VC
            Bound的表达式，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/eae3474bffb2c48404d4a99814d8bb40.jpg" />包含于<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3b273b44626e7829a870a146ba0696c1.jpg" />之内，所以，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/76e2d27174aa547bb043174899910745.jpg" />比<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f9a04b9f5a6d023002e116c8c6854dff.jpg" />更接近于<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/245882eb75d78bef2732bf34a68dbdd5.jpg" />，即更好地代表<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/245882eb75d78bef2732bf34a68dbdd5.jpg" />，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/76e2d27174aa547bb043174899910745.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/245882eb75d78bef2732bf34a68dbdd5.jpg" />之间的误差更小。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/536e79210fa3326d57c0f931e65a8cc5.jpg" alt="这里写图片描述" title="" /></p>

        <p>根据VC Dimension理论，整个hypothesis set的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3ede32294fd7aa1a37b78d4be699aa01.jpg" />，这是因为所有的w都考虑了，没有任何限制条件。而引入限定条件的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/228d730c8ab17399a7821674c0a3ca34.jpg" />，即有效的VC dimension。也就是说，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/df8bee418e750c05eb4f3ea0ccac0302.jpg" />比较大，因为它代表了整个hypothesis
            set，但是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9e4c19054920bb696023541e1d6d618c.jpg" />比较小，因为由于regularized的影响，限定了w只取一小部分。其中A表示regularized算法。当<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />时，有：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-100">d_{EFF}(H,A)\leq d_{VC}</script>
        </p>

        <p>这些与实际情况是相符的，比如对多项式拟合模型，当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />时，所有的w都给予考虑，相应的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2ec47ee64765a58de35b14c3ba9951c4.jpg" />很大，容易发生过拟合。当<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />且越来越大时，很多w将被舍弃，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9e4c19054920bb696023541e1d6d618c.jpg" />减小，拟合曲线越来越平滑，容易发生欠拟合。</p>

        <h3 id="四general-regularizers" class="sigil_not_in_toc"><strong>四、General Regularizers</strong></h3>

        <p>那么通用的Regularizers，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/eae3474bffb2c48404d4a99814d8bb40.jpg" />，应该选择什么样的形式呢？一般地，我们会朝着目标函数的方向进行选取。有三种方式：</p>

        <ul>
            <li>
                <p><strong>target-dependent</strong></p>
            </li>
            <li>
                <p><strong>plausible</strong></p>
            </li>
            <li>
                <p><strong>friendly</strong></p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/275fd367724df24567a5ebb1880edb89.jpg" alt="这里写图片描述" title="" /></p>

        <p>其实这三种方法跟之前error measure类似，其也有三种方法：</p>

        <ul>
            <li>
                <p><strong>user-dependent</strong></p>
            </li>
            <li>
                <p><strong>plausible</strong></p>
            </li>
            <li>
                <p><strong>friendly</strong></p>
            </li>
        </ul>

        <p>regularizer与error measure是机器学习模型设计中的重要步骤。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f6813d8320c1a435a3c6b47c0cf6d37d.jpg" alt="这里写图片描述" title="" /></p>

        <p>接下来，介绍两种Regularizer：L2和L1。L2 Regularizer一般比较通用，其形式如下：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-106">\Omega(w)=\sum_{q=0}^Qw_q^2=||w||_2^2</script>
        </p>

        <p>这种形式的regularizer计算的是w的平方和，是凸函数，比较平滑，易于微分，容易进行最优化计算。</p>

        <p>L1 Regularizer的表达式如下：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-107">\Omega(w)=\sum_{q=0}^Q|w_q|=||w||_1</script>
        </p>

        <p>L1计算的不是w的平方和，而是绝对值和，即长度和，也是凸函数。已知<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d0e69aef985f70d39cca96be12c5ab08.jpg" />围成的是圆形，而<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fa3a48f6803dde9d78f97e49d37ff44f.jpg" />围成的是正方形，那么在正方形的四个顶点处，是不可微分的（不像圆形，处处可微分）。根据之前介绍的平行等式推导过程，对应这种正方形，它的解大都位于四个顶点处（不太理解，欢迎补充赐教），因为正方形边界处的w绝对值都不为零，若<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e0c4f909b6260b7712228261220ea320.jpg" />不与其平行，那么w就会向顶点处移动，顶点处的许多w分量为零，所以，L1
            Regularizer的解是稀疏的，称为sparsity。优点是计算速度快。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/635be90afff56a814305942a3e64b8c9.jpg" alt="这里写图片描述" title="" /></p>

        <p>下面来看一下<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />如何取值，首先，若stochastic noise不同，那么一般情况下，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />取值有如下特点：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1b8802523a5d7e7ce17145f7366533a8.jpg" alt="这里写图片描述" title="" /></p>

        <p>从图中可以看出，stochastic noise越大，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />越大。</p>

        <p>另一种情况，不同的deterministic noise，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />取值有如下特点：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/47fa19e6f0ca6f5502b098ed7a26f419.jpg" alt="这里写图片描述" title="" /></p>

        <p>从图中可以看出，deterministic noise越大，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />越大。</p>

        <p>以上两种noise的情况下，都是noise越大，相应的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />也就越大。这也很好理解，如果在开车的情况下，路况也不好，即noise越多，那么就越会踩刹车，这里踩刹车指的就是regularization。但是大多数情况下，noise是不可知的，这种情况下如何选择<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />？这部分内容，我们下节课将会讨论。</p>

        <h3 id="五总结" class="sigil_not_in_toc"><strong>五、总结</strong></h3>

        <p>本节课主要介绍了Regularization。首先，原来的hypothesis set加上一些限制条件，就成了Regularized Hypothesis Set。加上限制条件之后，我们就可以把问题转化为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/698eb7045506202d5ee9af60ce79dd7c.jpg" />最小化问题，即把w的平方加进去。这种过程，实际上回降低VC
            Dimension。最后，介绍regularization是通用的机器学习工具，设计方法通常包括target-dependent，plausible，friendly等等。下节课将介绍如何选取合适的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b62ab2bbd282a7834aef6436264a5685.jpg" />来建立最佳拟合模型。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习基石》课程</p>
    </div>

    <h1>
        15 -- Validation

    </h1>
    <div class="markdown_views">
        <p>上节课我们主要讲了为了避免overfitting，可以使用regularization方法来解决。在之前的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc179d7399bc499d289e3530b24c554a.jpg" />上加上一个regularizer，生成<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d2a876b4761a506e87f9425e087950a9.jpg" />，将其最小化，这样可以有效减少模型的复杂度，避免过拟合现象的发生。那么，机器学习领域还有许多选择，如何保证训练的模型具有良好的泛化能力？本节课将介绍一些概念和方法来解决这个选择性的问题。</p>

        <h3 id="一model-selection-problem" class="sigil_not_in_toc"><strong>一、Model Selection Problem</strong></h3>

        <p>机器学习模型建立的过程中有许多选择，例如对于简单的二元分类问题，首先是算法A的选择，有PLA，pocket，linear regression，logistic
            regression等等；其次是迭代次数T的选择，有100，1000,10000等等；之后是学习速率<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f995254ff0d13566efbea9d484d08d83.jpg" />的选择，有1，0.01,0.0001等等；接着是模型特征转换<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3fbb3a8ecadcf6b3c5b65666f6362964.jpg" />的选择，有linear，quadratic，poly-10，Legendre-poly-10等等；然后是正则化regularizer的选择，有L2，L1等等；最后是正则化系数<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/452b3a0836b4cf36b99f61d30bc5c43a.jpg" />的选择，有0，0.01，1等等。不同的选择搭配，有不同的机器学习效果。我们的目标就是找到最合适的选择搭配，得到一个好的矩g，构建最佳的机器学习模型。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f684f6eab0c4f7d9bdc518ed292a5e94.jpg" alt="这里写图片描述" title="" /></p>

        <p>假设有M个模型，对应有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4bf5df0f322dcdea3ffd948a0f58b64a.jpg" />，即有M个hypothesis set，演算法为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ff8d0bfd9fd938109cfc039038cac6aa.jpg" />，共M个。我们的目标是从这M个hypothesis
            set中选择一个模型<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dba5ff82a1291aa4043c46bed7ef5002.jpg" />，通过演算法<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/266a41d78514f733a95fbcd76b5a8c30.jpg" />对样本集D的训练，得到一个最好的矩<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8bef8cb2ac711ae515b4bb17e2e4d088.jpg" />，使其<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f68c57dc39693d8d4a3e0269fc6733e7.jpg" />最小。所以，问题的关键就是机器学习中如何选择到最好的矩<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8bef8cb2ac711ae515b4bb17e2e4d088.jpg" />。</p>

        <p>考虑有这样一种方法，对M个模型分别计算使<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc179d7399bc499d289e3530b24c554a.jpg" />最小的矩g，再横向比较，取其中能使<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc179d7399bc499d289e3530b24c554a.jpg" />最小的模型的矩<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8bef8cb2ac711ae515b4bb17e2e4d088.jpg" />：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4a5e07d2b3023d54a5c5bf15d9b08ce6.jpg" alt="这里写图片描述" title="" /></p>

        <p>但是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc179d7399bc499d289e3530b24c554a.jpg" />足够小并不能表示模型好，反而可能表示训练的矩<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8bef8cb2ac711ae515b4bb17e2e4d088.jpg" />发生了过拟合，泛化能力很差。而且这种“模型选择+学习训练”的过程，它的VC
            Dimension是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1cb80b8193cb64ac90723e01275d0aae.jpg" />，模型复杂度增加。总的来说，泛化能力差，用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc179d7399bc499d289e3530b24c554a.jpg" />来选择模型是不好的。</p>

        <p>另外一种方法，如果有这样一个独立于训练样本的测试集，将M个模型在测试集上进行测试，看一下<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50ac3d7f2860877b2584f93eedade6c2.jpg" />的大小，则选取<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50ac3d7f2860877b2584f93eedade6c2.jpg" />最小的模型作为最佳模型：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/397635d4ed9fc8b29ede78007e34c9a9.jpg" alt="这里写图片描述" title="" /></p>

        <p>这种测试集验证的方法，根据finite-bin Hoffding不等式，可以得到：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-22">E_{out}(g_{m^*})\leq E_{test}(g_{m^*})+O(\sqrt \frac{log M}{N_{test}})</script>
        </p>

        <p>由上式可以看出，模型个数M越少，测试集数目越大，那么<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50a60eeae9ced436ce27028024094d7e.jpg" />越小，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50ac3d7f2860877b2584f93eedade6c2.jpg" />越接近于<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f68c57dc39693d8d4a3e0269fc6733e7.jpg" />。</p>

        <p>下面比较一下之前讲的两种方法，第一种方法使用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc179d7399bc499d289e3530b24c554a.jpg" />作为判断基准，使用的数据集就是训练集D本身；第二种方法使用<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50ac3d7f2860877b2584f93eedade6c2.jpg" />作为判断基准，使用的是独立于训练集D之外的测试集。前者不仅使用D来训练不同的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27afd07ac4e9ee83c7b6327cea7a45b3.jpg" />，而且又使用D来选择最好的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8bef8cb2ac711ae515b4bb17e2e4d088.jpg" />，那么<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8bef8cb2ac711ae515b4bb17e2e4d088.jpg" />对未知数据并不一定泛化能力好。举个例子，这相当于老师用学生做过的练习题再来对学生进行考试，那么即使学生得到高分，也不能说明他的学习能力强。所以最小化<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc179d7399bc499d289e3530b24c554a.jpg" />的方法并不科学。而后者使用的是独立于D的测试集，相当于新的考试题能更好地反映学生的真实水平，所以最小化<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50ac3d7f2860877b2584f93eedade6c2.jpg" />更加理想。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c8b9cad747e8ba0e7e88aa92cf9c5014.jpg" alt="这里写图片描述" title="" /></p>

        <p>但是，我们拿到的一都是训练集D，测试集是拿不到的。所以，寻找一种折中的办法，我们可以使用已有的训练集D来创造一个验证集validation set，即从D中划出一部分<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4dffa0d5c5dc8624441b6dff1062368.jpg" />作为验证集。D另外的部分作为训练模型使用，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4dffa0d5c5dc8624441b6dff1062368.jpg" />独立开来，用来测试各个模型的好坏，最小化<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d6c9ea13e6a4bf337de9c86f48c67860.jpg" />，从而选择最佳的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8bef8cb2ac711ae515b4bb17e2e4d088.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fa984426c8b608d1e8f42a4b87121896.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="二validation" class="sigil_not_in_toc"><strong>二、Validation</strong></h3>

        <p>从训练集D中抽出一部分K个数据作为验证集<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4dffa0d5c5dc8624441b6dff1062368.jpg" />，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4dffa0d5c5dc8624441b6dff1062368.jpg" />对应的error记为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d6c9ea13e6a4bf337de9c86f48c67860.jpg" />。这样做的一个前提是保证<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4dffa0d5c5dc8624441b6dff1062368.jpg" />独立同分布（iid）于P(x,y)，也就是说<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4dffa0d5c5dc8624441b6dff1062368.jpg" />的选择是从D中平均随机抽样得到的，这样能够把<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d6c9ea13e6a4bf337de9c86f48c67860.jpg" />与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />联系起来。D中去除<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4dffa0d5c5dc8624441b6dff1062368.jpg" />后的数据就是供模型选择的训练数据<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/836d8bb4801edbda224142ed76eb9353.jpg" />，其大小为N-k。从<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/836d8bb4801edbda224142ed76eb9353.jpg" />中选择最好的矩，记为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27afd07ac4e9ee83c7b6327cea7a45b3.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dd2428af083c24feaf9b188e8f3b8722.jpg" alt="这里写图片描述" title="" /></p>

        <p>假如D共有1000个样本，那么可以选择其中900个<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/836d8bb4801edbda224142ed76eb9353.jpg" />，剩下的100个作为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4dffa0d5c5dc8624441b6dff1062368.jpg" />。使用<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/836d8bb4801edbda224142ed76eb9353.jpg" />训练模型，得到最佳的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27afd07ac4e9ee83c7b6327cea7a45b3.jpg" />，使用<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27afd07ac4e9ee83c7b6327cea7a45b3.jpg" />对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4dffa0d5c5dc8624441b6dff1062368.jpg" />进行验证，得到如下Hoffding不等式：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-54">E_{out}(g_m^-)\leq E_{val}(g_m^-)+O(\sqrt \frac{log M}{K})</script>
        </p>

        <p>假设有M种模型hypothesis set，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4dffa0d5c5dc8624441b6dff1062368.jpg" />的数量为K，那么从每种模型m中得到一个在<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4dffa0d5c5dc8624441b6dff1062368.jpg" />上表现最好的矩，再横向比较，从M个矩中选择一个最好的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b945cd736afe4e57c5ea5e9c5f75c72d.jpg" />作为我们最终得到的模型。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3721ffee027bfff987f7ab73df000de9.jpg" alt="这里写图片描述" title="" /></p>

        <p>现在由于数量为N的总样本D的一部分K作为验证集，那么只有N-k个样本可供训练。从<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/836d8bb4801edbda224142ed76eb9353.jpg" />中得到最好的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8bef8cb2ac711ae515b4bb17e2e4d088.jpg" />，而总样本D对应的最好的矩为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8bef8cb2ac711ae515b4bb17e2e4d088.jpg" />。根据之前的leraning
            curve很容易知道，训练样本越多，得到的模型越准确，其hypothesis越接近target function，即D的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />比<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/836d8bb4801edbda224142ed76eb9353.jpg" />的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />要小：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/abb103b6b7503f255621353b8c910b7f.jpg" alt="这里写图片描述" title="" /></p>

        <p>所以，我们通常的做法是通过<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4dffa0d5c5dc8624441b6dff1062368.jpg" />来选择最好的矩<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8bef8cb2ac711ae515b4bb17e2e4d088.jpg" />对应的模型<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/61a69b1d4d42d0222973d05822993981.jpg" />，再对整体样本集D使用该模型进行训练，最终得到最好的矩<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8bef8cb2ac711ae515b4bb17e2e4d088.jpg" />。</p>

        <p>总结一下，使用验证集进行模型选择的整个过程为：先将D分成两个部分，一个是训练样本<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/836d8bb4801edbda224142ed76eb9353.jpg" />，一个是验证集<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4dffa0d5c5dc8624441b6dff1062368.jpg" />。若有M个模型，那么分别对每个模型在<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/836d8bb4801edbda224142ed76eb9353.jpg" />上进行训练，得到矩<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ae28ef5ad3de4893ba1d0225219205fa.jpg" />，再用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4dffa0d5c5dc8624441b6dff1062368.jpg" />对每个<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ae28ef5ad3de4893ba1d0225219205fa.jpg" />进行验证，选择表现最好的矩<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8bef8cb2ac711ae515b4bb17e2e4d088.jpg" />，则该矩对应的模型被选择。最后使用该模型对整个D进行训练，得到最终的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8bef8cb2ac711ae515b4bb17e2e4d088.jpg" />。下图展示了整个模型选择的过程：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e623cf94bee4a1aebd963ea34d0bcdb4.jpg" alt="这里写图片描述" title="" /></p>

        <p>不等式关系满足：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-76">E_{out}(g_{m^*})\leq E_{out}(g_{m^*}^-)\leq E_{val}(g_{m^*}^-)+O(\sqrt \frac{log M}{K})</script>
        </p>

        <p>下面我们举个例子来解释这种模型选择的方法的优越性，假设有两个模型：一个是5阶多项式<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9dd79ad98e518991ef32a8216fee7331.jpg" />，一个是10阶多项式<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1a0a88023edb4223e696e7350aac9390.jpg" />。通过不使用验证集和使用验证集两种方法对模型选择结果进行比较，分析结果如下：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/576c24dd2833e3bda0f95ba879c7b4e1.jpg" alt="这里写图片描述" title="" /></p>

        <p>图中，横坐标表示验证集数量K，纵坐标表示<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />大小。黑色水平线表示没有验证集，完全使用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc179d7399bc499d289e3530b24c554a.jpg" />进行判断基准，那么<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1a0a88023edb4223e696e7350aac9390.jpg" />更好一些，但是这种方法的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />比较大，而且与K无关。黑色虚线表示测试集非常接近实际数据，这是一种理想的情况，其<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />很小，同样也与K无关，实际中很难得到这条虚线。红色曲线表示使用验证集，但是最终选取的矩是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8bef8cb2ac711ae515b4bb17e2e4d088.jpg" />，其趋势是随着K的增加，它对应的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />先减小再增大，当K大于一定值的时候，甚至会超过黑色水平线。蓝色曲线表示也使用验证集，最终选取的矩是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8bef8cb2ac711ae515b4bb17e2e4d088.jpg" />，其趋势是随着K的增加，它对应的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />先缓慢减小再缓慢增大，且一直位于红色曲线和黑色直线之下。从此可见，蓝色曲线对应的方法最好，符合我们之前讨论的使用验证集进行模型选择效果最好。</p>

        <p>这里提一点，当K大于一定的值时，红色曲线会超过黑色直线。这是因为随着K的增大，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4dffa0d5c5dc8624441b6dff1062368.jpg" />增大，但可供模型训练的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/836d8bb4801edbda224142ed76eb9353.jpg" />在减小，那得到的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8bef8cb2ac711ae515b4bb17e2e4d088.jpg" />不具有很好的泛化能力，即对应的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />会增大，甚至当K增大到一定值时，比<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc179d7399bc499d289e3530b24c554a.jpg" />模型更差。</p>

        <p>那么，如何设置验证集K值的大小呢？根据之前的分析：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5674d8735cc5648a87506c31c0310ab0.jpg" alt="这里写图片描述" title="" /></p>

        <p>当K值很大时，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d6c9ea13e6a4bf337de9c86f48c67860.jpg" />，但是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27afd07ac4e9ee83c7b6327cea7a45b3.jpg" />与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27afd07ac4e9ee83c7b6327cea7a45b3.jpg" />相差很大；当K值很小是，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27afd07ac4e9ee83c7b6327cea7a45b3.jpg" />，但是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d6c9ea13e6a4bf337de9c86f48c67860.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />可能相差很大。所以有个折中的办法，通常设置<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/55c8358e23c0cd14dc1ffbe2e57984c0.jpg" />。值得一提的是，划分验证集，通常并不会增加整体时间复杂度，反而会减少，因为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/836d8bb4801edbda224142ed76eb9353.jpg" />减少了。</p>

        <h3 id="三leave-one-out-cross-validation" class="sigil_not_in_toc"><strong>三、Leave-One-Out Cross Validation</strong></h3>

        <p>假如考虑一个极端的例子，k=1，也就是说验证集大小为1，即每次只用一组数据对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27afd07ac4e9ee83c7b6327cea7a45b3.jpg" />进行验证。这样做的优点是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27afd07ac4e9ee83c7b6327cea7a45b3.jpg" />，但是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d6c9ea13e6a4bf337de9c86f48c67860.jpg" />与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />可能相差很大。为了避免<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d6c9ea13e6a4bf337de9c86f48c67860.jpg" />与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />相差很大，每次从D中取一组作为验证集，直到所有样本都作过验证集，共计算N次，最后对验证误差求平均，得到<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/11f821bd2cbbb15f2dd7413f32feb089.jpg" />，这种方法称之为留一法交叉验证，表达式为：</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-108">E_{loocv}(H,A)=\frac1N\sum_{n=1}^Ne_n=\frac1N\sum_{n=1}^Nerr(g_n^-(x_n),y_n)</script>
        </p>

        <p>这样求平均的目的是为了让<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/11f821bd2cbbb15f2dd7413f32feb089.jpg" />尽可能地接近<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />。</p>

        <p>下面用一个例子图解留一法的过程：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3ef418763ccf753f1b2ff2d5c2aff75b.jpg" alt="这里写图片描述" title="" /></p>

        <p>如上图所示，要对二维平面上的三个点做拟合，上面三个图表示的是线性模型，下面三个图表示的是常数模型。对于两种模型，分别使用留一交叉验证法来计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ee79bfba65d4096146688e110dde889e.jpg" />，计算过程都是每次将一个点作为验证集，其他两个点作为训练集，最终将得到的验证误差求平均值，就得到了<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ee79bfba65d4096146688e110dde889e.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ee79bfba65d4096146688e110dde889e.jpg" />，比较两个值的大小，取值小对应的模型即为最佳模型。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1aed4ca83cd44166254a6ad19c52632f.jpg" alt="这里写图片描述" title="" /></p>

        <p>接下来，我们从理论上分析Leave-One-Out方法的可行性，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/11f821bd2cbbb15f2dd7413f32feb089.jpg" />是否能保证<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />的矩足够好？假设有不同的数据集D，它的期望分布记为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3a6e214ff03eeb2a2cf6c1c003647cab.jpg" />，则其<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/11f821bd2cbbb15f2dd7413f32feb089.jpg" />可以通过推导，等于<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />的平均值。由于N-1近似为N，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />的平均值也近似等于<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />的平均值。具体推导过程如下：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d864d37b1a845ad3e602d60db5354ab5.jpg" alt="这里写图片描述" title="" /></p>

        <p>最终我们得到的结论是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/11f821bd2cbbb15f2dd7413f32feb089.jpg" />的期望值和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />的期望值是相近的，这代表得到了比较理想的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />，Leave-One-Out方法是可行的。</p>

        <p>举一个例子，使用两个特征：Average Intensity和Symmetry加上这两个特征的非线性变换（例如高阶项）来进行手写数字识别。平面特征分布如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d84459d5d861bab613a18569165975a5.jpg" alt="这里写图片描述" title="" /></p>

        <p>Error与特征数量的关系如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5179aa9c982753c56c44c27031b9d4b8.jpg" alt="这里写图片描述" title="" /></p>

        <p>从图中我们看出，随着特征数量的增加，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc179d7399bc499d289e3530b24c554a.jpg" />不断减小，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />先减小再增大，虽然<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc179d7399bc499d289e3530b24c554a.jpg" />是不断减小的，但是它与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />的差距越来越大，发生了过拟合，泛化能力太差。而<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6aa905f7cfd450e313c4963c23ff5635.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />的分布基本一致，能较好地反映<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />的变化。所以，我们只要使用Leave-One-Out方法得到使<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6aa905f7cfd450e313c4963c23ff5635.jpg" />最小的模型，就能保证其<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />足够小。下图是分别使用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc179d7399bc499d289e3530b24c554a.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a9dbe0de5c2387be3c8cb25d1e68460.jpg" />进行训练得到的分类曲线：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b837c2555e77f1ad09146ceec9e70abc.jpg" alt="这里写图片描述" title="" /></p>

        <p>很明显可以看出，使用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc179d7399bc499d289e3530b24c554a.jpg" />发生了过拟合，而<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ee79bfba65d4096146688e110dde889e.jpg" />分类效果更好，泛化能力强。</p>

        <h3 id="四v-fold-cross-validation" class="sigil_not_in_toc"><strong>四、V-Fold Cross Validation</strong></h3>

        <p>接下来我们看看Leave-One-Out可能的问题是什么。首先，第一个问题是计算量，假设N=1000，那么就需要计算1000次的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ee79bfba65d4096146688e110dde889e.jpg" />，再计算其平均值。当N很大的时候，计算量是巨大的，很耗费时间。第二个问题是稳定性，例如对于二分类问题，取值只有0和1两种，预测本身存在不稳定的因素，那么对所有的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ee79bfba65d4096146688e110dde889e.jpg" />计算平均值可能会带来很大的数值跳动，稳定性不好。所以，这两个因素决定了Leave-One-Out方法在实际中并不常用。</p>

        <p>针对Leave-One-Out的缺点，我们对其作出了改进。Leave-One-Out是将N个数据分成N分，那么改进措施是将N个数据分成V份（例如V=10），计算过程与Leave-One-Out相似。这样可以减少总的计算量，又能进行交叉验证，得到最好的矩，这种方法称为V-折交叉验证。其实Leave-One-Out就是V-折交叉验证的一个极端例子。</p>

        <p>
            <script type="math/tex; mode=display" id="MathJax-Element-139">E_{cv}(H,A)=\frac1V\sum_{v=1}^VE_{val}^{(V)}(g_V^-)</script>
        </p>

        <p>所以呢，一般的Validation使用V-折交叉验证来选择最佳的模型。值得一提的是Validation的数据来源也是样本集中的，所以并不能保证交叉验证的效果好，它的模型一定好。只有样本数据越多，越广泛，那么Validation的结果越可信，其选择的模型泛化能力越强。</p>

        <h3 id="五总结" class="sigil_not_in_toc"><strong>五、总结</strong></h3>

        <p>本节课主要介绍了Validation验证。先从如何选择一个好的模型开始切入，例如使用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc179d7399bc499d289e3530b24c554a.jpg" />、<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50ac3d7f2860877b2584f93eedade6c2.jpg" />都是不太好的，最终使用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d6c9ea13e6a4bf337de9c86f48c67860.jpg" />来进行模型选择。然后详细介绍了Validation的过程。最后，介绍了Leave-One-Out和V-Fold
            Cross两种验证方法，比较它们各自的优点和缺点，实际情况下，V-Fold Cross更加常用。</p>

        <p><strong><em>注明：</em></strong> <br />
            文章中所有的图片均来自台湾大学林轩田《机器学习基石》课程</p>
    </div>

    <h1>
        16 -- Three Learning Principles

    </h1>
    <div class="markdown_views">
        <p>上节课我们讲了一个机器学习很重要的工具——Validation。我们将整个训练集分成两部分：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c99c53b6be6b232364cf942223905179.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d12639d2f8bae2d05084dc0428946d6e.jpg" />，一部分作为机器学习模型建立的训练数据，另一部分作为验证模型好坏的数据，从而选择到更好的模型，实现更好的泛化能力。这节课，我们主要介绍机器学习中非常实用的三个“锦囊妙计”。</p>

        <h3 id="一occams-razor" class="sigil_not_in_toc"><strong>一、Occam’s Razor</strong></h3>

        <p>奥卡姆剃刀定律（Occam’s Razor），是由14世纪逻辑学家、圣方济各会修士奥卡姆的威廉（William of
            Occam，约1285年至1349年）提出。奥卡姆（Ockham）在英格兰的萨里郡，那是他出生的地方。他在《箴言书注》2卷15题说“切勿浪费较多东西去做用较少的东西同样可以做好的事情。”
            这个原理称为“如无必要，勿增实体”（Entities must not be multiplied unnecessarily），就像剃刀一样，将不必要的部分去除掉。</p>

        <p>Occam’s Razor反映到机器学习领域中，指的是在所有可能选择的模型中，我们应该选择能够很好地解释已知数据并且十分简单的模型。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7e6e3ef349b004a9e32cb115f9003384.jpg" alt="这里写图片描述" title="" /></p>

        <p>上图就是一个模型选择的例子，左边的模型很简单，可能有分错的情况；而右边的模型非常复杂，所有的训练样本都分类正确。但是，我们会选择左边的模型，它更简单，符合人类直觉的解释方式。这样的结果带来两个问题：一个是什么模型称得上是简单的？另一个是为什么简单模型比复杂模型要好？</p>

        <p>简单的模型一方面指的是简单的hypothesis
            h，简单的hypothesis就是指模型使用的特征比较少，例如多项式阶数比较少。简单模型另一方面指的是模型H包含的hypothesis数目有限，不会太多，这也是简单模型包含的内容。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/832e95cff2777e6275548833c014b95d.jpg" alt="这里写图片描述" title="" /></p>

        <p>其实，simple hypothesis h和simple model H是紧密联系的。如果hypothesis的特征个数是l，那么H中包含的hypothesis个数就是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/13477f039e1a528df4da31516dbe8e6d.jpg" />，也就是说，hypothesis特征数目越少，H中hypothesis数目也就越少。</p>

        <p>所以，为了让模型简单化，我们可以一开始就选择简单的model，或者用regularization，让hypothesis中参数个数减少，都能降低模型复杂度。</p>

        <p>那为什么简单的模型更好呢？下面从哲学的角度简单解释一下。机器学习的目的是“找规律”，即分析数据的特征，总结出规律性的东西出来。假设现在有一堆没有规律的杂乱的数据需要分类，要找到一个模型，让它的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5b5444f0784f2feef887a8f45ad5cab9.jpg" />，是很难的，大部分时候都无法正确分类，但是如果是很复杂的模型，也有可能将其分开。反过来说，如果有另一组数据，如果可以比较容易找到一个模型能完美地把数据分开，那表明数据本身应该是有某种规律性。也就是说杂乱的数据应该不可以分开，能够分开的数据应该不是杂乱的。如果使用某种简单的模型就可以将数据分开，那表明数据本身应该符合某种规律性。相反地，如果用很复杂的模型将数据分开，并不能保证数据本身有规律性存在，也有可能是杂乱的数据，因为无论是有规律数据还是杂乱数据，复杂模型都能分开。这就不是机器学习模型解决的内容了。所以，模型选择中，我们应该尽量先选择简单模型，例如最简单的线性模型。</p>

        <h3 id="二sampling-bias" class="sigil_not_in_toc"><strong>二、Sampling Bias</strong></h3>

        <p>首先引入一个有趣的例子：1948年美国总统大选的两位热门候选人是Truman和Dewey。一家报纸通过电话采访，统计人们把选票投给了Truman还是Dewey。经过大量的电话统计显示，投给Dewey的票数要比投个Truman的票数多，所以这家报纸就在选举结果还没公布之前，信心满满地发表了“Dewey
            Defeats Truman”的报纸头版，认为Dewey肯定赢了。但是大选结果公布后，让这家报纸大跌眼镜，最终Truman赢的了大选的胜利。</p>

        <p>为什么会出现跟电话统计完全相反的结果呢？是因为电话统计数据出错还是投票运气不好？都不是。其实是因为当时电话比较贵，有电话的家庭比较少，而正好是有电话的美国人支持Dewey的比较多，而没有电话的支持Truman比较多。也就是说样本选择偏向于有钱人那边，可能不具有广泛的代表性，才造成Dewey支持率更多的假象。</p>

        <p>这个例子表明，抽样的样本会影响到结果，用一句话表示“If the data is sampled in a biased way, learning will produce a similarly biased
            outcome.”意思是，如果抽样有偏差的话，那么学习的结果也产生了偏差，这种情形称之为抽样偏差Sampling Bias。</p>

        <p>从技术上来说，就是训练数据和验证数据要服从同一个分布，最好都是独立同分布的，这样训练得到的模型才能更好地具有代表性。</p>

        <h3 id="三data-snooping" class="sigil_not_in_toc"><strong>三、Data Snooping</strong></h3>

        <p>之前的课程，我们介绍过在模型选择时应该尽量避免偷窥数据，因为这样会使我们人为地倾向于某种模型，而不是根据数据进行随机选择。所以，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/00360aa7696f3b53fd233976aec97104.jpg" />应该自由选取，最好不要偷窥到原始数据，这会影响我们的判断。</p>

        <p>事实上，数据偷窥发生的情况有很多，不仅仅指我们看到了原始数据。什么意思呢？其实，当你在使用这些数据的任何过程，都是间接地偷看到了数据本身，然后你会进行一些模型的选择或者决策，这就增加了许多的model
            complexity，也就是引入了污染。</p>

        <p>下面举个例子来说明。假如我们有8年的货比交易数据，我们希望从这些数据中找出规律，来预测货比的走势。如果选择前6年数据作为训练数据，后2年数据作为测试数据的话，来训练模型。现在我们有前20天的数据，根据之前训练的模型，来预测第21天的货比交易走势。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/830f30d0ce87b547d7d093f4a30b38f5.jpg" alt="这里写图片描述" title="" /></p>

        <p>现在有两种训练模型的方法，如图所示，一种是使用前6年数据进行模型训练，后2年数据作为测试，图中蓝色曲线表示后2年的预测收益；另一种是直接使用8年数据进行模型训练，图中红色曲线表示后2年的预测收益情况。图中，很明显，使用8年数据进行训练的模型对后2年的预测的收益更大，似乎效果更好。但是这是一种自欺欺人的做法，因为训练的时候已经拿到了后2年的数据，用这样的模型再来预测后2年的走势是不科学的。这种做法也属于间接偷窥数据的行为。直接偷窥和间接偷窥数据的行为都是不科学的做法，并不能表示训练的模型有多好。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40dd421cbd7fea87b3ee7caa35f3b2aa.jpg" alt="这里写图片描述" title="" /></p>

        <p>还有一个偷窥数据的例子，比如对于某个基准数据集D，某人对它建立了一个模型H1，并发表了论文。第二个人看到这篇论文后，又会对D，建立一个新的好的模型H2。这样，不断地有人看过前人的论文后，建立新的模型。其实，后面人选择模型时，已经被前人影响了，这也是偷窥数据的一种情况。也许你能对D训练很好的模型，但是可能你仅仅只根据前人的模型，成功避开了一些错误，甚至可能发生了overfitting或者bad
            generalization。所以，机器学习领域有这样一句有意思的话“If you torture the data long enough, it will
            confess.”所以，我们不能太“折磨”我们的数据了，否则它只能“妥协”了~哈哈。</p>

        <p>在机器学习过程中，避免“偷窥数据”非常重要，但实际上，完全避免也很困难。实际操作中，有一些方法可以帮助我们尽量避免偷窥数据。第一个方法是“看不见”数据。就是说当我们在选择模型的时候，尽量用我们的经验和知识来做判断选择，而不是通过数据来选择。先选模型，再看数据。第二个方法是保持怀疑。就是说时刻保持对别人的论文或者研究成果保持警惕与怀疑，要通过自己的研究与测试来进行模型选择，这样才能得到比较正确的结论。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8b13507f656fafbc4591bdd325891957.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="四power-of-three" class="sigil_not_in_toc"><strong>四、Power of Three</strong></h3>

        <p>本小节，我们对16节课做个简单的总结，用“三的威力”进行概括。因为课程中我们介绍的很多东西都与三有关。</p>

        <p>首先，我们介绍了跟机器学习相关的三个领域：</p>

        <ul>
            <li>
                <p>Data Mining</p>
            </li>
            <li>
                <p>Artificial Intelligence</p>
            </li>
            <li>
                <p>Statistics</p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/58ccddeafd8ccd74cd08a440d90e9d1b.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们还介绍了三个理论保证：</p>

        <ul>
            <li>
                <p>Hoeffding</p>
            </li>
            <li>
                <p>Multi-Bin Hoeffding</p>
            </li>
            <li>
                <p>VC</p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0e64742a4f568c4d83413508167d03dc.jpg" alt="这里写图片描述" title="" /></p>

        <p>然后，我们又介绍了三种线性模型：</p>

        <ul>
            <li>
                <p>PLA/pocket</p>
            </li>
            <li>
                <p>linear regression</p>
            </li>
            <li>
                <p>logistic regression</p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/68ca1eedb5415a7373496f4a046f8ddb.jpg" alt="这里写图片描述" title="" /></p>

        <p>同时，我们介绍了三种重要的工具：</p>

        <ul>
            <li>
                <p>Feature Transform</p>
            </li>
            <li>
                <p>Regularization</p>
            </li>
            <li>
                <p>Validation</p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f66ed2702ccb34b2bb8e772f2e87d0da.jpg" alt="这里写图片描述" title="" /></p>

        <p>还有我们本节课介绍的三个锦囊妙计：</p>

        <ul>
            <li>
                <p>Occam’s Razer</p>
            </li>
            <li>
                <p>Sampling Bias</p>
            </li>
            <li>
                <p>Data Snooping</p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4105fd39b25018169321ba670c3b13a9.jpg" alt="这里写图片描述" title="" /></p>

        <p>最后，我们未来机器学习的方向也分为三种：</p>

        <ul>
            <li>
                <p>More Transform</p>
            </li>
            <li>
                <p>More Regularization</p>
            </li>
            <li>
                <p>Less Label</p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7d9554b224ca4d2485e3ff0feb066e66.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="五总结" class="sigil_not_in_toc"><strong>五、总结</strong></h3>

        <p>本节课主要介绍了机器学习三个重要的锦囊妙计：Occam’s Razor, Sampling Bias, Data
            Snooping。并对《机器学习基石》课程中介绍的所有知识和方法进行“三的威力”这种形式的概括与总结，“三的威力”也就构成了坚固的机器学习基石。</p>

        <p>整个机器学习基石的课程笔记总结完毕！后续将会推出机器学习技法的学习笔记，谢谢！</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习基石》课程</p>
    </div>

    <h1>机器学习技法</h1>

    <h1 class="title-article">1 -- Linear Support Vector Machine</h1>
    <div class="markdown_views">
        <blockquote>
            <p>红色石头的个人网站：<a href="http://redstonewill.com/" rel="nofollow">redstonewill.com</a></p>
        </blockquote>

        <p>关于台湾大学林轩田老师的《机器学习基石》课程，我们已经总结了16节课的笔记。这里附上基石第一节课的博客地址：</p>

        <p><a href="http://blog.csdn.net/red_stone1/article/details/72899485" rel="nofollow">台湾大学林轩田机器学习基石课程学习笔记1 – The
                Learning Problem</a></p>

        <p>本系列同样分成16节课，将会介绍《机器学习基石》的进阶版《机器学习技法》，更深入地探讨机器学习一些高级算法和技巧。</p>

        <h3 id="large-margin-separating-hyperplane" class="sigil_not_in_toc"><strong>Large-Margin Separating Hyperplane</strong></h3>

        <p>回顾一下我们之前介绍了linear classification，对于线性可分的情况，我们可以使用PLA/pocket算法在平面或者超平面上把正负类分开。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/36ee67ed919b5006df931c449a3ed907.jpg" alt="这里写图片描述" title="" /></p>

        <p>例如对平面2D这种情况，我们可以找到一条直线，能将正类和负类完全分开。但是，这样的直线通常不止一条，如下图所示。那么，下图中的三条分类线都能将数据分开，但是哪条线更好呢？</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e87b4f4010932f8ee9459df5d4e6d40.jpg" alt="这里写图片描述" title="" /></p>

        <p>这三条直线都是由PLA/pocket算法不断修正错误点而最终产生的，整个确定直线形状的过程是随机的。单从分类效果上看，这三条直线都满足要求，而且都满足VC bound要求，模型复杂度<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d7dadd85f490ced3e3f3d2a8f070087a.jpg" />是一样的，即具有一定的泛化能力。但是，如果要选择的话，凭第一感觉，我们还是会选择第三条直线，感觉它的分类效果更好一些。那这又是为什么呢？</p>

        <p>先给个简单解释，一般情况下，训练样本外的测量数据应该分布在训练样本附近，但与训练样本的位置有一些偏差。若要保证对未知的测量数据也能进行正确分类，最好让分类直线距离正类负类的点都有一定的距离。这样能让每个样本点附近的圆形区域是“安全”的。圆形区域越大，表示分类直线对测量数据误差的容忍性越高，越“安全”。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7f3f247dbdd7bb038deb82cc118ab484.jpg" alt="这里写图片描述" title="" /></p>

        <p>如上图所示，左边的点距离分类直线的最小距离很小，它的圆形区域很小。那么，这种情况下，分类线对测量数据误差的容忍性就很差，测量数据与样本数据稍有偏差，很有可能就被误分。而右边的点距离分类直线的最小距离更大一些，其圆形区域也比较大。这种情况下，分类线对测量数据误差的容忍性就相对来说大很多，不容易误分。也就是说，左边分类线和右边分类线的最大区别是对这类测量误差的容忍度不同。</p>

        <p>那么，如果每一笔训练资料距离分类线越远的话，就表示分类型可以忍受更多的测量误差（noise）。我们之前在《机器学习基石》中介绍过，noise是造成overfitting的主要原因，而测量误差也是一种noise。所以，如果分类线对测量误差的容忍性越好的话，表示这是一条不错的分类线。那么，我们的目标就是找到这样一条最“健壮”的线，即距离数据点越远越好。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/81f068986d60a0891c60a5684bc0e441.jpg" alt="这里写图片描述" title="" /></p>

        <p>上面我们用圆形区域表示分类线能够容忍多少误差，也就相当于计算点到直线的距离。距离越大，表示直线越“胖”，越能容忍误差；距离越小，表示直线越“瘦”，越不能容忍误差。越胖越好（像杨贵妃那样的哦~）。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/756a78600c582886c2696fe1d61e2e21.jpg" alt="这里写图片描述" title="" /></p>

        <p>如何定义分类线有多胖，就是看距离分类线最近的点与分类线的距离，我们把它用margin表示。分类线由权重w决定，目的就是找到使margin最大时对应的w值。整体来说，我们的目标就是找到这样的分类线并满足下列条件：</p>

        <ul>
            <li>
                <p><strong>分类正确，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8bcacd1d466fb3be231d49e874891f02.jpg" /></strong></p>
            </li>
            <li>
                <p><strong>margin最大化</strong></p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/97cf99f084f31ae6876488b0aa97b18a.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="standard-large-margin-problem" class="sigil_not_in_toc"><strong>Standard Large-Margin Problem</strong></h3>

        <p>要让margin最大，即让离分类线最近的点到分类线距离最大，我们先来看一下如何计算点到分类线的距离。</p>

        <p>首先，我们将权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ecd821b27e091c590a46f60976ecb92e.jpg" />中的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ba3c75638c442d45dd1986e37b37fd7e.jpg" />拿出来，用b表示。同时省去<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ddfc662b32da3468fabb177c80db8ea6.jpg" />项。这样，hypothesis就变成了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/757f9582d67ce5194f85e5d47564767b.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f6e8f20e9b21ce90804daa75eb9fff0d.jpg" alt="这里写图片描述" title="" /></p>

        <p>下面，利用图解的方式，详细推导如何计算点到分类平面的距离：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a7c02de7f2855e6e5fc3bcebc340dc32.jpg" alt="这里写图片描述" title="" /></p>

        <p>如上图所示，平面上有两个点：x’和x”。因为这两个点都在分类平面上，所以它们都满足：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d4dba4f3e5f82c0d9f88cf29abf8e046.jpg" /></p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50560407af48d279c351803f52ffdf17.jpg" /></p>

        <p>同时可以得到：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52fc30fa9b30c208e811c22e6fbf5476.jpg" />，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4010057f1d98618512057e7ae7f875fc.jpg" />，则有：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/501dfaadd1ff06fbc588d54b52bfe378.jpg" /></p>

        <p>(x”-x’)是平面上的任一向量，(x”-x’)与w内积为0，表示(x”-x’)垂直于w，那么w就是平面的法向量。</p>

        <p>现在，若要计算平面外一点x到该平面的距离，做法是只要将向量(x-x’)投影到垂直于该平面的方向（即w方向）上就可以了。那么，令(x”-x’)与w的夹角为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/51b8359f970d2bfe2ad4cdc3ac1aed3c.jpg" />，距离就可以表示为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/38f9328e1e02a0acfe2db4fb3294d65c.jpg" /></p>

        <p>代入<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52fc30fa9b30c208e811c22e6fbf5476.jpg" />，可得：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/45d70e1c9c69cde10e49d5668d9284eb.jpg" /></p>

        <p>点到分类面（Separating Hyperplane）的距离已经算出来了。基于这个分类面，所有的点均满足：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/309436010528a3f04e65b8de4ad3998a.jpg" />，表示所有点都分类正确，则distance公式就可以变换成：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/873de15b0e040c5826564a1f81c6d2c3.jpg" /></p>

        <p>那么，我们的目标形式就转换为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d5acd213fda5fab334d9375550179136.jpg" alt="这里写图片描述" title="" /></p>

        <p>对上面的式子还不容易求解，我们继续对它进行简化。我们知道分类面<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/19b91ac27388102ab4db13efc06dff1c.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6196770af06ce0b98f705ecadc9920af.jpg" />其实是一样的。也就是说，对w和b进行同样的缩放还会得到同一分类面。所以，为了简化计算，我们令距离分类满最近的点满足<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/273899ae7b2132d1efb36818f09ae9d5.jpg" />。那我们所要求的margin就变成了:</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9c1892438e837f773e5d70e76f350984.jpg" /></p>

        <p>这样，目标形式就简化为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/eb9140488401f5c58357cebc549c06cb.jpg" alt="这里写图片描述" title="" /></p>

        <p>这里可以省略条件：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/309436010528a3f04e65b8de4ad3998a.jpg" />，因为满足条件<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/273899ae7b2132d1efb36818f09ae9d5.jpg" />必然满足大于零的条件。我们的目标就是根据这个条件，计算<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3bc453c7df64b7414112b903975936ce.jpg" />的最大值。</p>

        <p>刚刚我们讲的距离分类满最近的点满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/273899ae7b2132d1efb36818f09ae9d5.jpg" />，也就是说对所有的点满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9cae1107e06e79ea45c46840638c56f7.jpg" />。另外，因为最小化问题我们最熟悉也最好解，所以可以把目标<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3bc453c7df64b7414112b903975936ce.jpg" />最大化转化为计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fe7bbafafbb55291e5ff44c29986ee21.jpg" />的最小化问题。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4e24769dbecf76910c33b02407875d7a.jpg" alt="这里写图片描述" title="" /></p>

        <p>如上图所示，最终的条件就是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9cae1107e06e79ea45c46840638c56f7.jpg" />，而我们的目标就是最小化<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fe7bbafafbb55291e5ff44c29986ee21.jpg" />值。</p>

        <h3 id="support-vector-machine" class="sigil_not_in_toc"><strong>Support Vector Machine</strong></h3>

        <p>现在，条件和目标变成：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/789687d676ee27ba75162f6004735c9e.jpg" alt="这里写图片描述" title="" /></p>

        <p>现在，举个例子，假如平面上有四个点，两个正类，两个负类：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fefa3a35bb107bc9225edf90334d4035.jpg" alt="这里写图片描述" title="" /></p>

        <p>不同点的坐标加上条件<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9cae1107e06e79ea45c46840638c56f7.jpg" />，可以得到：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5ab8fd522520256ed4b0c733bc1f8b5e.jpg" alt="这里写图片描述" title="" /></p>

        <p>最终，我们得到的条件是：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fa3478d6e7f7bc744f3cac90a9170795.jpg" /></p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a474b81288355808bdfb7c5f9cc03770.jpg" /></p>

        <p>而我们的目标是：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/56d75dfecd49f6af25c0dfdad931887b.jpg" /></p>

        <p>目标最小值为1，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3cd77a5d26a3d307aa1d57b0df6a5e16.jpg" />，那么这个例子就得到了最佳分类面的解，如图所示，且<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8aa8c56bfb9129b2f5b68a02c3cef325.jpg" />。分类面的表达式为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f6a7dd94fa7611956751e0382879a043.jpg" /></p>

        <p>最终我们得到的矩的表达式为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5d26975224056e1a526d82122204317d.jpg" /></p>

        <p>Support Vector
            Machine(SVM)这个名字从何而来？为什么把这种分类面解法称为支持向量机呢？这是因为分类面仅仅由分类面的两边距离它最近的几个点决定的，其它点对分类面没有影响。决定分类面的几个点称之为支持向量（Support
            Vector），好比这些点“支撑”着分类面。而利用Support Vector得到最佳分类面的方法，称之为支持向量机（Support Vector Machine）。</p>

        <p>下面介绍SVM的一般求解方法。先写下我们的条件和目标：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ea638acb7c3e795803cb44e9be1df579.jpg" alt="这里写图片描述" title="" /></p>

        <p>这是一个典型的二次规划问题，即Quadratic
            Programming（QP）。因为SVM的目标是关于w的二次函数，条件是关于w和b的一次函数，所以，它的求解过程还是比较容易的，可以使用一些软件（例如Matlab）自带的二次规划的库函数来求解。下图给出SVM与标准二次规划问题的参数对应关系：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/590aee7b7c40d13e2c5b3627202ca163.jpg" alt="这里写图片描述" title="" /></p>

        <p>那么，线性SVM算法可以总结为三步：</p>

        <ul>
            <li>
                <p><strong>计算对应的二次规划参数Q，p，A，c</strong></p>
            </li>
            <li>
                <p><strong>根据二次规划库函数，计算b，w</strong></p>
            </li>
            <li>
                <p><strong>将b和w代入<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f7480a086f97ad3ec2aa19c5c1102c50.jpg" />，得到最佳分类面</strong></p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/80758fbb27b9cc2cf03b287f228f7854.jpg" alt="这里写图片描述" title="" /></p>

        <p>这种方法称为Linear Hard-Margin SVM Algorithm。如果是非线性的，例如包含x的高阶项，那么可以使用我们之前在《机器学习基石》课程中介绍的特征转换的方法，先作<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d3c7fd7b2a38ace00ee14265a1527997.jpg" />的特征变换，从非线性的x域映射到线性的z域空间，再利用Linear
            Hard-Margin SVM Algorithm求解即可。</p>

        <h3 id="reasons-behind-large-margin-hyperplane" class="sigil_not_in_toc"><strong>Reasons behind Large-Margin
                Hyperplane</strong></h3>

        <p>从视觉和直觉的角度，我们认为Large-Margin
            Hyperplane的分类效果更好。SVM的这种思想其实与我们之前介绍的机器学习非常重要的正则化regularization思想很类似。regularization的目标是将<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />最小化，条件是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b6d200f980aaa3ee660d804911e853cc.jpg" />；SVM的目标是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/67f16bf9eedca78b8c35cf58f249f43e.jpg" />最小化，条件是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2a35ee6d5e962de03eca129426833bec.jpg" />，即保证了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8979e87b0fb1d13fdfaad13dcfe4638b.jpg" />。有趣的是，regularization与SVM的目标和限制条件分别对调了。其实，考虑的内容是类似的，效果也是相近的。SVM也可以说是一种weight-decay
            regularization，限制条件是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8979e87b0fb1d13fdfaad13dcfe4638b.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b049167335e751ffdff8e9d6f92422f1.jpg" alt="这里写图片描述" title="" /></p>

        <p>从另一方面来看，Large-Margin会限制Dichotomies的个数。这从视觉上也很好理解，假如一条分类面越“胖”，即对应Large-Margin，那么它可能shtter的点的个数就可能越少：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/05a58783f6d6d6659782736e6dde09b6.jpg" alt="这里写图片描述" title="" /></p>

        <p>之前的《机器学习基石》课程中介绍过，Dichotomies与VC Dimension是紧密联系的。也就是说如果Dichotomies越少，那么复杂度就越低，即有效的VC Dimension就越小，得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/576638187193b3b48c902b404e059c9d.jpg" />，泛化能力强。</p>

        <p>下面我们从概念的角度推导一下为什么dichotomies越少，VC Dimension就越少。首先我们考虑一下Large-Margin演算法的VC Dimension，记为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4021ef185aeb8db23f74722c66146670.jpg" />。<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4021ef185aeb8db23f74722c66146670.jpg" />与数据有关，而我们之前介绍的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/63926b21692667f723efd5f25797c88c.jpg" />与数据无关。</p>

        <p>假如平面上有3个点分布在单位圆上，如果Margin为0，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/034d56aa2a75a8950d53689324807ee0.jpg" />，这条细细的直线可以很容易将圆上任意三点分开（shatter），就能得到它的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/469b1ecc529270c36127c531e37a22cd.jpg" />。如果<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d1dc93bafa5b5049f85ea6f2eef73148.jpg" />，这条粗粗的线无论如何都不能将圆上的任一三点全完分开（no
            shatter），因为圆上必然至少存在两个点的距离小于<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6e2311b6f3563ded95d2ca9d04ebcafd.jpg" />，那么其对应d的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/72ec03d3c2218812a91b20201f968b28.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/29f63a519a15372fa6d5cf7fd2276497.jpg" alt="这里写图片描述" title="" /></p>

        <p>那么，一般地，在d维空间，当数据点分布在半径为R的超球体内时，得到的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4021ef185aeb8db23f74722c66146670.jpg" />满足下列不等式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ccaccb87f2f75169f850df9047c18028.jpg" alt="这里写图片描述" title="" /></p>

        <p>之前介绍的Perceptrons的VC Dimension为d+1，这里得到的结果是Large-Margin演算法的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/640aa38ed9ea2dfa2861b2c082a9a4d3.jpg" />。所以，由于Large-Margin，得到的dichotomies个数减少，从而VC
            Dimension也减少了。VC Dimension减少降低了模型复杂度，提高了泛化能力。</p>

        <h3 id="总结" class="sigil_not_in_toc"><strong>总结</strong></h3>

        <p>本节课主要介绍了线性支持向量机（Linear Support Vector
            Machine）。我们先从视觉角度出发，希望得到一个比较“胖”的分类面，即满足所有的点距离分类面都尽可能远。然后，我们通过一步步推导和简化，最终把这个问题转换为标准的二次规划（QP）问题。二次规划问题可以使用Matlab等软件来进行求解，得到我们要求的w和b，确定分类面。这种方法背后的原理其实就是减少了dichotomies的种类，减少了有效的VC
            Dimension数量，从而让机器学习的模型具有更好的泛化能力。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习技法》课程</p>

        <p><strong>更多AI资源请关注公众号：红色石头的机器学习之路（ID：redstonewill）</strong> <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3bd4e9122327d60ac29c3a232d4934eb.jpg" alt="这里写图片描述" title="" /></p>
    </div>

    <h1 class="title-article">2 -- Dual Support Vector Machine</h1>
    <div class="markdown_views">
        <blockquote>
            <p>红色石头的个人网站：<a href="http://redstonewill.com/" rel="nofollow">redstonewill.com</a></p>
        </blockquote>

        <p>上节课我们主要介绍了线性支持向量机（Linear Support Vector Machine）。Linear
            SVM的目标是找出最“胖”的分割线进行正负类的分离，方法是使用二次规划来求出分类线。本节课将从另一个方面入手，研究对偶支持向量机（Dual Support Vector
            Machine），尝试从新的角度计算得出分类线，推广SVM的应用范围。</p>

        <h3 id="motivation-of-dual-svm" class="sigil_not_in_toc"><strong>Motivation of Dual SVM</strong></h3>

        <p>首先，我们回顾一下，对于非线性SVM，我们通常可以使用非线性变换将变量从x域转换到z域中。然后，在z域中，根据上一节课的内容，使用线性SVM解决问题即可。上一节课我们说过，使用SVM得到large-margin，减少了有效的VC
            Dimension，限制了模型复杂度；另一方面，使用特征转换，目的是让模型更复杂，减小<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />。所以说，非线性SVM是把这两者目的结合起来，平衡这两者的关系。那么，特征转换下，求解QP问题在z域中的维度设为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/500653986413116be2a517679c22bfd2.jpg" />，如果模型越复杂，则<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/500653986413116be2a517679c22bfd2.jpg" />越大，相应求解这个QP问题也变得很困难。当<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />无限大的时候，问题将会变得难以求解，那么有没有什么办法可以解决这个问题呢？一种方法就是使SVM的求解过程不依赖<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />，这就是我们本节课所要讨论的主要内容。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1de4d5d2e0727f3a50445556d6ca2507.jpg" alt="这里写图片描述" title="" /></p>

        <p>比较一下，我们上一节课所讲的Original SVM二次规划问题的变量个数是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/500653986413116be2a517679c22bfd2.jpg" />，有N个限制条件；而本节课，我们把问题转化为对偶问题（’Equivalent’
            SVM），同样是二次规划，只不过变量个数变成N个，有N+1个限制条件。这种对偶SVM的好处就是问题只跟N有关，与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />无关，这样就不存在上文提到的当<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />无限大时难以求解的情况。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d4871f5d57735df2c2b1473d89b6ac09.jpg" alt="这里写图片描述" title="" /></p>

        <p>如何把问题转化为对偶问题（’Equivalent’ SVM），其中的数学推导非常复杂，本文不做详细数学论证，但是会从概念和原理上进行简单的推导。</p>

        <p>还记得我们在《机器学习基石》课程中介绍的Regularization中，在最小化<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />的过程中，也添加了限制条件：<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b6d200f980aaa3ee660d804911e853cc.jpg" />。我们的求解方法是引入拉格朗日因子<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" />，将有条件的最小化问题转换为无条件的最小化问题：<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cb76a6ddbcdf1a80fb2c6f10493c9aca.jpg" />，最终得到的w的最优化解为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a9861b11eab2dcc8a5fc6a5b75c4dad1.jpg" /></p>

        <p>所以，在regularization问题中，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" />是已知常量，求解过程变得容易。那么，对于dual
            SVM问题，同样可以引入<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" />，将条件问题转换为非条件问题，只不过<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" />是未知参数，且个数是N，需要对其进行求解。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6d2f47282052c59f7060210764ab7e4b.jpg" alt="这里写图片描述" title="" /></p>

        <p>如何将条件问题转换为非条件问题？上一节课我们介绍的SVM中，目标是：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/55bc745bc4b82cd76bc564bef2fed36f.jpg" />，条件是：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9918e5500a5fc07d013a823f98c8511c.jpg" />。首先，我们令拉格朗日因子为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />（区别于regularization），构造一个函数：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d4d4ec18fd6e4ad4578c6cc41f84d1b8.jpg" /></p>

        <p>这个函数右边第一项是SVM的目标，第二项是SVM的条件和拉格朗日因子<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />的乘积。我们把这个函数称为拉格朗日函数，其中包含三个参数：b，w，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14ac8209334051d986a9e3c89c980a00.jpg" alt="这里写图片描述" title="" /></p>

        <p>下面，我们利用拉格朗日函数，把SVM构造成一个非条件问题：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d7b7419f72b7b55c5a0eedecf012140f.jpg" alt="这里写图片描述" title="" /></p>

        <p>该最小化问题中包含了最大化问题，怎么解释呢？首先我们规定拉格朗日因子<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/db6890730ce9a7d6545d124446e7da9e.jpg" />，根据SVM的限定条件可得：<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fe7ea758f408d074ca0ab7454393bfcf.jpg" />，如果没有达到最优解，即有不满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fe7ea758f408d074ca0ab7454393bfcf.jpg" />的情况，因为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/db6890730ce9a7d6545d124446e7da9e.jpg" />，那么必然有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e7fe5217a259ec8a98f670f6c90b14c3.jpg" />。对于这种大于零的情况，其最大值是无解的。如果对于所有的点，均满足<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fe7ea758f408d074ca0ab7454393bfcf.jpg" />，那么必然有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ce162b749eb9a94653d0639fd70125e5.jpg" />，则当<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9a882899a91f289a9441a621381dc7dc.jpg" />时，其有最大值，最大值就是我们SVM的目标：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fe7bbafafbb55291e5ff44c29986ee21.jpg" />。因此，这种转化为非条件的SVM构造函数的形式是可行的。</p>

        <h3 id="lagrange-dual-svm" class="sigil_not_in_toc"><strong>Lagrange Dual SVM</strong></h3>

        <p>现在，我们已经将SVM问题转化为与拉格朗日因子<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />有关的最大最小值形式。已知<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/db6890730ce9a7d6545d124446e7da9e.jpg" />，那么对于任何固定的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8029168dab11a1038d7a3788d9df743.jpg" />，且<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3a9cac3d490765bedd2ca462e6cd52f5.jpg" />，一定有如下不等式成立：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/16e7a81a6274531b8573a7e15f64ec3f.jpg" alt="这里写图片描述" title="" /></p>

        <p>对上述不等式右边取最大值，不等式同样成立：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/963b0fba8275b236ee890c88610c1942.jpg" alt="这里写图片描述" title="" /></p>

        <p>上述不等式表明，我们对SVM的min和max做了对调，满足这样的关系，这叫做Lagrange dual problem。不等式右边是SVM问题的下界，我们接下来的目的就是求出这个下界。</p>

        <p>已知<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/32f64b55ca4b4acc4f1bd066ac0b4040.jpg" />是一种弱对偶关系，在二次规划QP问题中，如果满足以下三个条件：</p>

        <ul>
            <li>
                <p><strong>函数是凸的（convex primal）</strong></p>
            </li>
            <li>
                <p><strong>函数有解（feasible primal）</strong></p>
            </li>
            <li>
                <p><strong>条件是线性的（linear constraints）</strong></p>
            </li>
        </ul>

        <p>那么，上述不等式关系就变成强对偶关系，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/32f64b55ca4b4acc4f1bd066ac0b4040.jpg" />变成=，即一定存在满足条件的解<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5833c1253e9b8e7e8feb90a716e70c2f.jpg" />，使等式左边和右边都成立，SVM的解就转化为右边的形式。</p>

        <p>经过推导，SVM对偶问题的解已经转化为无条件形式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6d9afb3fae232cc023e110d2cea1d38c.jpg" alt="这里写图片描述" title="" /></p>

        <p>其中，上式括号里面的是对拉格朗日函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b0340fd145f2058f1ee1a09d92497ba9.jpg" />计算最小值。那么根据梯度下降算法思想：最小值位置满足梯度为零。首先，令<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b0340fd145f2058f1ee1a09d92497ba9.jpg" />对参数b的梯度为零：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/792768feef52385f2efd53979913ea0a.jpg" /></p>

        <p>也就是说，最优解一定满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9c044a4161aafa0fe2d6ec7b962d666d.jpg" />。那么，我们把这个条件代入计算max条件中（与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/db6890730ce9a7d6545d124446e7da9e.jpg" />同为条件），并进行化简：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9a4a4f3435de037b3b29d88372cb1b3e.jpg" alt="这里写图片描述" title="" /></p>

        <p>这样，SVM表达式消去了b，问题化简了一些。然后，再根据最小值思想，令<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b0340fd145f2058f1ee1a09d92497ba9.jpg" />对参数w的梯度为零：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3ac526e188de7dcefb4c6d80020a1a00.jpg" /></p>

        <p>即得到：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/69bdfefe744163ecac980fd18bac2712.jpg" /></p>

        <p>也就是说，最优解一定满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/69bdfefe744163ecac980fd18bac2712.jpg" />。那么，同样我们把这个条件代入并进行化简：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c63dfb9c0510fce4842c0b20c0296210.jpg" alt="这里写图片描述" title="" /></p>

        <p>这样，SVM表达式消去了w，问题更加简化了。这时候的条件有3个：</p>

        <ul>
            <li>
                <p>all <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/db6890730ce9a7d6545d124446e7da9e.jpg" /></p>
            </li>
            <li>
                <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9c044a4161aafa0fe2d6ec7b962d666d.jpg" /></p>
            </li>
            <li>
                <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/69bdfefe744163ecac980fd18bac2712.jpg" /></p>
            </li>
        </ul>

        <p>SVM简化为只有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />的最佳化问题，即计算满足上述三个条件下，函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/11165ada31a78fadd43a2f7abf2c02f4.jpg" />最小值时对应的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />是多少。</p>

        <p>总结一下，SVM最佳化形式转化为只与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />有关：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a5bc66de0a6f6105434a0124eb0739cc.jpg" alt="这里写图片描述" title="" /></p>

        <p>其中，满足最佳化的条件称之为Karush-Kuhn-Tucker(KKT)：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/315386eb8d4d1c52b020d8456e910819.jpg" alt="这里写图片描述" title="" /></p>

        <p>在下一部分中，我们将利用KKT条件来计算最优化问题中的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/82005cc2e0087e2a52c7e43df4a19a00.jpg" />，进而得到b和w。</p>

        <h3 id="solving-dual-svm" class="sigil_not_in_toc"><strong>Solving Dual SVM</strong></h3>

        <p>上面我们已经得到了dual SVM的简化版了，接下来，我们继续对它进行一些优化。首先，将max问题转化为min问题，再做一些条件整理和推导，得到：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6a301804378e31fb171cebe230f64857.jpg" alt="这里写图片描述" title="" /></p>

        <p>显然，这是一个convex的QP问题，且有N个变量<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />，限制条件有N+1个。则根据上一节课讲的QP解法，找到Q，p，A，c对应的值，用软件工具包进行求解即可。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f8fab6ad372676d546b99fb0095e0f23.jpg" alt="这里写图片描述" title="" /></p>

        <p>求解过程很清晰，但是值得注意的是，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0ffcb522e53e75f523d75f82d7e9c935.jpg" />，大部分值是非零的，称为dense。当N很大的时候，例如N=30000，那么对应的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1fe7a902369b857be0aefda4594ddedc.jpg" />的计算量将会很大，存储空间也很大。所以一般情况下，对dual SVM问题的矩阵<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1fe7a902369b857be0aefda4594ddedc.jpg" />，需要使用一些特殊的方法，这部分内容就不再赘述了。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5c266c1fb3bef9ec893b136721a16d4.jpg" alt="这里写图片描述" title="" /></p>

        <p>得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />之后，再根据之前的KKT条件，就可以计算出w和b了。首先利用条件<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a444bd494aa5bbd18fb590a1173feaa6.jpg" />得到w，然后利用条件<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/143c7a016f60f17ee3ffa7de1c336026.jpg" />，取任一<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50d9c11c51222fd482856e48eec5a134.jpg" />即<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />&gt;0的点，得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/64fccb927aebbcac5e8b1962f58ec34f.jpg" />，进而求得<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8d4251be40eabb2af74bafe5492c6d15.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d9e6b27ecbfa0f3d5444cfcc8770af09.jpg" alt="这里写图片描述" title="" /></p>

        <p>值得注意的是，计算b值，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />&gt;0时，有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/668d079f15a25b2346fa69e0ee7d687a.jpg" />成立。<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/668d079f15a25b2346fa69e0ee7d687a.jpg" />正好表示的是该点在SVM分类线上，即fat boundary。也就是说，满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />&gt;0的点一定落在fat
            boundary上，这些点就是Support Vector。这是一个非常有趣的特性。</p>

        <h3 id="messages-behind-dual-svm" class="sigil_not_in_toc"><strong>Messages behind Dual SVM</strong></h3>

        <p>回忆一下，上一节课中，我们把位于分类线边界上的点称为support vector（candidates）。本节课前面介绍了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />&gt;0的点一定落在分类线边界上，这些点称之为support
            vector（注意没有candidates）。也就是说分类线上的点不一定都是支持向量，但是满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />&gt;0的点，一定是支持向量。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4bba91a3df7aeb6ec3a4dd152ea6f87f.jpg" alt="这里写图片描述" title="" /></p>

        <p>SV只由<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />&gt;0的点决定，根据上一部分推导的w和b的计算公式，我们发现，w和b仅由SV即<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />&gt;0的点决定，简化了计算量。这跟我们上一节课介绍的分类线只由“胖”边界上的点所决定是一个道理。也就是说，样本点可以分成两类：一类是support
            vectors，通过support vectors可以求得fattest hyperplane；另一类不是support vectors，对我们求得fattest hyperplane没有影响。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f2c058722c1f4343cb344bf06c74026a.jpg" alt="这里写图片描述" title="" /></p>

        <p>回过头来，我们来比较一下SVM和PLA的w公式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/88ec3911c97e06c02e6aa47919a0e3ea.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们发现，二者在形式上是相似的。<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/870e196274fb87ef507b6bbebf697db9.jpg" />由fattest hyperplane边界上所有的SV决定，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2de33d1152bc9266f54828db82afac0a.jpg" />由所有当前分类错误的点决定。<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/870e196274fb87ef507b6bbebf697db9.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2de33d1152bc9266f54828db82afac0a.jpg" />都是原始数据点<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d873c5e6c901dc85105463368e9c46cd.jpg" />的线性组合形式，是原始数据的代表。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/24e51a68b0a840edee6615be101c1d12.jpg" alt="这里写图片描述" title="" /></p>

        <p>总结一下，本节课和上节课主要介绍了两种形式的SVM，一种是Primal Hard-Margin SVM，另一种是Dual Hard_Margin SVM。Primal Hard-Margin SVM有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/81f3529fe606d9313bd5b610f9bebc92.jpg" />个参数，有N个限制条件。当<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/81f3529fe606d9313bd5b610f9bebc92.jpg" />很大时，求解困难。而Dual Hard_Margin
            SVM有N个参数，有N+1个限制条件。当数据量N很大时，也同样会增大计算难度。两种形式都能得到w和b，求得fattest hyperplane。通常情况下，如果N不是很大，一般使用Dual SVM来解决问题。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8ebdb61b1791c5baf2a3f536444a8597.jpg" alt="这里写图片描述" title="" /></p>

        <p>这节课提出的Dual SVM的目的是为了避免计算过程中对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />的依赖，而只与N有关。但是，Dual
            SVM是否真的消除了对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />的依赖呢？其实并没有。因为在计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3d0de89d8cc6447a36dd93c6e7aef429.jpg" />的过程中，由z向量引入了<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />，实际上复杂度已经隐藏在计算过程中了。所以，我们的目标并没有实现。下一节课我们将继续研究探讨如何消除对<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />的依赖。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/13aec28d3ee01fc80f48db45bc47b3c6.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="总结" class="sigil_not_in_toc"><strong>总结</strong></h3>

        <p>本节课主要介绍了SVM的另一种形式：Dual SVM。我们这样做的出发点是为了移除计算过程对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />的依赖。Dual
            SVM的推导过程是通过引入拉格朗日因子<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/82005cc2e0087e2a52c7e43df4a19a00.jpg" />，将SVM转化为新的非条件形式。然后，利用QP，得到最佳解的拉格朗日因子<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/82005cc2e0087e2a52c7e43df4a19a00.jpg" />。再通过KKT条件，计算得到对应的w和b。最终求得fattest
            hyperplane。下一节课，我们将解决Dual SVM计算过程中对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />的依赖问题。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习技法》课程</p>

        <p><strong>更多AI资源请关注公众号：红色石头的机器学习之路（ID：redstonewill）</strong> <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d87273058c04b0486763efaacdc13bfb.jpg" alt="这里写图片描述" title="" /></p>
    </div>

    <h1 class="title-article">3 -- Kernel Support Vector Machine</h1>
    <div class="markdown_views">
        <blockquote>
            <p>红色石头的个人网站：<a href="http://redstonewill.com/" rel="nofollow">redstonewill.com</a></p>
        </blockquote>

        <p>上节课我们主要介绍了SVM的对偶形式，即dual SVM。Dual
            SVM也是一个二次规划问题，可以用QP来进行求解。之所以要推导SVM的对偶形式是因为：首先，它展示了SVM的几何意义；然后，从计算上，求解过程“好像”与所在维度<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />无关，规避了<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />很大时难以求解的情况。但是，上节课的最后，我们也提到dual SVM的计算过程其实跟<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />还是有关系的。那么，能不能完全摆脱对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />的依赖，从而减少SVM计算量呢？这就是我们本节课所要讲的主要内容。</p>

        <h3 id="kernel-trick" class="sigil_not_in_toc"><strong>Kernel Trick</strong></h3>

        <p>我们上节课推导的dual SVM是如下形式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9963013aa0114f2a018abf1414185750.jpg" alt="这里写图片描述" title="" /></p>

        <p>其中<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/82005cc2e0087e2a52c7e43df4a19a00.jpg" />是拉格朗日因子，共N个，这是我们要求解的，而条件共有N+1个。我们来看向量<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1fe7a902369b857be0aefda4594ddedc.jpg" />中的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3d0de89d8cc6447a36dd93c6e7aef429.jpg" />，看似这个计算与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />无关，但是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b1b6374af3b38fdb428ac954c29a899e.jpg" />的内积中不得不引入<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />。也就是说，如果<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />很大，计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b1b6374af3b38fdb428ac954c29a899e.jpg" />的复杂度也会很高，同样会影响QP问题的计算效率。可以说，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3d0de89d8cc6447a36dd93c6e7aef429.jpg" />这一步是计算的瓶颈所在。</p>

        <p>其实问题的关键在于<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b1b6374af3b38fdb428ac954c29a899e.jpg" />内积求解上。我们知道，z是由x经过特征转换而来：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e277d4f661efe26e889f6512ed41cdd7.jpg" /></p>

        <p>如果从x空间来看的话，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b1b6374af3b38fdb428ac954c29a899e.jpg" />分为两个步骤：1. 进行特征转换<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/906461d8e73b71342020d05cb5b01d7c.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0fabf7042aa60f44f8405a35d842ceb7.jpg" />；2. 计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/906461d8e73b71342020d05cb5b01d7c.jpg" />与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0fabf7042aa60f44f8405a35d842ceb7.jpg" />的内积。这种先转换再计算内积的方式，必然会引入<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />参数，从而在<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />很大的时候影响计算速度。那么，若把这两个步骤联合起来，是否可以有效地减小计算量，提高计算速度呢？</p>

        <p>我们先来看一个简单的例子，对于二阶多项式转换，各种排列组合为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0c50f4c37cd731776e1a3927db7d5b0f.jpg" alt="这里写图片描述" title="" /></p>

        <p>这里提一下，为了简单起见，我们把<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e06c832b50d067f6adcb5581f4d1c297.jpg" />包含进来，同时将二次项<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/de88439a7f52e8c41be8e8a586172649.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/37af3f8625130eefe5c9ff1c2c945b18.jpg" />也包含进来。转换之后再做内积并进行推导，得到：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/09bcd008e92937537dc5d5627a0757f7.jpg" alt="这里写图片描述" title="" /></p>

        <p>其中<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/70699fcdf117dcb43d9ada6c41a0252c.jpg" />是x空间中特征向量的内积。所以，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1ae3b108a49dd873ae26314855cde4d3.jpg" />与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc5f30b627754c112790c50bb7f8e423.jpg" />的内积的复杂度由原来的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6defe1038cdaa3379890b4b11fc8fbb7.jpg" />变成<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4a9f1eb59e9aca78102049c3006b6fbe.jpg" />，只与x空间的维度d有关，而与z空间的维度<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />无关，这正是我们想要的！</p>

        <p>至此，我们发现如果把特征转换和z空间计算内积这两个步骤合并起来，有可能会简化计算。因为我们只是推导了二阶多项式会提高运算速度，这个特例并不具有一般推论性。但是，我们还是看到了希望。</p>

        <p>我们把合并特征转换和计算内积这两个步骤的操作叫做Kernel Function，用大写字母K表示。例如刚刚讲的二阶多项式例子，它的kernel function为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2e3d67f056d8eb132fb83b55d9a1fa6b.jpg" /></p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c1427521e1006ae3dad786ac1ee30dc0.jpg" /></p>

        <p>有了kernel function之后，我们来看看它在SVM里面如何使用。在dual SVM中，二次项系数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/755cb947eb5865293d3c2af8bf4788db.jpg" />中有z的内积计算，就可以用kernel
            function替换：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/faea774a5f085cac93c09f8f2189d20f.jpg" /></p>

        <p>所以，直接计算出<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/70af08ef8ccec23cba790878be5a7043.jpg" />，再代入上式，就能得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/755cb947eb5865293d3c2af8bf4788db.jpg" />的值。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/755cb947eb5865293d3c2af8bf4788db.jpg" />值计算之后，就能通过QP得到拉格朗日因子<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />。然后，下一步就是计算b（取<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />&gt;0的点，即SV），b的表达式中包含z，可以作如下推导：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f64fa781c41b69330f4d930dd69e40a2.jpg" /></p>

        <p>这样得到的b就可以用kernel function表示，而与z空间无关。</p>

        <p>最终我们要求的矩<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f7480a086f97ad3ec2aa19c5c1102c50.jpg" />可以作如下推导：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2107494b3ab5e0bb04dd67c7f31a687a.jpg" /></p>

        <p>至此，dual SVM中我们所有需要求解的参数都已经得到了，而且整个计算过程中都没有在z空间作内积，即与z无关。我们把这个过程称为kernel trick，也就是把特征转换和计算内积两个步骤结合起来，用kernel
            function来避免计算过程中受<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />的影响，从而提高运算速度。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/121df257ff97da30e6b8002f4251bd85.jpg" alt="这里写图片描述" title="" /></p>

        <p>那么总结一下，引入kernel funtion后，SVM算法变成：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/611675145258f9dd0eb2be46747f5a4e.jpg" alt="这里写图片描述" title="" /></p>

        <p>分析每个步骤的时间复杂度为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d867288191351fcc2069669d07fc5dca.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们把这种引入kernel function的SVM称为kernel SVM，它是基于dual SVM推导而来的。kernel SVM同样只用SV（<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />&gt;0）就能得到最佳分类面，而且整个计算过程中摆脱了<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />的影响，大大提高了计算速度。</p>

        <h3 id="polynomial-kernel" class="sigil_not_in_toc"><strong>Polynomial Kernel</strong></h3>

        <p>我们刚刚通过一个特殊的二次多项式导出了相对应的kernel，其实二次多项式的kernel形式是多种的。例如，相应系数的放缩构成完全平方公式等。下面列举了几种常用的二次多项式kernel形式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd9c848f3039394555fb559bbf86dc47.jpg" alt="这里写图片描述" title="" /></p>

        <p>比较一下，第一种<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1ae3b108a49dd873ae26314855cde4d3.jpg" />（蓝色标记）和第三种<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1ae3b108a49dd873ae26314855cde4d3.jpg" />（绿色标记）从某种角度来说是一样的，因为都是二次转换，对应到同一个z空间。但是，它们系数不同，内积就会有差异，那么就代表有不同的距离，最终可能会得到不同的SVM
            margin。所以，系数不同，可能会得到不同的SVM分界线。通常情况下，第三种<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1ae3b108a49dd873ae26314855cde4d3.jpg" />（绿色标记）简单一些，更加常用。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75c99c7a12cde493a430a8660b4f3640.jpg" alt="这里写图片描述" title="" /></p>

        <p>不同的转换，对应到不同的几何距离，得到不同的距离，这是什么意思呢？举个例子，对于我们之前介绍的一般的二次多项式kernel，它的SVM margin和对应的SV如下图（中）所示。对于上面介绍的完全平方公式形式，自由度<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e5eb48b52abfea615dab1901fba89948.jpg" />，它的SVM margin和对应的SV如下图（左）所示。比较发现，这种SVM
            margin比较简单一些。对于自由度<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ff95a8e3c1607467e4e872f939a4bfe7.jpg" />，它的SVM
            margin和对应的SV如下图（右）所示。与前两种比较，margin和SV都有所不同。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/69005cabbf532ae787067ceb2fa4cf40.jpg" alt="这里写图片描述" title="" /></p>

        <p>通过改变不同的系数，得到不同的SVM margin和SV，如何选择正确的kernel，非常重要。</p>

        <p>归纳一下，引入<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0fd6dee3b6a268ae6f8c16faf2d704b0.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/86d1022cfa58f807202bec1c3b1fc5a3.jpg" />，对于Q次多项式一般的kernel形式可表示为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/584865a01945fa78f22e3a02a6de0375.jpg" alt="这里写图片描述" title="" /></p>

        <p>所以，使用高阶的多项式kernel有两个优点：</p>

        <ul>
            <li>
                <p><strong>得到最大SVM margin，SV数量不会太多，分类面不会太复杂，防止过拟合，减少复杂度</strong></p>
            </li>
            <li>
                <p><strong>计算过程避免了对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />的依赖，大大简化了计算量。</strong></p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4549c59fa11cf26747a96bd5a14f091a.jpg" alt="这里写图片描述" title="" /></p>

        <p>顺便提一下，当多项式阶数Q=1时，那么对应的kernel就是线性的，即本系列课程第一节课所介绍的内容。对于linear
            kernel，计算方法是简单的，而且也是我们解决SVM问题的首选。还记得机器学习基石课程中介绍的奥卡姆剃刀定律（Occam’s Razor）吗？</p>

        <h3 id="gaussian-kernel" class="sigil_not_in_toc"><strong>Gaussian Kernel</strong></h3>

        <p>刚刚我们介绍的Q阶多项式kernel的阶数是有限的，即特征转换的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />是有限的。但是，如果是无限多维的转换<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aed0c138deb8fbac62918bb5c5351399.jpg" />，是否还能通过kernel的思想，来简化SVM的计算呢？答案是肯定的。</p>

        <p>先举个例子，简单起见，假设原空间是一维的，只有一个特征x，我们构造一个kernel function为高斯函数：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/925e0550c7c54167f513da36aa533cd2.jpg" /></p>

        <p>构造的过程正好与二次多项式kernel的相反，利用反推法，先将上式分解并做泰勒展开：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f0877d21dc36b947945fa681781a2cd2.jpg" alt="这里写图片描述" title="" /></p>

        <p>将构造的K(x,x’)推导展开为两个<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aed0c138deb8fbac62918bb5c5351399.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/18af12eb6ed878f19db455f058a8a3bc.jpg" />的乘积，其中：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fd182493f17f8351cd0fa73463d93aa5.jpg" /></p>

        <p>通过反推，我们得到了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aed0c138deb8fbac62918bb5c5351399.jpg" />，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aed0c138deb8fbac62918bb5c5351399.jpg" />是无限多维的，它就可以当成特征转换的函数，且<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />是无限的。这种<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aed0c138deb8fbac62918bb5c5351399.jpg" />得到的核函数即为Gaussian
            kernel。</p>

        <p>更一般地，对于原空间不止一维的情况（d&gt;1），引入缩放因子<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/86d1022cfa58f807202bec1c3b1fc5a3.jpg" />，它对应的Gaussian
            kernel表达式为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0cecc1e44fd553a74a92e7283b336b07.jpg" /></p>

        <p>那么引入了高斯核函数，将有限维度的特征转换拓展到无限的特征转换中。根据本节课上一小节的内容，由K，计算得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />和b，进而得到矩<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f7480a086f97ad3ec2aa19c5c1102c50.jpg" />。将其中的核函数K用高斯核函数代替，得到：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ae6084ff92ac0732faa42e3c4d00c023.jpg" /></p>

        <p>通过上式可以看出，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f7480a086f97ad3ec2aa19c5c1102c50.jpg" />有n个高斯函数线性组合而成，其中n是SV的个数。而且，每个高斯函数的中心都是对应的SV。通常我们也把高斯核函数称为径向基函数（Radial
            Basis Function, RBF）。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/85b4a1d96b9ca3f124cd3163368be938.jpg" alt="这里写图片描述" title="" /></p>

        <p>总结一下，kernel SVM可以获得large-margin的hyperplanes，并且可以通过高阶的特征转换使<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />尽可能地小。kernel的引入大大简化了dual
            SVM的计算量。而且，Gaussian kernel能将特征转换扩展到无限维，并使用有限个SV数量的高斯函数构造出矩<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f7480a086f97ad3ec2aa19c5c1102c50.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2abbb9dde7aef1b6dc861bc9cc010c0a.jpg" alt="这里写图片描述" title="" /></p>

        <p>值得注意的是，缩放因子<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cdab9437b701fd21fb3294cfba7c4bc2.jpg" />取值不同，会得到不同的高斯核函数，hyperplanes不同，分类效果也有很大的差异。举个例子，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cdab9437b701fd21fb3294cfba7c4bc2.jpg" />分别取1, 10, 100时对应的分类效果如下：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3e06ec4421d4e64adc8eade6bd564fca.jpg" alt="这里写图片描述" title="" /></p>

        <p>从图中可以看出，当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cdab9437b701fd21fb3294cfba7c4bc2.jpg" />比较小的时候，分类线比较光滑，当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cdab9437b701fd21fb3294cfba7c4bc2.jpg" />越来越大的时候，分类线变得越来越复杂和扭曲，直到最后，分类线变成一个个独立的小区域，像小岛一样将每个样本单独包起来了。为什么会出现这种区别呢？这是因为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cdab9437b701fd21fb3294cfba7c4bc2.jpg" />越大，其对应的高斯核函数越尖瘦，那么有限个高斯核函数的线性组合就比较离散，分类效果并不好。所以，SVM也会出现过拟合现象，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cdab9437b701fd21fb3294cfba7c4bc2.jpg" />的正确选择尤为重要，不能太大。</p>

        <h3 id="comparison-of-kernels" class="sigil_not_in_toc"><strong>Comparison of Kernels</strong></h3>

        <p>目前为止，我们已经介绍了几种kernel，下面来对几种kernel进行比较。</p>

        <p>首先，Linear Kernel是最简单最基本的核，平面上对应一条直线，三维空间里对应一个平面。Linear Kernel可以使用上一节课介绍的Dual SVM中的QP直接计算得到。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/64e83172ebe908ea0254d4831fa512a6.jpg" alt="这里写图片描述" title="" /></p>

        <p>Linear Kernel的优点是计算简单、快速，可以直接使用QP快速得到参数值，而且从视觉上分类效果非常直观，便于理解；缺点是如果数据不是线性可分的情况，Linear Kernel就不能使用了。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/32d11ca0eb6846836f0d68ce7514355d.jpg" alt="这里写图片描述" title="" /></p>

        <p>然后，Polynomial Kernel的hyperplanes是由多项式曲线构成。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/688995a4eac659ace3df46ade55dd242.jpg" alt="这里写图片描述" title="" /></p>

        <p>Polynomial Kernel的优点是阶数Q可以灵活设置，相比linear kernel限制更少，更贴近实际样本分布；缺点是当Q很大时，K的数值范围波动很大，而且参数个数较多，难以选择合适的值。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/31ac10f30bf881e4774a6f35dcf8f3a0.jpg" alt="这里写图片描述" title="" /></p>

        <p>对于Gaussian Kernel，表示为高斯函数形式。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9d55ecd5f795b7a56b9f930dd4a6a519.jpg" alt="这里写图片描述" title="" /></p>

        <p>Gaussian Kernel的优点是边界更加复杂多样，能最准确地区分数据样本，数值计算K值波动较小，而且只有一个参数，容易选择；缺点是由于特征转换到无限维度中，w没有求解出来，计算速度要低于linear
            kernel，而且可能会发生过拟合。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/18112d4fee8d3f81e6a32fdbef83d408.jpg" alt="这里写图片描述" title="" /></p>

        <p>除了这三种kernel之外，我们还可以使用其它形式的kernel。首先，我们考虑kernel是什么？实际上kernel代表的是两笔资料x和x’，特征变换后的相似性即内积。但是不能说任何计算相似性的函数都可以是kernel。有效的kernel还需满足几个条件：</p>

        <ul>
            <li>
                <p><strong>K是对称的</strong></p>
            </li>
            <li>
                <p><strong>K是半正定的</strong></p>
            </li>
        </ul>

        <p>这两个条件不仅是必要条件，同时也是充分条件。所以，只要我们构造的K同时满足这两个条件，那它就是一个有效的kernel。这被称为Mercer 定理。事实上，构造一个有效的kernel是比较困难的。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5adc893bd957506168bb207d1bbfefa2.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="总结" class="sigil_not_in_toc"><strong>总结</strong></h3>

        <p>本节课主要介绍了Kernel Support Vector Machine。首先，我们将特征转换和计算内积的操作合并到一起，消除了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/43d11718af2e4efe2c95da32038c4b0c.jpg" />的影响，提高了计算速度。然后，分别推导了Polynomial
            Kernel和Gaussian Kernel，并列举了各自的优缺点并做了比较。对于不同的问题，应该选择合适的核函数进行求解，以达到最佳的分类效果。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习技法》课程</p>

        <p><strong>更多AI资源请关注公众号：红色石头的机器学习之路（ID：redstonewill）</strong> <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4af35b184f6ecd751e069a88e95f17b6.jpg" alt="这里写图片描述" title="" /></p>
    </div>

    <h1 class="title-article">4 -- Soft-Margin Support Vector Machine</h1>
    <div class="markdown_views">
        <blockquote>
            <p>红色石头的个人网站：<a href="http://redstonewill.com/" rel="nofollow">redstonewill.com</a></p>
        </blockquote>

        <p>上节课我们主要介绍了Kernel SVM。先将特征转换和计算内积这两个步骤合并起来，简化计算、提高计算速度，再用Dual SVM的求解方法来解决。Kernel
            SVM不仅能解决简单的线性分类问题，也可以求解非常复杂甚至是无限多维的分类问题，关键在于核函数的选择，例如线性核函数、多项式核函数和高斯核函数等等。但是，我们之前讲的这些方法都是Hard-Margin
            SVM，即必须将所有的样本都分类正确才行。这往往需要更多更复杂的特征转换，甚至造成过拟合。本节课将介绍一种Soft-Margin
            SVM，目的是让分类错误的点越少越好，而不是必须将所有点分类正确，也就是允许有noise存在。这种做法很大程度上不会使模型过于复杂，不会造成过拟合，而且分类效果是令人满意的。</p>

        <h3 id="motivation-and-primal-problem" class="sigil_not_in_toc"><strong>Motivation and Primal Problem</strong></h3>

        <p>上节课我们说明了一点，就是SVM同样可能会造成overfit。原因有两个，一个是由于我们的SVM模型（即kernel）过于复杂，转换的维度太多，过于powerful了；另外一个是由于我们坚持要将所有的样本都分类正确，即不允许错误存在，造成模型过于复杂。如下图所示，左边的图<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/de6156a36da5593672299bfefa52b1e5.jpg" />是线性的，虽然有几个点分类错误，但是大部分都能完全分开。右边的图<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e94099764c799580f1714afd62695462.jpg" />是四次多项式，所有点都分类正确了，但是模型比较复杂，可能造成过拟合。直观上来说，左边的图是更合理的模型。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cd6990173963357c58b4216bbe0dc59b.jpg" alt="这里写图片描述" title="" /></p>

        <p>如何避免过拟合？方法是允许有分类错误的点，即把某些点当作是noise，放弃这些noise点，但是尽量让这些noise个数越少越好。回顾一下我们在机器学习基石笔记中介绍的pocket算法，pocket的思想不是将所有点完全分开，而是找到一条分类线能让分类错误的点最少。而Hard-Margin
            SVM的目标是将所有点都完全分开，不允许有错误点存在。为了防止过拟合，我们可以借鉴pocket的思想，即允许有犯错误的点，目标是让这些点越少越好。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/318d64bf8b507135a5da6752c96ee49a.jpg" alt="这里写图片描述" title="" /></p>

        <p>为了引入允许犯错误的点，我们将Hard-Margin SVM的目标和条件做一些结合和修正，转换为如下形式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6a4a6ccde66c7955733850f785440cf1.jpg" alt="这里写图片描述" title="" /></p>

        <p>修正后的条件中，对于分类正确的点，仍需满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/421c2ca1e48f63ab4e6aeda6aa7dd8e9.jpg" />，而对于noise点，满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75e85e6ae32dc853554b0127bacfbd1c.jpg" />，即没有限制。修正后的目标除了<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fe7bbafafbb55291e5ff44c29986ee21.jpg" />项，还添加了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/04b322c7f26d36bf3300ae1606314940.jpg" />，即noise点的个数。参数C的引入是为了权衡目标第一项和第二项的关系，即权衡large
            margin和noise tolerance的关系。</p>

        <p>我们再对上述的条件做修正，将两个条件合并，得到：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e74611e41c2ff40e124e0d4a052e5243.jpg" alt="这里写图片描述" title="" /></p>

        <p>这个式子存在两个不足的地方。首先，最小化目标中第二项是非线性的，不满足QP的条件，所以无法使用dual或者kernel
            SVM来计算。然后，对于犯错误的点，有的离边界很近，即error小，而有的离边界很远，error很大，上式的条件和目标没有区分small error和large error。这种分类效果是不完美的。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/66f91e1d0fe6390db2e2c865a2d1ef44.jpg" alt="这里写图片描述" title="" /></p>

        <p>为了改正这些不足，我们继续做如下修正：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6784a16580e3a2963f8806dee12623a1.jpg" alt="这里写图片描述" title="" /></p>

        <p>修正后的表达式中，我们引入了新的参数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40ba8a7a08940acca1b2724689177103.jpg" />来表示每个点犯错误的程度值，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1d32e4c7621717e43be3ebb7e4d5ae55.jpg" />。通过使用error值的大小代替是否有error，让问题变得易于求解，满足QP形式要求。这种方法类似于我们在机器学习基石笔记中介绍的0/1
            error和squared error。这种soft-margin SVM引入新的参数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5c12c10e0a4ede5cb71a28124e734649.jpg" />。</p>

        <p>至此，最终的Soft-Margin SVM的目标为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2794a621c994da4de33da5a82c0e0a3c.jpg" /></p>

        <p>条件是：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0b3af39c316106e9e38e58f5384131bd.jpg" /></p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1d32e4c7621717e43be3ebb7e4d5ae55.jpg" /></p>

        <p>其中，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40ba8a7a08940acca1b2724689177103.jpg" />表示每个点犯错误的程度，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d969059c4983d25c5a8efdf9836ae4f7.jpg" />，表示没有错误，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40ba8a7a08940acca1b2724689177103.jpg" />越大，表示错误越大，即点距离边界（负的）越大。参数C表示尽可能选择宽边界和尽可能不要犯错两者之间的权衡，因为边界宽了，往往犯错误的点会增加。large
            C表示希望得到更少的分类错误，即不惜选择窄边界也要尽可能把更多点正确分类；small C表示希望得到更宽的边界，即不惜增加错误点个数也要选择更宽的分类边界。</p>

        <p>与之对应的QP问题中，由于新的参数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40ba8a7a08940acca1b2724689177103.jpg" />的引入，总共参数个数为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/911d742ee57cd09587062da7fe504fac.jpg" />，限制条件添加了<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1d32e4c7621717e43be3ebb7e4d5ae55.jpg" />，则总条件个数为2N。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9f5aa1dd5d52f2bbb5159bc9f584b63d.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="dual-problem" class="sigil_not_in_toc"><strong>Dual Problem</strong></h3>

        <p>接下来，我们将推导Soft-Margin SVM的对偶dual形式，从而让QP计算更加简单，并便于引入kernel算法。首先，我们把Soft-Margin SVM的原始形式写出来：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2d5e65c361f1f9d330a17d58e8c0739e.jpg" alt="这里写图片描述" title="" /></p>

        <p>然后，跟我们在第二节课中介绍的Hard-Margin SVM做法一样，构造一个拉格朗日函数。因为引入了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40ba8a7a08940acca1b2724689177103.jpg" />，原始问题有两类条件，所以包含了两个拉格朗日因子<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a5240d5e29bc269362ba121cb320f46f.jpg" />。拉格朗日函数可表示为如下形式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0d2870419e389f3520c4e8ca0e22a680.jpg" alt="这里写图片描述" title="" /></p>

        <p>接下来，我们跟第二节课中的做法一样，利用Lagrange dual problem，将Soft-Margin SVM问题转换为如下形式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/949be96d374573ca885e693f76608bf2.jpg" alt="这里写图片描述" title="" /></p>

        <p>根据之前介绍的KKT条件，我们对上式进行简化。上式括号里面的是对拉格朗日函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/116c8d7be75881ba2b3045f13d49238f.jpg" />计算最小值。那么根据梯度下降算法思想：最小值位置满足梯度为零。</p>

        <p>我们先对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40ba8a7a08940acca1b2724689177103.jpg" />做偏微分：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/992c5f80b6848443bd8f3a6a01d1fce7.jpg" /></p>

        <p>根据上式，得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3e31d5ab52b3e4109176cda3d1175fb3.jpg" />，因为有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dee8eafe087bc432f1b48132de301cdb.jpg" />，所以限制<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2d5dc37ee169283a647fee95b6c18871.jpg" />。将<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3e31d5ab52b3e4109176cda3d1175fb3.jpg" />代入到dual形式中并化简，我们发现<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a5240d5e29bc269362ba121cb320f46f.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40ba8a7a08940acca1b2724689177103.jpg" />都被消去了：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/68865f0442c203dba14a1c22b4ccb5bc.jpg" alt="这里写图片描述" title="" /></p>

        <p>这个形式跟Hard-Margin SVM中的dual形式是基本一致的，只是条件不同。那么，我们分别令拉个朗日函数L对b和w的偏导数为零，分别得到：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9c044a4161aafa0fe2d6ec7b962d666d.jpg" /></p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/69bdfefe744163ecac980fd18bac2712.jpg" /></p>

        <p>经过化简和推导，最终标准的Soft-Margin SVM的Dual形式如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/686a8abb8a2ca7da7b9f4d6f3e5bd4cf.jpg" alt="这里写图片描述" title="" /></p>

        <p>Soft-Margin SVM Dual与Hard-Margin SVM Dual基本一致，只有一些条件不同。Hard-Margin SVM Dual中<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/db6890730ce9a7d6545d124446e7da9e.jpg" />，而Soft-Margin
            SVM Dual中<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2d5dc37ee169283a647fee95b6c18871.jpg" />，且新的拉格朗日因子<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3e31d5ab52b3e4109176cda3d1175fb3.jpg" />。在QP问题中，Soft-Margin
            SVM Dual的参数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />同样是N个，但是，条件由Hard-Margin SVM
            Dual中的N+1个变成2N+1个，这是因为多了N个<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />的上界条件。</p>

        <p>对于Soft-Margin SVM Dual这部分推导不太清楚的同学，可以看下第二节课的笔记：<a href="http://blog.csdn.net/red_stone1/article/details/73822768"
                rel="nofollow">2 – Dual Support Vector Machine</a></p>

        <h3 id="messages-behind-soft-margin-svm" class="sigil_not_in_toc"><strong>Messages behind Soft-Margin SVM</strong></h3>

        <p>推导完Soft-Margin SVM Dual的简化形式后，就可以利用QP，找到Q，p，A，c对应的值，用软件工具包得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />的值。或者利用核函数的方式，同样可以简化计算，优化分类效果。Soft-Margin
            SVM Dual计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />的方法过程与Hard-Margin SVM Dual的过程是相同的。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/865a25e0b5a251e7bb07a6f6c55ed4b1.jpg" alt="这里写图片描述" title="" /></p>

        <p>但是如何根据<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />的值计算b呢？在Hard-Margin SVM
            Dual中，有complementary slackness条件：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/143c7a016f60f17ee3ffa7de1c336026.jpg" />，找到SV，即<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/94d62be943cf1eac2b155bbc649d2be5.jpg" />的点，计算得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9cdf066c61c38471de8bc9e7624097fc.jpg" />。</p>

        <p>那么，在Soft-Margin SVM Dual中，相应的complementary slackness条件有两个（因为两个拉格朗日因子<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a5240d5e29bc269362ba121cb320f46f.jpg" />）：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/24badfcf38664366b3a4fa6f8625e2ac.jpg" /></p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/42574ea1314f40bae9a4be3c0a751a8e.jpg" /></p>

        <p>找到SV，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/94d62be943cf1eac2b155bbc649d2be5.jpg" />的点，由于参数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40ba8a7a08940acca1b2724689177103.jpg" />的存在，还不能完全计算出b的值。根据第二个complementary
            slackness条件，如果令<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3bc0cb93f55f85cb9924778b3576f443.jpg" />，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/427162674635fac93f76073834721530.jpg" />，则一定有<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d969059c4983d25c5a8efdf9836ae4f7.jpg" />，代入到第一个complementary slackness条件，即可计算得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9cdf066c61c38471de8bc9e7624097fc.jpg" />。我们把<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3288b7bc128237422e3b1610ce23fa59.jpg" />的点称为free SV。引入核函数后，b的表达式为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/757e3f73deab6f426ab099f0acef4fbb.jpg" /></p>

        <p>上面求解b提到的一个假设是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/67609924d00a63fd28c0b6a7c0ddecc3.jpg" />，这个假设是否一定满足呢？如果没有free SV，所有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aa69dda237beb633f148bc405725f9bd.jpg" />大于零的点都满足<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/df3197b5d35e22401af3b98f192d2e15.jpg" />怎么办？一般情况下，至少存在一组SV使<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/67609924d00a63fd28c0b6a7c0ddecc3.jpg" />的概率是很大的。如果出现没有free
            SV的情况，那么b通常会由许多不等式条件限制取值范围，值是不确定的，只要能找到其中满足KKT条件的任意一个b值就可以了。这部分细节比较复杂，不再赘述。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/64bdaf37016f49c3731278d0975fa47e.jpg" alt="这里写图片描述" title="" /></p>

        <p>接下来，我们看看C取不同的值对margin的影响。例如，对于Soft-Margin Gaussian SVM，C分别取1，10，100时，相应的margin如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7fb4b7e89f9d6cdebe896f4d533f403b.jpg" alt="这里写图片描述" title="" /></p>

        <p>从上图可以看出，C=1时，margin比较粗，但是分类错误的点也比较多，当C越来越大的时候，margin越来越细，分类错误的点也在减少。正如前面介绍的，C值反映了margin和分类正确的一个权衡。C越小，越倾向于得到粗的margin，宁可增加分类错误的点；C越大，越倾向于得到高的分类正确率，宁可margin很细。我们发现，当C值很大的时候，虽然分类正确率提高，但很可能把noise也进行了处理，从而可能造成过拟合。也就是说Soft-Margin
            Gaussian SVM同样可能会出现过拟合现象，所以参数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f932b37b23db91b08d2392465c894dac.jpg" />的选择非常重要。</p>

        <p>我们再来看看<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />取不同值是对应的物理意义。已知<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2d5dc37ee169283a647fee95b6c18871.jpg" />满足两个complementary
            slackness条件：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/24badfcf38664366b3a4fa6f8625e2ac.jpg" /></p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/42574ea1314f40bae9a4be3c0a751a8e.jpg" /></p>

        <p>若<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f45cc32c1db76f070988752be8d270ba.jpg" />，得<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d969059c4983d25c5a8efdf9836ae4f7.jpg" />。<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d969059c4983d25c5a8efdf9836ae4f7.jpg" />表示该点没有犯错，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f45cc32c1db76f070988752be8d270ba.jpg" />表示该点不是SV。所以对应的点在margin之外（或者在margin上），且均分类正确。</p>

        <p>若<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a8f150fd55b13c824f70d4ba384f3b3.jpg" />，得<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d969059c4983d25c5a8efdf9836ae4f7.jpg" />，且<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/668d079f15a25b2346fa69e0ee7d687a.jpg" />。<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d969059c4983d25c5a8efdf9836ae4f7.jpg" />表示该点没有犯错，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/668d079f15a25b2346fa69e0ee7d687a.jpg" />表示该点在margin上。这些点即free SV，确定了b的值。</p>

        <p>若<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6b4b521cb9e0c249f3f44a2f3bcd7f32.jpg" />，不能确定<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40ba8a7a08940acca1b2724689177103.jpg" />是否为零，且得到<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c2ab2398f3a7fb3fd1b478ddcef5c222.jpg" />，这个式表示该点偏离margin的程度，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40ba8a7a08940acca1b2724689177103.jpg" />越大，偏离margin的程度越大。只有当<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d969059c4983d25c5a8efdf9836ae4f7.jpg" />时，该点落在margin上。所以这种情况对应的点在margin之内负方向（或者在margin上），有分类正确也有分类错误的。这些点称为bounded
            SV。</p>

        <p>所以，在Soft-Margin SVM Dual中，根据<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />的取值，就可以推断数据点在空间的分布情况。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/62c8dfb45e5e3aa5c7aa32d8f512cf34.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="model-selection" class="sigil_not_in_toc"><strong>Model Selection</strong></h3>

        <p>在Soft-Margin SVM Dual中，kernel的选择、C等参数的选择都非常重要，直接影响分类效果。例如，对于Gaussian SVM，不同的参数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/168c59a9de2f3609f916c95bf403ca13.jpg" />，会得到不同的margin，如下图所示。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f8ff44bdaccd7cca0ef513d4eebfe2cd.jpg" alt="这里写图片描述" title="" /></p>

        <p>其中横坐标是C逐渐增大的情况，纵坐标是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cdab9437b701fd21fb3294cfba7c4bc2.jpg" />逐渐增大的情况。不同的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/168c59a9de2f3609f916c95bf403ca13.jpg" />组合，margin的差别很大。那么如何选择最好的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/168c59a9de2f3609f916c95bf403ca13.jpg" />等参数呢？最简单最好用的工具就是validation。</p>

        <p>validation我们在机器学习基石课程中已经介绍过，只需要将由不同<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/168c59a9de2f3609f916c95bf403ca13.jpg" />等参数得到的模型在验证集上进行cross
            validation，选取<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3ec70cba3e47fb34ae8101f333268c3a.jpg" />最小的对应的模型就可以了。例如上图中各种<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/168c59a9de2f3609f916c95bf403ca13.jpg" />组合得到的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3ec70cba3e47fb34ae8101f333268c3a.jpg" />如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f23d1837e6cc9503eeeea5bb997e79ca.jpg" alt="这里写图片描述" title="" /></p>

        <p>因为左下角的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/98b5f675bd3684b307703a98fdb6bde8.jpg" />最小，所以就选择该<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/168c59a9de2f3609f916c95bf403ca13.jpg" />对应的模型。通常来说，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/98b5f675bd3684b307703a98fdb6bde8.jpg" />并不是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/168c59a9de2f3609f916c95bf403ca13.jpg" />的连续函数，很难使用最优化选择（例如梯度下降）。一般做法是选取不同的离散的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/168c59a9de2f3609f916c95bf403ca13.jpg" />值进行组合，得到最小的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/98b5f675bd3684b307703a98fdb6bde8.jpg" />，其对应的模型即为最佳模型。这种算法就是我们之前在机器学习基石中介绍过的V-Fold
            cross validation，在SVM中使用非常广泛。</p>

        <p>V-Fold cross validation的一种极限就是Leave-One-Out CV，也就是验证集只有一个样本。对于SVM问题，它的验证集Error满足：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/30bcf38b5d542ff81622db28bdf66606.jpg" /></p>

        <p>也就是说留一法验证集Error大小不超过支持向量SV占所有样本的比例。下面做简单的证明。令样本总数为N，对这N个点进行SVM分类后得到margin，假设第N个点<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a1ae50efc4bd11027491db192d2c9492.jpg" />的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/64e4aed9b13374d3c6e1491e186d6908.jpg" />，不是SV，即远离margin（正距离）。这时候，如果我们只使用剩下的N-1个点来进行SVM分类，那么第N个点<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a1ae50efc4bd11027491db192d2c9492.jpg" />必然是分类正确的点，所得的SVM
            margin跟使用N个点的到的是完全一致的。这是因为我们假设第N个点是non-SV，对SV没有贡献，不影响margin的位置和形状。所以前N-1个点和N个点得到的margin是一样的。</p>

        <p>那么，对于non-SV的点，它的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1e110f128239934ca2def200e986b871.jpg" />，即对第N个点，它的Error必然为零：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fb747eae399ee488edbe1900ecaa70f9.jpg" /></p>

        <p>另一方面，假设第N个点<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9ee13b2408bbefa15e6bd967429b5079.jpg" />，即对于SV的点，它的Error可能是0，也可能是1，必然有：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/880110535b9ee3640f0002c7d74c6845.jpg" /></p>

        <p>综上所述，即证明了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/30bcf38b5d542ff81622db28bdf66606.jpg" />。这符合我们之前得到的结论，即只有SV影响margin，non-SV对margin没有任何影响，可以舍弃。</p>

        <p>SV的数量在SVM模型选择中也是很重要的。一般来说，SV越多，表示模型可能越复杂，越有可能会造成过拟合。所以，通常选择SV数量较少的模型，然后在剩下的模型中使用cross-validation，比较选择最佳模型。</p>

        <h3 id="总结" class="sigil_not_in_toc"><strong>总结</strong></h3>

        <p>本节课主要介绍了Soft-Margin SVM。我们的出发点是与Hard-Margin SVM不同，不一定要将所有的样本点都完全分开，允许有分类错误的点，而使margin比较宽。然后，我们增加了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40ba8a7a08940acca1b2724689177103.jpg" />作为分类错误的惩罚项，根据之前介绍的Dual
            SVM，推导出了Soft-Margin SVM的QP形式。得到的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />除了要满足大于零，还有一个上界C。接着介绍了通过<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />值的大小，可以将数据点分为三种：non-SVs，free SVs，bounded
            SVs，这种更清晰的物理解释便于数据分析。最后介绍了如何选择合适的SVM模型，通常的办法是cross-validation和利用SV的数量进行筛选。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习技法》课程</p>

        <p><strong>更多AI资源请关注公众号：红色石头的机器学习之路（ID：redstonewill）</strong> <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4af35b184f6ecd751e069a88e95f17b6.jpg" alt="这里写图片描述" title="" /></p>
    </div>

    <h1 class="title-article">5 -- Kernel Logistic Regression</h1>
    <div class="markdown_views">
        <blockquote>
            <p>红色石头的个人网站：<a href="http://redstonewill.com/" rel="nofollow">redstonewill.com</a></p>
        </blockquote>

        <p>上节课我们主要介绍了Soft-Margin SVM，即如果允许有分类错误的点存在，那么在原来的Hard-Margin SVM中添加新的惩罚因子C，修正原来的公式，得到新的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />值。最终的到的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />有个上界，上界就是C。Soft-Margin SVM权衡了large-margin和error
            point之前的关系，目的是在尽可能犯更少错误的前提下，得到最大分类边界。本节课将把Soft-Margin SVM和我们之前介绍的Logistic
            Regression联系起来，研究如何使用kernel技巧来解决更多的问题。</p>

        <h3 id="soft-margin-svm-as-regularized-model" class="sigil_not_in_toc"><strong>Soft-Margin SVM as Regularized
                Model</strong></h3>

        <p>先复习一下我们已经介绍过的内容，我们最早开始讲了Hard-Margin Primal的数学表达式，然后推导了Hard-Margin
            Dual形式。后来，为了允许有错误点的存在（或者noise），也为了避免模型过于复杂化，造成过拟合，我们建立了Soft-Margin
            Primal的数学表达式，并引入了新的参数C作为权衡因子，然后也推导了其Soft-Margin Dual形式。因为Soft-Margin Dual
            SVM更加灵活、便于调整参数，所以在实际应用中，使用Soft-Margin Dual SVM来解决分类问题的情况更多一些。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fa2dbb56d69b49193377f8dc108d97d6.jpg" alt="这里写图片描述" title="" /></p>

        <p>Soft-Margin Dual SVM有两个应用非常广泛的工具包，分别是Libsvm和Liblinear。 Libsvm和Liblinear都是国立台湾大学的Chih-Jen Lin博士开发的，Chih-Jen
            Lin的个人网站为：<a href="http://www.csie.ntu.edu.tw/~cjlin/index.html" rel="nofollow">Welcome to Chih-Jen Lin’s
                Home Page</a></p>

        <p>下面我们再来回顾一下Soft-Margin SVM的主要内容。我们的出发点是用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40ba8a7a08940acca1b2724689177103.jpg" />来表示margin
            violation，即犯错值的大小，没有犯错对应的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d969059c4983d25c5a8efdf9836ae4f7.jpg" />。然后将有条件问题转化为对偶dual形式，使用QP来得到最佳化的解。</p>

        <p>从另外一个角度来看，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40ba8a7a08940acca1b2724689177103.jpg" />描述的是点<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52044980121cb72960d9993d9e8fb1b2.jpg" />
            距离<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/668d079f15a25b2346fa69e0ee7d687a.jpg" />的边界有多远。第一种情况是violating margin，即不满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/66e5ed753716931de3f56d86041f66d7.jpg" />。那么<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40ba8a7a08940acca1b2724689177103.jpg" />可表示为：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2251ce66b0ff9c1ad3941bedfccdda7d.jpg" />。第二种情况是not
            violating margin，即点<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52044980121cb72960d9993d9e8fb1b2.jpg" /> 在边界之外，满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/66e5ed753716931de3f56d86041f66d7.jpg" />的条件，此时<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d969059c4983d25c5a8efdf9836ae4f7.jpg" />。我们可以将两种情况整合到一个表达式中，对任意点：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2a39e484eaad8e0af9aa2a527b463cc2.jpg" /></p>

        <p>上式表明，如果有voilating margin，则<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9c4e321dfac7f03a5b49b0b759b69d00.jpg" />，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d3498fd194d10947d8be76c9bc743415.jpg" />；如果not
            violating margin，则<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ec1c53c8025a2f40ffa4b05981140cb2.jpg" />，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d969059c4983d25c5a8efdf9836ae4f7.jpg" />。整合之后，我们可以把Soft-Margin
            SVM的最小化问题写成如下形式：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1df897d1794ad84929aa7a9575311c33.jpg" /></p>

        <p>经过这种转换之后，表征犯错误值大小的变量<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40ba8a7a08940acca1b2724689177103.jpg" />就被消去了，转而由一个max操作代替。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/22022484722a50950e533476eea5b922.jpg" alt="这里写图片描述" title="" /></p>

        <p>为什么要将把Soft-Margin SVM转换为这种unconstrained form呢？我们再来看一下转换后的形式，其中包含两项，第一项是w的内积，第二项关于y和w，b，z的表达式，似乎有点像一种错误估计<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc71999918264fdf4c6f8b43cc1b0da8.jpg" />，则类似这样的形式：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9e857c41a4fadfeff8a455c311c9a504.jpg" /></p>

        <p>看到这样的形式我们应该很熟悉，因为之前介绍的L2 Regularization中最优化问题的表达式跟这个是类似的：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8807a6d83bd711592de5b9036786336e.jpg" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1983ca072a724523f7f2e7774a3231f0.jpg" alt="这里写图片描述" title="" /></p>

        <p>这里提一下，既然unconstrained form SVM与L2 Regularization的形式是一致的，而且L2
            Regularization的解法我们之前也介绍过，那么为什么不直接利用这种方法来解决unconstrained form
            SVM的问题呢？有两个原因。一个是这种无条件的最优化问题无法通过QP解决，即对偶推导和kernel都无法使用；另一个是这种形式中包含的max()项可能造成函数并不是处处可导，这种情况难以用微分方法解决。</p>

        <p>我们在第一节课中就介绍过Hard-Margin SVM与Regularization Model是有关系的。Regularization的目标是最小化<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />，条件是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b6d200f980aaa3ee660d804911e853cc.jpg" />，而Hard-Margin SVM的目标是最小化<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/67f16bf9eedca78b8c35cf58f249f43e.jpg" />，条件是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8979e87b0fb1d13fdfaad13dcfe4638b.jpg" />，即它们的最小化目标和限制条件是相互对调的。对于L2
            Regularization来说，条件和最优化问题结合起来，整体形式写成：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1a87cc76b04ea9e2eed3fde6d4f07ca4.jpg" /></p>

        <p>而对于Soft-Margin SVM来说，条件和最优化问题结合起来，整体形式写成：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4c8f239d3c833c294d568fcd984de84e.jpg" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4259d5ad217cf008dede89718654a3d.jpg" alt="这里写图片描述" title="" /></p>

        <p>通过对比，我们发现L2 Regularization和Soft-Margin SVM的形式是相同的，两个式子分别包含了参数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" />和C。Soft-Margin
            SVM中的large margin对应着L2 Regularization中的short w，也就是都让hyperplanes更简单一些。我们使用特别的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc71999918264fdf4c6f8b43cc1b0da8.jpg" />来代表可以容忍犯错误的程度，即soft
            margin。L2 Regularization中的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" />和Soft-Margin
            SVM中的C也是相互对应的，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" />越大，w会越小，Regularization的程度就越大；C越小，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a3ed3e66830e0500d8c8dce7807e3dd0.jpg" />会越大，相应的margin就越大。所以说增大C，或者减小<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" />，效果是一致的，Large-Margin等同于Regularization，都起到了防止过拟合的作用。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b9c9c9ac6bdfe368062669bc53833ed4.jpg" alt="这里写图片描述" title="" /></p>

        <p>建立了Regularization和Soft-Margin SVM的关系，接下来我们将尝试看看是否能把SVM作为一个regularized的模型进行扩展，来解决其它一些问题。</p>

        <h3 id="svm-versus-logistic-regression" class="sigil_not_in_toc"><strong>SVM versus Logistic Regression</strong></h3>

        <p>上一小节，我们已经把Soft-Margin SVM转换成无条件的形式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/551f674063ed8eb847ae4010bf2d8d0a.jpg" alt="这里写图片描述" title="" /></p>

        <p>上式中第二项的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3b33e620f3e7e1ad5e0f10dfe2364f3c.jpg" />倍设置为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc71999918264fdf4c6f8b43cc1b0da8.jpg" />。下面我们来看看<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc71999918264fdf4c6f8b43cc1b0da8.jpg" />与之前再二元分类中介绍过的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0d4404e1539902fe8ce92517b1d05855.jpg" />有什么关系。</p>

        <p>对于<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0d4404e1539902fe8ce92517b1d05855.jpg" />，它的linear score <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6adf110316ae106f7cf080db1c8339d3.jpg" />，当<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fa8cf825e08e00c564eb12347ad5bc20.jpg" />时，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a9e6115d6ac3e822fa95762e17389549.jpg" />；当<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/504bb2d6e247559b0ce0811a8f70015d.jpg" />时，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/58b16d0edb128d309537fa9cd8ae8b35.jpg" />，呈阶梯状，如下图所示。而对于<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc71999918264fdf4c6f8b43cc1b0da8.jpg" />，当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fa8cf825e08e00c564eb12347ad5bc20.jpg" />时，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a9e6115d6ac3e822fa95762e17389549.jpg" />；当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/504bb2d6e247559b0ce0811a8f70015d.jpg" />时，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dffb31c0820734d358ed44c5ebb80f7f.jpg" />，呈折线状，如下图所示，通常把<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0bb351e8ef768cd1a171f23bc432510c.jpg" />称为hinge
            error measure。比较两条error曲线，我们发现<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0bb351e8ef768cd1a171f23bc432510c.jpg" />始终在<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0d4404e1539902fe8ce92517b1d05855.jpg" />的上面，则<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0bb351e8ef768cd1a171f23bc432510c.jpg" />可作为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0d4404e1539902fe8ce92517b1d05855.jpg" />的上界。所以，可以使用<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0bb351e8ef768cd1a171f23bc432510c.jpg" />来代替<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0d4404e1539902fe8ce92517b1d05855.jpg" />，解决二元线性分类问题，而且<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0bb351e8ef768cd1a171f23bc432510c.jpg" />是一个凸函数，使它在最佳化问题中有更好的性质。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d5d2d07c061dd809a3236abe8d376509.jpg" alt="这里写图片描述" title="" /></p>

        <p>紧接着，我们再来看一下logistic regression中的error function。逻辑回归中，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/79bc69f92fa4c94298b11e0017d998e6.jpg" />，当ys=0时，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/38c125969f70cb5d714189a57aa0cf5b.jpg" />。它的err曲线如下所示。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d22af6f5931e0dc22a1610c350bc8825.jpg" alt="这里写图片描述" title="" /></p>

        <p>很明显，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3dc0011276ed445899d9099575fd13ff.jpg" />也是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0d4404e1539902fe8ce92517b1d05855.jpg" />的上界，而<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3dc0011276ed445899d9099575fd13ff.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0bb351e8ef768cd1a171f23bc432510c.jpg" />也是比较相近的。因为当ys趋向正无穷大的时候，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3dc0011276ed445899d9099575fd13ff.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0bb351e8ef768cd1a171f23bc432510c.jpg" />都趋向于零；当ys趋向负无穷大的时候，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3dc0011276ed445899d9099575fd13ff.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0bb351e8ef768cd1a171f23bc432510c.jpg" />都趋向于正无穷大。正因为二者的这种相似性，我们可以把SVM看成是L2-regularized
            logistic regression。</p>

        <p>总结一下，我们已经介绍过几种Binary Classification的Linear Models，包括PLA，Logistic Regression和Soft-Margin
            SVM。PLA是相对简单的一个模型，对应的是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0d4404e1539902fe8ce92517b1d05855.jpg" />，通过不断修正错误的点来获得最佳分类线。它的优点是简单快速，缺点是只对线性可分的情况有用，线性不可分的情况需要用到pocket算法。Logistic
            Regression对应的是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3dc0011276ed445899d9099575fd13ff.jpg" />，通常使用GD/SGD算法求解最佳分类线。它的优点是凸函数<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3dc0011276ed445899d9099575fd13ff.jpg" />便于最优化求解，而且有regularization作为避免过拟合的保证；缺点是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3dc0011276ed445899d9099575fd13ff.jpg" />作为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0d4404e1539902fe8ce92517b1d05855.jpg" />的上界，当ys很小（负值）时，上界变得更宽松，不利于最优化求解。Soft-Margin
            SVM对应的是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0bb351e8ef768cd1a171f23bc432510c.jpg" />，通常使用QP求解最佳分类线。它的优点和Logistic
            Regression一样，凸优化问题计算简单而且分类线比较“粗壮”一些；缺点也和Logistic Regression一样，当ys很小（负值）时，上界变得过于宽松。其实，Logistic
            Regression和Soft-Margin SVM都是在最佳化<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0d4404e1539902fe8ce92517b1d05855.jpg" />的上界而已。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3322f39556d1a72963a90e58c6621e5b.jpg" alt="这里写图片描述" title="" /></p>

        <p>至此，可以看出，求解regularized logistic regression的问题等同于求解soft-margin SVM的问题。反过来，如果我们求解了一个soft-margin
            SVM的问题，那这个解能否直接为regularized logistic regression所用？来预测结果是正类的几率是多少，就像regularized logistic
            regression做的一样。我们下一小节将来解答这个问题。</p>

        <h3 id="svm-for-soft-binary-classification" class="sigil_not_in_toc"><strong>SVM for Soft Binary Classification</strong></h3>

        <p>接下来，我们探讨如何将SVM的结果应用在Soft Binary Classification中，得到是正类的概率值。</p>

        <p>第一种简单的方法是先得到SVM的解<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/21c090cbde0f030fe514f06cf94292a2.jpg" />，然后直接代入到logistic regression中，得到<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a17e6f6b95a4cdf420c343e1dbae61de.jpg" />。这种方法直接使用了SVM和logistic
            regression的相似性，一般情况下表现还不错。但是，这种形式过于简单，与logistic regression的关联不大，没有使用到logistic regression中好的性质和方法。</p>

        <p>第二种简单的方法是同样先得到SVM的解<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/21c090cbde0f030fe514f06cf94292a2.jpg" />，然后把<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/21c090cbde0f030fe514f06cf94292a2.jpg" />作为logistic
            regression的初始值，再进行迭代训练修正，速度比较快，最后，将得到的b和w代入到g(x)中。这种做法有点显得多此一举，因为并没有比直接使用logistic regression快捷多少。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/00a2c88098351af8705a7c89643ccec3.jpg" alt="这里写图片描述" title="" /></p>

        <p>这两种方法都没有融合SVM和logistic regression各自的优势，下面构造一个模型，融合了二者的优势。构造的模型g(x)表达式为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cf94ea69abf41ff92d7ceaceba8b55c3.jpg" /></p>

        <p>与上述第一种简单方法不同，我们额外增加了放缩因子A和平移因子B。首先利用SVM的解<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/21c090cbde0f030fe514f06cf94292a2.jpg" />来构造这个模型，放缩因子A和平移因子B是待定系数。然后再用通用的logistic
            regression优化算法，通过迭代优化，得到最终的A和B。一般来说，如果<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/21c090cbde0f030fe514f06cf94292a2.jpg" />较为合理的话，满足A&gt;0且<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/88c4ad898f784ba8c70dc1c34235ab9b.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3fa7a08dbc8f9b592e33564a02307f66.jpg" alt="这里写图片描述" title="" /></p>

        <p>那么，新的logistic regression表达式为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/82b634ec10994d5bb27f86363f0512f6.jpg" alt="这里写图片描述" title="" /></p>

        <p>这个表达式看上去很复杂，其实其中的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/21c090cbde0f030fe514f06cf94292a2.jpg" />已经在SVM中解出来了，实际上的未知参数只有A和B两个。归纳一下，这种Probabilistic
            SVM的做法分为三个步骤：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d4c477e712460d2156b64c777662ad5e.jpg" alt="这里写图片描述" title="" /></p>

        <p>这种soft binary classifier方法得到的结果跟直接使用SVM classifier得到的结果可能不一样，这是因为我们引入了系数A和B。一般来说，soft binary
            classifier效果更好。至于logistic regression的解法，可以选择GD、SGD等等。</p>

        <h3 id="kernel-logistic-regression" class="sigil_not_in_toc"><strong>Kernel Logistic Regression</strong></h3>

        <p>上一小节我们介绍的是通过kernel SVM在z空间中求得logistic regression的近似解。如果我们希望直接在z空间中直接求解logistic
            regression，通过引入kernel，来解决最优化问题，又该怎么做呢？SVM中使用kernel，转化为QP问题，进行求解，但是logistic
            regression却不是个QP问题，看似好像没有办法利用kernel来解决。</p>

        <p>我们先来看看之前介绍的kernel trick为什么会work，kernel trick就是把z空间的内积转换到x空间中比较容易计算的函数。如果w可以表示为z的线性组合，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b370377b17116dc182f19d66abb75aca.jpg" />的形式，那么乘积项<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/751948c744568bb764c060e8082c58a2.jpg" />，即其中包含了z的内积。也就是w可以表示为z的线性组合是kernel
            trick可以work的关键。</p>

        <p>我们之前介绍过SVM、PLA包扩logistic regression都可以表示成z的线性组合，这也提供了一种可能，就是将kernel应用到这些问题中去，简化z空间的计算难度。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2136a1d71ba6ee072f47c2ce1f16d978.jpg" alt="这里写图片描述" title="" /></p>

        <p>有这样一个理论，对于L2-regularized linear model，如果它的最小化问题形式为如下的话，那么最优解<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b370377b17116dc182f19d66abb75aca.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5ab4fee12ef5b0f76121e35f5a1a5b54.jpg" alt="这里写图片描述" title="" /></p>

        <p>下面给出简单的证明，假如最优解<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7463cf6e4a8d5ca721bbe27a7f0be5fa.jpg" />。其中，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f40180f9234bfd4fd69a41b9f0308d49.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cc6a25f36861346bf4ca4ea2961f4c19.jpg" />分别是平行z空间和垂直z空间的部分。我们需要证明的是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e715fe43cb01aaf25f084423f12b85bd.jpg" />。利用反证法，假如<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5658f511d2c1d3af68dd5478bf61d03a.jpg" />，考虑<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/97a81baf24896a43ef27a8abfdfcaadf.jpg" />与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f40180f9234bfd4fd69a41b9f0308d49.jpg" />的比较。第一步先比较最小化问题的第二项：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cdfb289511b089086925bcdb2fe016f9.jpg" />，即第二项是相等的。然后第二步比较第一项：<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fa406e26e230e699e5ff02dde6965283.jpg" />，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/97a81baf24896a43ef27a8abfdfcaadf.jpg" />对应的L2-regularized
            linear model值要比<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f40180f9234bfd4fd69a41b9f0308d49.jpg" />大，这就说明<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/97a81baf24896a43ef27a8abfdfcaadf.jpg" />并不是最优解，从而证明<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cc6a25f36861346bf4ca4ea2961f4c19.jpg" />必然等于零，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b370377b17116dc182f19d66abb75aca.jpg" />一定成立，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/97a81baf24896a43ef27a8abfdfcaadf.jpg" />一定可以写成z的线性组合形式。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dee64aab5a6c5039d05948337446b439.jpg" alt="这里写图片描述" title="" /></p>

        <p>经过证明和分析，我们得到了结论是任何L2-regularized linear model都可以使用kernel来解决。</p>

        <p>现在，我们来看看如何把kernel应用在L2-regularized logistic regression上。上面我们已经证明了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/97a81baf24896a43ef27a8abfdfcaadf.jpg" />一定可以写成z的线性组合形式，即<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b370377b17116dc182f19d66abb75aca.jpg" />。那么我们就无需一定求出<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/97a81baf24896a43ef27a8abfdfcaadf.jpg" />，而只要求出其中的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a5240d5e29bc269362ba121cb320f46f.jpg" />就行了。怎么求呢？直接将<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b370377b17116dc182f19d66abb75aca.jpg" />代入到L2-regularized
            logistic regression最小化问题中，得到：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/05529db25e358d0310213bb1f2e1e6b6.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/22866b1f665ae3e917acd0e49d666f0d.jpg" alt="这里写图片描述" title="" /></p>

        <p>上式中，所有的w项都换成<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a5240d5e29bc269362ba121cb320f46f.jpg" />来表示了，变成了没有条件限制的最优化问题。我们把这种问题称为kernel
            logistic regression，即引入kernel，将求w的问题转换为求<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a5240d5e29bc269362ba121cb320f46f.jpg" />的问题。</p>

        <p>从另外一个角度来看Kernel Logistic Regression（KLR）：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3b0fc619602bed4b47a26933090b2b5d.jpg" alt="这里写图片描述" title="" /></p>

        <p>上式中log项里的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/eb79d32b43ea2c2b70fb03b9e0911f45.jpg" />可以看成是变量<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/08499d5d5fdfd58d4051531aec59a134.jpg" />的内积。上式第一项中的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9e9f752496796b73cb19a862746526fe.jpg" />可以看成是关于<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />的正则化项<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7a359a11e06367426c823fe2a84e2a1a.jpg" />。所以，KLR是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />的线性组合，其中包含了kernel内积项和kernel
            regularizer。这与SVM是相似的形式。</p>

        <p>但值得一提的是，KLR中的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a5240d5e29bc269362ba121cb320f46f.jpg" />与SVM中的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />是有区别的。SVM中的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />大部分为零，SV的个数通常是比较少的；而KLR中的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a5240d5e29bc269362ba121cb320f46f.jpg" />通常都是非零值。</p>

        <h3 id="总结" class="sigil_not_in_toc"><strong>总结</strong></h3>

        <p>本节课主要介绍了Kernel Logistic Regression。首先把Soft-Margin SVM解释成Regularized Model，建立二者之间的联系，其实Soft-Margin
            SVM就是一个L2-regularization，对应着hinge error messure。然后利用它们之间的相似性，讨论了如何利用SVM的解来得到Soft Binary
            Classification。方法是先得到SVM的解，再在logistic regression中引入参数A和B，迭代训练，得到最佳解。最后介绍了Kernel Logistic
            Regression，证明L2-regularized logistic regression中，最佳解<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/97a81baf24896a43ef27a8abfdfcaadf.jpg" />一定可以写成z的线性组合形式，从而可以将kernel引入logistic
            regression中，使用kernel思想在z空间直接求解L2-regularized logistic regression问题。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习技法》课程</p>

        <p><strong>更多AI资源请关注公众号：红色石头的机器学习之路（ID：redstonewill）</strong> <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6db1c865a22e7ec22a97bab0828b8c23.jpg" alt="这里写图片描述" title="" /></p>
    </div>

    <h1 class="title-article">6 -- Support Vector Regression</h1>
    <div class="markdown_views">
        <blockquote>
            <p>红色石头的个人网站：<a href="http://redstonewill.com/" rel="nofollow">redstonewill.com</a></p>
        </blockquote>

        <p>上节课我们主要介绍了Kernel Logistic Regression，讨论如何把SVM的技巧应用在soft-binary classification上。方法是使用2-level
            learning，先利用SVM得到参数b和w，然后再用通用的logistic regression优化算法，通过迭代优化，对参数b和w进行微调，得到最佳解。然后，也介绍了可以通过Representer
            Theorem，在z空间中，引入SVM的kernel技巧，直接对logistic regression进行求解。本节课将延伸上节课的内容，讨论如何将SVM的kernel技巧应用到regression问题上。</p>

        <h3 id="kernel-ridge-regression" class="sigil_not_in_toc"><strong>Kernel Ridge Regression</strong></h3>

        <p>首先回顾一下上节课介绍的Representer Theorem，对于任何包含正则项的L2-regularized linear
            model，它的最佳化解w都可以写成是z的线性组合形式，因此，也就能引入kernel技巧，将模型kernelized化。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/060590b97ee2059cad9798d428b3eff1.jpg" alt="这里写图片描述" title="" /></p>

        <p>那么如何将regression模型变成kernel的形式呢？我们之前介绍的linear/ridge regression最常用的错误估计是squared error，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ad5b9b58e08b25d68583b29b46c38e59.jpg" />。这种形式对应的解是analytic
            solution，即可以使用线性最小二乘法，通过向量运算，直接得到最优化解。那么接下来我们就要研究如何将kernel引入到ridge regression中去，得到与之对应的analytic solution。</p>

        <p>我们先把Kernel Ridge Regression问题写下来：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/81d99816213c14a0f916776f85633bf5.jpg" alt="这里写图片描述" title="" /></p>

        <p>其中，最佳解<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/97a81baf24896a43ef27a8abfdfcaadf.jpg" />必然是z的线性组合。那么我们就把<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b370377b17116dc182f19d66abb75aca.jpg" />代入到ridge
            regression中，将z的内积用kernel替换，把求<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/97a81baf24896a43ef27a8abfdfcaadf.jpg" />的问题转化成求<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a5240d5e29bc269362ba121cb320f46f.jpg" />的问题，得到：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0a2cf6b48562fc9ab74dbc2acaa82188.jpg" alt="这里写图片描述" title="" /></p>

        <p>ridge regression可以写成矩阵的形式，其中第一项可以看成是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a5240d5e29bc269362ba121cb320f46f.jpg" />的正则项，而第二项可以看成是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a5240d5e29bc269362ba121cb320f46f.jpg" />的error function。这样，我们的目的就是求解该式最小化对应的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a5240d5e29bc269362ba121cb320f46f.jpg" />值，这样就解决了kernel
            ridge regression问题。</p>

        <p>求解<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a5240d5e29bc269362ba121cb320f46f.jpg" />的问题可以写成如下形式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9d796fb3613f4198a41cad4d878eb093.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d91a95cfe6fa49447756f9ffe1a6741f.jpg" />是关于<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />的二次多项式，要对<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d91a95cfe6fa49447756f9ffe1a6741f.jpg" />求最小化解，这种凸二次最优化问题，只需要先计算其梯度，再令梯度为零即可。<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bcdcd011ce8e9f68a1a55d85951f51ae.jpg" />已经在上式中写出来了，令其等于零，即可得到一种可能的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />的解析解为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e5b2558963bce1114a1960ef67ffb85a.jpg" /></p>

        <p>这里需要关心的问题是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4fefa966dd7aaa33b3b7fce14ffaf837.jpg" />的逆矩阵是否存在？答案是肯定的。因为我们之前介绍过，核函数K满足Mercer’s
            condition，它是半正定的，而且<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6f23e0bd8afd177f220927e176d3999c.jpg" />，所以<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4fefa966dd7aaa33b3b7fce14ffaf837.jpg" />一定是可逆的。从计算的时间复杂上来说，由于<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4fefa966dd7aaa33b3b7fce14ffaf837.jpg" />是NxN大小的，所以时间复杂度是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/93775cb4be1692e2bc4c1149edf2c3cc.jpg" />。还有一点，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bcdcd011ce8e9f68a1a55d85951f51ae.jpg" />是由两项乘积构成的，另一项是K，会不会出现K=0的情况呢？其实，由于核函数K表征的是z空间的内积，一般而言，除非两个向量互相垂直，内积才为零，否则，一般情况下K不等于零。这个原因也决定了<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4fefa966dd7aaa33b3b7fce14ffaf837.jpg" />是dense matrix，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />的解大部分都是非零值。这个性质，我们之后还会说明。</p>

        <p>所以说，我们可以通过kernel来解决non-linear regression的问题。下面比较一下linear ridge regression和kernel ridge regression的关系。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5821fe52e06d6f4be1f69865fce59c06.jpg" alt="这里写图片描述" title="" /></p>

        <p>如上图所示，左边是linear ridge regression，是一条直线；右边是kernel ridge
            regression，是一条曲线。大致比较一下，右边的曲线拟合的效果更好一些。这两种regression有什么样的优点和缺点呢？对于linear ridge
            regression来说，它是线性模型，只能拟合直线；其次，它的训练复杂度是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/413d162f9d88d243ed56ddc35574b553.jpg" />，预测的复杂度是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4a9f1eb59e9aca78102049c3006b6fbe.jpg" />，如果N比d大很多时，这种模型就更有效率。而对于kernel ridge
            regression来说，它转换到z空间，使用kernel技巧，得到的是非线性模型，所以更加灵活；其次，它的训练复杂度是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/93775cb4be1692e2bc4c1149edf2c3cc.jpg" />，预测的复杂度是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7aa2a71c820bb752a08fa8f58b0004ee.jpg" />，均只与N有关。当N很大的时候，计算量就很大，所以，kernel ridge
            regression适合N不是很大的场合。比较下来，可以说linear和kernel实际上是效率（efficiency）和灵活（flexibility）之间的权衡。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a600cd0154598bb8d24f2bd53b9c345c.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="support-vector-regression-primal" class="sigil_not_in_toc"><strong>Support Vector Regression Primal</strong></h3>

        <p>我们在机器学习基石课程中介绍过linear regression可以用来做classification，那么上一部分介绍的kernel ridge
            regression同样可以来做classification。我们把kernel ridge regression应用在classification上取个新的名字，叫做least-squares
            SVM（LSSVM）。</p>

        <p>先来看一下对于某个问题，soft-margin Gaussian SVM和Gaussian LSSVM结果有哪些不一样的地方。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ca6bf991cd63def6ee0d9ea01c38151b.jpg" alt="这里写图片描述" title="" /></p>

        <p>如上图所示，如果只看分类边界的话，soft-margin Gaussian SVM和Gaussian LSSVM差别不是很大，即的到的分类线是几乎相同的。但是如果看Support
            Vector的话（图中方框标注的点），左边soft-margin Gaussian SVM的SV不多，而右边Gaussian LSSVM中基本上每个点都是SV。这是因为soft-margin Gaussian
            SVM中的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />大部分是等于零，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0f2f3d44c78ed4dcb95ac1c35a8a1ba8.jpg" />的点只占少数，所以SV少。而对于LSSVM，我们上一部分介绍了<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />的解大部分都是非零值，所以对应的每个点基本上都是SV。SV太多会带来一个问题，就是做预测的矩<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8204a79ba5eff683228758b6498cc270.jpg" />，如果<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a5240d5e29bc269362ba121cb320f46f.jpg" />非零值较多，那么g的计算量也比较大，降低计算速度。基于这个原因，soft-margin
            Gaussian SVM更有优势。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1965942b852ad0c55d40c78c11e0d1de.jpg" alt="这里写图片描述" title="" /></p>

        <p>那么，针对LSSVM中dense <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />的缺点，我们能不能使用一些方法来的得到sparse <img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />，使得SV不会太多，从而得到和soft-margin
            SVM同样的分类效果呢？下面我们将尝试解决这个问题。</p>

        <p>方法是引入一个叫做Tube Regression的做法，即在分类线上下分别划定一个区域（中立区），如果数据点分布在这个区域内，则不算分类错误，只有误分在中立区域之外的地方才算error。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5ab9412b0525bd48d0ddbac46ff64aa3.jpg" alt="这里写图片描述" title="" /></p>

        <p>假定中立区的宽度为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a506b7d1584dc28109b0adf6c88e06cb.jpg" />，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5c9d41f0b7c0a47f67551fa45a3cedf6.jpg" />,那么error
            measure就可以写成：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f0cadf2ef354422f932ff9d2fb1061f0.jpg" />，对应上图中红色标注的距离。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ea656564185e456d25461d24cda5c001.jpg" alt="这里写图片描述" title="" /></p>

        <p>通常把这个error叫做<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aeb302325ebc29add21f094ad38ad261.jpg" />-insensitive
            error，这种max的形式跟我们上节课中介绍的hinge error measure形式其实是类似的。所以，我们接下来要做的事情就是将L2-regularized tube
            regression做类似于soft-margin SVM的推导，从而得到sparse <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />。</p>

        <p>首先，我们把tube regression中的error与squared error做个比较：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8ff0de3b2e13cfaf2e4e5cb0591f034e.jpg" alt="这里写图片描述" title="" /></p>

        <p>然后，将err(y,s)与s的关系曲线分别画出来：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f7ca93639d8775d1575a78e609521d75.jpg" alt="这里写图片描述" title="" /></p>

        <p>上图中，红色的线表示squared error，蓝色的线表示tube error。我们发现，当|s-y|比较小即s比较接近y的时候，squared error与tube
            error是差不多大小的。而在|s-y|比较大的区域，squared error的增长幅度要比tube
            error大很多。error的增长幅度越大，表示越容易受到noise的影响，不利于最优化问题的求解。所以，从这个方面来看，tube regression的这种error function要更好一些。</p>

        <p>现在，我们把L2-Regularized Tube Regression写下来：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3aa122503da3aa7903c36eee0d50d6cf.jpg" alt="这里写图片描述" title="" /></p>

        <p>这个最优化问题，由于其中包含max项，并不是处处可微分的，所以不适合用GD/SGD来求解。而且，虽然满足representer theorem，有可能通过引入kernel来求解，但是也并不能保证得到sparsity
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />。从另一方面考虑，我们可以把这个问题转换为带条件的QP问题，仿照dual
            SVM的推导方法，引入kernel，得到KKT条件，从而保证解<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />是sparse的。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f437c8ef60284419ff269ec59259d240.jpg" alt="这里写图片描述" title="" /></p>

        <p>所以，我们就可以把L2-Regularized Tube Regression写成跟SVM类似的形式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d4cc11afca9685b98b918db9e3f075f2.jpg" alt="这里写图片描述" title="" /></p>

        <p>值得一提的是，系数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" />和C是反比例相关的，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" />越大对应C越小，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" />越小对应C越大。而且该式也把<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ba3c75638c442d45dd1986e37b37fd7e.jpg" />即b单独拿了出来，这跟我们之前推导SVM的解的方法是一致的。</p>

        <p>现在我们已经有了Standard Support Vector Regression的初始形式，这还是不是一个标准的QP问题。我们继续对该表达式做一些转化和推导：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/da65a8d9efbed5309ee35a0422abffc7.jpg" alt="这里写图片描述" title="" /></p>

        <p>如上图右边所示，即为标准的QP问题，其中<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5406cf2c31a4da9b7abb2df48a87d960.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27d3f00722391d919a690e26c7cbe699.jpg" />分别表示upper
            tube violations和lower tube violations。这种形式叫做Support Vector Regression（SVR） primal。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a28ce12619819c176e6d7c0f1a76126.jpg" alt="这里写图片描述" title="" /></p>

        <p>SVR的标准QP形式包含几个重要的参数：C和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aeb302325ebc29add21f094ad38ad261.jpg" />。C表示的是regularization和tube
            violation之间的权衡。large C倾向于tube violation，small C则倾向于regularization。<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aeb302325ebc29add21f094ad38ad261.jpg" />表征了tube的区域宽度，即对错误点的容忍程度。<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aeb302325ebc29add21f094ad38ad261.jpg" />越大，则表示对错误的容忍度越大。<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aeb302325ebc29add21f094ad38ad261.jpg" />是可设置的常数，是SVR问题中独有的，SVM中没有这个参数。另外，SVR的QP形式共有<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cb1fb1dc0827dbc7413078d6e5888c10.jpg" />个参数，2N+2N个条件。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1ebbc1e80e49e5ca9a4b33e72a508b29.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="support-vector-regression-dual" class="sigil_not_in_toc"><strong>Support Vector Regression Dual</strong></h3>

        <p>现在我们已经得到了SVR的primal形式，接下来将推导SVR的Dual形式。首先，与SVM对偶形式一样，先令拉格朗日因子<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3a92c9b445e3709b49b755d6c4b2eed6.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/45a637768b9f40a9c9c42f141a3418f7.jpg" />，分别是与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5406cf2c31a4da9b7abb2df48a87d960.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27d3f00722391d919a690e26c7cbe699.jpg" />不等式相对应。这里忽略了与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d34778f36649b4750a1ac61790de366c.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4061555cb56432763974dc3d01960740.jpg" />对应的拉格朗日因子。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ceab7ff3f86cc99e69cc6d54f3afc7ec.jpg" alt="这里写图片描述" title="" /></p>

        <p>然后，与SVM一样做同样的推导和化简，拉格朗日函数对相关参数偏微分为零，得到相应的KKT条件：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3810abe2c67b7e167ce9697ddfbaa03e.jpg" alt="这里写图片描述" title="" /></p>

        <p>接下来，通过观察SVM primal与SVM dual的参数对应关系，直接从SVR primal推导出SVR dual的形式。（具体数学推导，此处忽略！）</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d1bbc5fba77ee3de9e160939dabf1a1e.jpg" alt="这里写图片描述" title="" /></p>

        <p>最后，我们就要来讨论一下SVR的解是否真的是sparse的。前面已经推导了SVR dual形式下推导的解w为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f791efb20fcae4bd99d171b32d3c603b.jpg" /></p>

        <p>相应的complementary slackness为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4df38d73e998f77abba059625717c1c7.jpg" alt="这里写图片描述" title="" /></p>

        <p>对于分布在tube中心区域内的点，满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ded4c927e0dddb7241d48d5d3ccc1c09.jpg" />，此时忽略错误，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5406cf2c31a4da9b7abb2df48a87d960.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27d3f00722391d919a690e26c7cbe699.jpg" />都等于零。则complementary slackness两个等式的第二项均不为零，必然得到<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/26ec4cc726b7ead02050c93e83aa4f03.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6cc7f490c81a04d8a866f021e795e839.jpg" />，即<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1aec635501f84b3cb5ad8ae38a270f99.jpg" />。</p>

        <p>所以，对于分布在tube内的点，得到的解<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/050a3d46436659c60c6cd204a732a855.jpg" />，是sparse的。而分布在tube之外的点，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/866da8a66cc7e1d6364783081e94934e.jpg" />。至此，我们就得到了SVR的sparse解。</p>

        <h3 id="summary-of-kernel-models" class="sigil_not_in_toc"><strong>Summary of Kernel Models</strong></h3>

        <p>这部分将对我们介绍过的所有的kernel模型做个概括和总结。我们总共介绍过三种线性模型，分别是PLA/pocket，regularized logistic regression和linear ridge
            regression。这三种模型都可以使用国立台湾大学的Chih-Jen Lin博士开发的Liblinear库函数来解决。</p>

        <p>另外，我们介绍了linear soft-margin SVM，其中的error function是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0bb351e8ef768cd1a171f23bc432510c.jpg" />，可以通过标准的QP问题来求解。linear
            soft-margin SVM和PLA/pocket一样都是解决同样的问题。然后，还介绍了linear SVR问题，它与linear ridge regression一样都是解决同样的问题，从SVM的角度，使用<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/28942c6033f66ae4558e1fea940f8c4e.jpg" />，转换为QP问题进行求解，这也是我们本节课的主要内容。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9b91b6794d7f76c87b67b1614ff0d4a4.jpg" alt="这里写图片描述" title="" /></p>

        <p>上图中相应的模型也可以转化为dual形式，引入kernel，整体的框图如下：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/53e8f824ffe8a7200869fb713bcb0462.jpg" alt="这里写图片描述" title="" /></p>

        <p>其中SVM，SVR和probabilistic SVM都可以使用国立台湾大学的Chih-Jen Lin博士开发的LLibsvm库函数来解决。通常来说，这些模型中SVR和probabilistic SVM最为常用。</p>

        <h3 id="总结" class="sigil_not_in_toc"><strong>总结</strong></h3>

        <p>本节课主要介绍了SVR，我们先通过representer theorem理论，将ridge regression转化为kernel的形式，即kernel ridge
            regression，并推导了SVR的解。但是得到的解是dense的，大部分为非零值。所以，我们定义新的tube regression，使用SVM的推导方法，来最小化regularized tube
            errors，转化为对偶形式，得到了sparse的解。最后，我们对介绍过的所有kernel模型做个总结，简单概述了各自的特点。在实际应用中，我们要根据不同的问题进行合适的模型选择。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习技法》课程</p>

        <p><strong>更多AI资源请关注公众号：红色石头的机器学习之路（ID：redstonewill）</strong> <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/014b482be6adc6e71825bbb09c51b7c3.jpg" alt="这里写图片描述" title="" /></p>
    </div>

    <h1 class="title-article">7 -- Blending and Bagging</h1>
    <div class="markdown_views">
        <blockquote>
            <p>红色石头的个人网站：<a href="http://redstonewill.com/" rel="nofollow">redstonewill.com</a></p>
        </blockquote>

        <p>上节课我们主要介绍了Support Vector Regression，将kernel model引入到regression中。首先，通过将ridge regression和representer
            theorem结合起来，得到kernel ridge regression。但是其解是dense的，即不部分不为零。为了得到sparse解，我们将regularized tube error和Lagrange
            dual结合起来，利用SVM dual的推导方法，得到support vector regression的sparse解。本系列1-6节课主要介绍Kernel
            Models及其应用，从本节课开始，讲介绍Aggregation
            Models，即如何将不同的hypothesis和features结合起来，让模型更好。本节课将介绍其中的两个方法，一个是Blending，一个是Bagging。</p>

        <h3 id="motivation-of-aggregation" class="sigil_not_in_toc"><strong>Motivation of Aggregation</strong></h3>

        <p>首先举个例子来说明为什么要使用Aggregation。假如你有T个朋友，每个朋友向你预测推荐明天某支股票会涨还是会跌，对应的建议分别是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f36f6543b9a61f4640f0454948e65b73.jpg" />，那么你该选择哪个朋友的建议呢？即最终选择对股票预测的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4131ab539ff96aa53dce85b56410010.jpg" />是什么样的？</p>

        <p>第一种方法是从T个朋友中选择一个最受信任，对股票预测能力最强的人，直接听从他的建议就好。这是一种普遍的做法，对应的就是validation思想，即选择犯错误最小的模型。第二种方法，如果每个朋友在股票预测方面都是比较厉害的，都有各自的专长，那么就同时考虑T个朋友的建议，将所有结果做个投票，一人一票，最终决定出对该支股票的预测。这种方法对应的是uniformly思想。第三种方法，如果每个朋友水平不一，有的比较厉害，投票比重应该更大一些，有的比较差，投票比重应该更小一些。那么，仍然对T个朋友进行投票，只是每个人的投票权重不同。这种方法对应的是non-uniformly的思想。第四种方法与第三种方法类似，但是权重不是固定的，根据不同的条件，给予不同的权重。比如如果是传统行业的股票，那么给这方面比较厉害的朋友较高的投票权重，如果是服务行业，那么就给这方面比较厉害的朋友较高的投票权重。以上所述的这四种方法都是将不同人不同意见融合起来的方式，接下来我们就要讨论如何将这些做法对应到机器学习中去。Aggregation的思想与这个例子是类似的，即把多个hypothesis结合起来，得到更好的预测效果。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2306240f089d3592848afc0526ae9c02.jpg" alt="这里写图片描述" title="" /></p>

        <p>将刚刚举的例子的各种方法用数学化的语言和机器学习符号归纳表示出来，其中G(x)表示最终选择的模型。</p>

        <p>第一种方法对应的模型：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6cb59c9c08b9339a66e36fc3d3dafcde.jpg" /></p>

        <p>第二种方法对应的模型：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/67f04d890c535748a4ebdc8645736f4c.jpg" /></p>

        <p>第三种方法对应的模型：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/339050b770cee9a63825ae943f2586df.jpg" /></p>

        <p>第四种方法对应的模型：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c2ac55038fcb6cfbd4c10e2ea5310f6e.jpg" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9b18f70a57b706a08061e17b131d9d48.jpg" alt="这里写图片描述" title="" /></p>

        <p>注意这里提到的第一种方法是通过验证集来选择最佳模型，不能使用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75a83fc009cd0f7b322b2b33d333f9a1.jpg" />来代替<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1c327866f8bfbe0ec695ca8a205e1d44.jpg" />。经过Validation，选择最小的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6462c685b1d7ece6cd83820bf768230a.jpg" />，保证<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/da16864d4ac2352ee42fb0fdda4c9cfb.jpg" />最小，从而将对应的模型作为最佳的选择。</p>

        <p>但是第一种方法只是从众多可能的hypothesis中选择最好的模型，并不能发挥集体的智慧。而Aggregation的思想是博采众长，将可能的hypothesis优势集合起来，将集体智慧融合起来，使预测模型达到更好的效果。</p>

        <p>下面先来看一个例子，通过这个例子说明为什么Aggregation能work得更好。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d1f2cfb1ee4b86ef8bd30f371ac2a5f2.jpg" alt="这里写图片描述" title="" /></p>

        <p>如上图所示，平面上分布着一些待分类的点。如果要求只能用一条水平的线或者垂直的线进行分类，那不论怎么选取直线，都达不到最佳的分类效果。这实际上就是上面介绍的第一种方法：validation。但是，如果可以使用集体智慧，比如一条水平线和两条垂直线组合而成的图中折线形式，就可以将所有的点完全分开，得到了最优化的预测模型。</p>

        <p>这个例子表明，通过将不同的hypotheses均匀地结合起来，得到了比单一hypothesis更好的预测模型。这就是aggregation的优势所在，它提高了预测模型的power，起到了特征转换（feature
            transform）的效果。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/908c6f07aecc3ade70a3428998dc81e6.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们再从另外一方面来看，同样是平面上分布着一些待分类的点，使用PLA算法，可以得到很多满足条件的分类线，如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cbc66ee6cb2c708fc2aa19be8b69aac7.jpg" alt="这里写图片描述" title="" /></p>

        <p>这无数条PLA选择出来的直线对应的hypothesis都是满足分类要求的。但是我们最想得到的分类直线是中间那条距离所有点都比较远的黑色直线，这与之前SVM目标是一致的。如果我们将所有可能的hypothesis结合起来，以投票的方式进行组合选择，最终会发现投票得到的分类线就是中间和黑色那条。这从哲学的角度来说，就是对各种效果较好的可能性进行组合，得到的结果一般是中庸的、最合适的，即对应图中那条黑色直线。所以，aggregation也起到了正则化（regularization）的效果，让预测模型更具有代表性。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/06ceedbb299a1d95b7a60d75888618b8.jpg" alt="这里写图片描述" title="" /></p>

        <p>基于以上的两个例子，我们得到了aggregation的两个优势：feature transform和regularization。我们之前在机器学习基石课程中就介绍过，feature
            transform和regularization是对立的，还把它们分别比作踩油门和踩刹车。如果进行feature
            transform，那么regularization的效果通常很差，反之亦然。也就是说，单一模型通常只能倾向于feature
            transform和regularization之一，在两者之间做个权衡。但是aggregation却能将feature
            transform和regularization各自的优势结合起来，好比把油门和刹车都控制得很好，从而得到不错的预测模型。</p>

        <h3 id="uniform-blending" class="sigil_not_in_toc"><strong>Uniform Blending</strong></h3>

        <p>那对于我们已经选择的性能较好的一些矩<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />，如何将它们进行整合、合并，来得到最佳的预测模型呢？这个过程称为blending。</p>

        <p>最常用的一种方法是uniform blending，应用于classification分类问题，做法是将每一个可能的矩赋予权重1，进行投票，得到的G(x)表示为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c440db11eb64a67044941e8afd16cacf.jpg" /></p>

        <p>这种方法对应三种情况：第一种情况是每个候选的矩<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />都完全一样，这跟选其中任意一个<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />效果相同；第二种情况是每个候选的矩<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />都有一些差别，这是最常遇到的，大都可以通过投票的形式使多数意见修正少数意见，从而得到很好的模型，如下图所示；第三种情况是多分类问题，选择投票数最多的那一类即可。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/94aa37eb2e87983932bcf5c08cb4211c.jpg" alt="这里写图片描述" title="" /></p>

        <p>如果是regression回归问题，uniform blending的做法很简单，就是将所有的矩<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />求平均值：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ca24487ed88a6533bb54e1da7c2dcfa3.jpg" /></p>

        <p>uniform blending for regression对应两种情况：第一种情况是每个候选的矩<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />都完全一样，这跟选其中任意一个<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />效果相同；第二种情况是每个候选的矩<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />都有一些差别，有的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ddf4c4832c4031ff82a6eb6b6d54e6af.jpg" />，有的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/747be9c2daa7415ba7f0fb52834d78dd.jpg" />，此时求平均值的操作可能会消去这种大于和小于的影响，从而得到更好的回归模型。因此，从直觉上来说，求平均值的操作更加稳定，更加准确。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8d4d4be946a14a66b2c75277aa2d39f9.jpg" alt="这里写图片描述" title="" /></p>

        <p>对于uniform blending，一般要求每个候选的矩<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />都有一些差别。这样，通过不同矩<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的组合和集体智慧，都能得到比单一矩<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />更好的模型。</p>

        <p>刚才我们提到了uniform blending for regression中，计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的平均值可能比单一的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />更稳定，更准确。下面进行简单的推导和证明。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/374d02fb233b82e226a3e808e9cd34e5.jpg" alt="这里写图片描述" title="" /></p>

        <p>推导过程中注意<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/66afe18135e49aa6a3fc97f8116a3189.jpg" />。经过推导，我们发现<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6ac95c9990355e32ceedfc0cfce6f7cf.jpg" />与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2e97c0fd2a6578b129758be064627f14.jpg" />之间差了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dc6bba9ec1a121b1f1b1f0a58ce12fb4.jpg" />项，且是大于零的。从而得到<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />与目标函数f的差值要比G与f的差值大。</p>

        <p>刚才是对单一的x进行证明，如果从期望角度，对整个x分布进行上述公式的整理，得到：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3ca035588c0aa9f3ac50fa6c5053e09f.jpg" alt="这里写图片描述" title="" /></p>

        <p>从结果上来看，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9af365ba1040da16faa6c8749a20063e.jpg" />，从而证明了从平均上来说，计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的平均值G(t)要比单一的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />更接近目标函数f，regression效果更好。</p>

        <p>我们已经知道G是数目为T的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的平均值。令包含N个数据的样本D独立同分布于<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/58a710b077481fb3f84954249b4a9437.jpg" />，每次从新的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/12499e2a147075c997da4071a77b4505.jpg" />中学习得到新的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />，在对<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />求平均得到G，当做无限多次，即T趋向于无穷大的时候：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c5fc9a30b4c170740649724329f7a409.jpg" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5ad54543f96e5dd798a7f270e5ec983b.jpg" alt="这里写图片描述" title="" /></p>

        <p>当T趋于无穷大的时候，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6cb0fbeac2141b61b0908af60f8bd743.jpg" />，则有如下等式成立：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f6472ff2d2f3f84859e8e7d6d454e958.jpg" alt="这里写图片描述" title="" /></p>

        <p>上述等式中左边表示演算法误差的期望值；右边第二项表示不同<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的平均误差共识，用偏差bias表示；右边第一项表示不同<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />与共识的差距是多少，反映<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />之间的偏差，用方差variance表示。也就是说，一个演算法的平均表现可以被拆成两项，一个是所有<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的共识，一个是不同<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />之间的差距是多少，即bias和variance。而uniform
            blending的操作时求平均的过程，这样就削减弱化了上式第一项variance的值，从而演算法的表现就更好了，能得到更加稳定的表现。</p>

        <h3 id="linear-and-any-blending" class="sigil_not_in_toc"><strong>Linear and Any Blending</strong></h3>

        <p>上一部分讲的是uniform blending，即每个<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />所占的权重都是1，求平均的思想。下面我们将介绍linear
            blending，每个<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />赋予的权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />并不相同，其中<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fd93e43e3e89365643df12ae4f7cf6bc.jpg" />。我们最终得到的预测结果等于所有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的线性组合。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3c9ed7cad6fd29961fb01769cc7d38e0.jpg" alt="这里写图片描述" title="" /></p>

        <p>如何确定<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />的值，方法是利用误差最小化的思想，找出最佳的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />，使<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b6971912d2600b733d9cd03941afca7c.jpg" />取最小值。例如对于linear blending for regression，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b6971912d2600b733d9cd03941afca7c.jpg" />可以写成下图左边形式，其中<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />是带求解参数，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1d768b793875ea4602e56a1cb2feb04a.jpg" />是每个矩得到的预测值，由已知矩得到。这种形式很类似于下图右边的形式，即加上特征转换<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f9b5f7ad8489157f13297606969fa12b.jpg" />的linear regression模型。两个式子中的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1d768b793875ea4602e56a1cb2feb04a.jpg" />对应于<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f9b5f7ad8489157f13297606969fa12b.jpg" />，唯一不同的就是linear blending for regression中<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fd93e43e3e89365643df12ae4f7cf6bc.jpg" />，而linear
            regression中<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7c33d0107578f4b8c92b64cbc2044221.jpg" />没有限制。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/463a76e9ac578bf5106d4783823c473e.jpg" alt="这里写图片描述" title="" /></p>

        <p>这种求解<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />的方法就像是使用two-level
            learning，类似于我们之前介绍的probabilistic SVM。这里，我们先计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1d768b793875ea4602e56a1cb2feb04a.jpg" />，再进行linear
            regression得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />值。总的来说，linear
            blending由三个部分组成：LinModel，hypotheses as transform，constraints。其中值得注意的一点就是，计算过程中可以把<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />当成feature
            transform，求解过程就跟之前没有什么不同，除了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4b5d8a1d2a0f8a54560951d1a0365484.jpg" />的条件限制。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/62f721a56dae0dcd37cfc6c8db105a76.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们来看一下linear blending中的constraint <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fd93e43e3e89365643df12ae4f7cf6bc.jpg" />。这个条件是否一定要成立呢？如果<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4c2a51f5ebff0876fc181d1b95a73eff.jpg" />，会带来什么后果呢？其实<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4c2a51f5ebff0876fc181d1b95a73eff.jpg" />并不会影响分类效果，只需要将正类看成负类，负类当成正类即可。例如分类问题，判断该点是正类对应的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4c2a51f5ebff0876fc181d1b95a73eff.jpg" />，则它就表示该点是负类，且对应的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/28eba620b5054d872cd3010737f25407.jpg" />。如果我们说这个样本是正类的概率是-99%，意思也就是说该样本是负类的概率是99%。<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fd93e43e3e89365643df12ae4f7cf6bc.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4c2a51f5ebff0876fc181d1b95a73eff.jpg" />的效果是等同的一致的。所以，我们可以把<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fd93e43e3e89365643df12ae4f7cf6bc.jpg" />这个条件舍去，这样linear blending就可以使用常规方法求解。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c73d8a259481739bac49b6ca59002b0c.jpg" alt="这里写图片描述" title="" /></p>

        <p>Linear Blending中使用的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />是通过模型选择而得到的，利用validation，从<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/03b4575acb3128cff010ac1f6cd63a35.jpg" />中得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1b1627922d996cffe90ba9dc9f09646d.jpg" />。然后将<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/03b4575acb3128cff010ac1f6cd63a35.jpg" />中每个数据点经过各个矩的计算得到的值，代入到相应的linear
            blending计算公式中，迭代优化得到对应<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/82005cc2e0087e2a52c7e43df4a19a00.jpg" />值。最终，再利用所有样本数据，得到新的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />代替<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fef5934349415af8294119990a6d01fc.jpg" />，则G(t)就是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的线性组合而不是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fef5934349415af8294119990a6d01fc.jpg" />，系数是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8f7234fc10cdfec6a8f0f0dc3286ecc2.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3e7d06dfd14c5be95f4284b41f38392e.jpg" alt="这里写图片描述" title="" /></p>

        <p>除了linear blending之外，还可以使用任意形式的blending。linear blending中，G(t)是g(t)的线性组合；any
            blending中，G(t)可以是g(t)的任何函数形式（非线性）。这种形式的blending也叫做Stacking。any
            blending的优点是模型复杂度提高，更容易获得更好的预测模型；缺点是复杂模型也容易带来过拟合的危险。所以，在使用any
            blending的过程中要时刻注意避免过拟合发生，通过采用regularization的方法，让模型具有更好的泛化能力。</p>

        <h3 id="baggingbootstrap-aggregation" class="sigil_not_in_toc"><strong>Bagging(Bootstrap Aggregation)</strong></h3>

        <p>总结一些上面讲的内容，blending的做法就是将已经得到的矩<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />进行aggregate的操作。具体的aggregation形式包括：uniform，non-uniforn和conditional。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b8d36eecda59947d7277cba6d75bca27.jpg" alt="这里写图片描述" title="" /></p>

        <p>现在考虑一个问题：如何得到不同的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />呢？可以选取不同模型H；可以设置不同的参数，例如<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />、迭代次数n等；可以由算法的随机性得到，例如PLA、随机种子等；可以选择不同的数据样本等。这些方法都可能得到不同的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e622572dd353027c0fcbf9c0565759fd.jpg" alt="这里写图片描述" title="" /></p>

        <p>那如何利用已有的一份数据集来构造出不同的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />呢？首先，我们回顾一下之前介绍的bias-variance，即一个演算法的平均表现可以被拆成两项，一个是所有<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的共识（bias），一个是不同<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />之间的差距是多少（variance）。其中每个<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />都是需要新的数据集的。只有一份数据集的情况下，如何构造新的数据集？</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1a51c6f12246c6e3b49fe9e084312bc6.jpg" alt="这里写图片描述" title="" /></p>

        <p>其中，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/546d4cdd67b97460228f2aa7eb1ababa.jpg" />是在矩个数T趋向于无穷大的时候，不同的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />计算平均得到的值。这里我们为了得到<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/546d4cdd67b97460228f2aa7eb1ababa.jpg" />，做两个近似条件：</p>

        <ul>
            <li>
                <p><strong>有限的T；</strong></p>
            </li>
            <li>
                <p><strong>由已有数据集D构造出<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1d90fd00b40fc082fec809cca7f74215.jpg" />，独立同分布</strong></p>
            </li>
        </ul>

        <p>第一个条件没有问题，第二个近似条件的做法就是bootstrapping。bootstrapping是统计学的一个工具，思想就是从已有数据集D中模拟出其他类似的样本<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/12499e2a147075c997da4071a77b4505.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3b0950b92ed371982b6c88abe2f18937.jpg" alt="这里写图片描述" title="" /></p>

        <p>bootstrapping的做法是，假设有N笔资料，先从中选出一个样本，再放回去，再选择一个样本，再放回去，共重复N次。这样我们就得到了一个新的N笔资料，这个新的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2b6e671c7d87e9ddaba0c67a81c61235.jpg" />中可能包含原D里的重复样本点，也可能没有原D里的某些样本，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2b6e671c7d87e9ddaba0c67a81c61235.jpg" />与D类似但又不完全相同。值得一提的是，抽取-放回的操作不一定非要是N，次数可以任意设定。例如原始样本有10000个，我们可以抽取-放回3000次，得到包含3000个样本的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2b6e671c7d87e9ddaba0c67a81c61235.jpg" />也是完全可以的。利用bootstrap进行aggragation的操作就被称为bagging。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a77d332a82e4a3c7d3210aee44547fa6.jpg" alt="这里写图片描述" title="" /></p>

        <p>下面举个实际中Bagging Pocket算法的例子。如下图所示，先通过bootstrapping得到25个不同样本集，再使用pocket算法得到25个不同的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />，每个pocket算法迭代1000次。最后，再利用blending，将所有的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />融合起来，得到最终的分类线，如图中黑线所示。可以看出，虽然bootstrapping会得到差别很大的分类线（灰线），但是经过blending后，得到的分类线效果是不错的，则bagging通常能得到最佳的分类模型。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7769649975b43359e33667d170b2f5d6.jpg" alt="这里写图片描述" title="" /></p>

        <p>值得注意的是，只有当演算法对数据样本分布比较敏感的情况下，才有比较好的表现。</p>

        <h3 id="总结" class="sigil_not_in_toc"><strong>总结</strong></h3>

        <p>本节课主要介绍了blending和bagging的方法，它们都属于aggregation，即将不同的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />合并起来，利用集体的智慧得到更加优化的G(t)。Blending通常分为三种情况：Uniform
            Blending，Linear Blending和Any Blending。其中，uniform blending采样最简单的“一人一票”的方法，linear blending和any
            blending都采用标准的two-level learning方法，类似于特征转换的操作，来得到不同<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的线性组合或非线性组合。最后，我们介绍了如何利用bagging（bootstrap
            aggregation），从已有数据集D中模拟出其他类似的样本<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/12499e2a147075c997da4071a77b4505.jpg" />，而得到不同的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />，再合并起来，优化预测模型。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习技法》课程</p>

        <p><strong>更多AI资源请关注公众号：红色石头的机器学习之路（ID：redstonewill）</strong> <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6bd62bf68004ab23bb768219ce27bfaa.jpg" alt="这里写图片描述" title="" /></p>
    </div>

    <h1 class="title-article">8 -- Adaptive Boosting</h1>
    <div class="markdown_views">
        <blockquote>
            <p>红色石头的个人网站：<a href="http://redstonewill.com/" rel="nofollow">redstonewill.com</a></p>
        </blockquote>

        <p>上节课我们主要开始介绍Aggregation Models，目的是将不同的hypothesis得到的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />集合起来，利用集体智慧得到更好的预测模型G。首先我们介绍了Blending，blending是将已存在的所有<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />结合起来，可以是uniformly，linearly，或者non-linearly组合形式。然后，我们讨论了在没有那么多<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的情况下，使用bootstrap方式，从已有数据集中得到新的类似的数据集，从而得到不同的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />。这种做法称为bagging。本节课将继续从这些概念出发，介绍一种新的演算法。</p>

        <h3 id="motivation-of-boosting" class="sigil_not_in_toc"><strong>Motivation of Boosting</strong></h3>

        <p>我们先来看一个简单的识别苹果的例子，老师展示20张图片，让6岁孩子们通过观察，判断其中哪些图片的内容是苹果。从判断的过程中推导如何解决二元分类问题的方法。</p>

        <p>显然这是一个监督式学习，20张图片包括它的标签都是已知的。首先，学生Michael回答说：所有的苹果应该是圆形的。根据Michael的判断，对应到20张图片中去，大部分苹果能被识别出来，但也有错误。其中错误包括有的苹果不是圆形，而且圆形的水果也不一定是苹果。如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5df26c491d8cf583fb44e6279531e1cf.jpg" alt="这里写图片描述" title="" /></p>

        <p>上图中蓝色区域的图片代表分类错误。显然，只用“苹果是圆形的”这一个条件不能保证分类效果很好。我们把蓝色区域（分类错误的图片）放大，分类正确的图片缩小，这样在接下来的分类中就会更加注重这些错误样本。</p>

        <p>然后，学生Tina观察被放大的错误样本和上一轮被缩小的正确样本，回答说：苹果应该是红色的。根据Tina的判断，得到的结果如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/845da3dba8b23551d783426ad7fbac20.jpg" alt="这里写图片描述" title="" /></p>

        <p>上图中蓝色区域的图片一样代表分类错误，即根据这个苹果是红色的条件，使得青苹果和草莓、西红柿都出现了判断错误。那么结果就是把这些分类错误的样本放大化，其它正确的样本缩小化。同样，这样在接下来的分类中就会更加注重这些错误样本。</p>

        <p>接着，学生Joey经过观察又说：苹果也可能是绿色的。根据Joey的判断，得到的结果如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0499b1e7e0ef89b1c0dc7ffb6b50a33f.jpg" alt="这里写图片描述" title="" /></p>

        <p>上图中蓝色区域的图片一样代表分类错误，根据苹果是绿色的条件，使得图中蓝色区域都出现了判断错误。同样把这些分类错误的样本放大化，其它正确的样本缩小化，在下一轮判断继续对其修正。</p>

        <p>后来，学生Jessica又发现：上面有梗的才是苹果。得到如下结果：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0863be5263e01518b4e2db8549322e57.jpg" alt="这里写图片描述" title="" /></p>

        <p>经过这几个同学的推论，苹果被定义为：圆的，红色的，也可能是绿色的，上面有梗。从一个一个的推导过程中，我们似乎得到一个较为准确的苹果的定义。虽然可能不是非常准确，但是要比单一的条件要好得多。也就是说把所有学生对苹果的定义融合起来，最终得到一个比较好的对苹果的总体定义。这种做法就是我们本节课将要讨论的演算法。这些学生代表的就是简单的hypotheses
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />，将所有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />融合，得到很好的预测模型G。例如，二维平面上简单的hypotheses（水平线和垂直线），这些简单<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />最终组成的较复杂的分类线能够较好地将正负样本完全分开，即得到了好的预测模型。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/03bde98587b7df4b07806ad50cc17ab3.jpg" alt="这里写图片描述" title="" /></p>

        <p>所以，上个苹果的例子中，不同的学生代表不同的hypotheses <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />；最终得到的苹果总体定义就代表hypothesis
            G；而老师就代表演算法A，指导学生的注意力集中到关键的例子中（错误样本），从而得到更好的苹果定义。其中的数学原理，我们下一部分详细介绍。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d0f092764f2d75d0f1c0596269ac7d63.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="diversity-by-re-weighting" class="sigil_not_in_toc"><strong>Diversity by Re-weighting</strong></h3>

        <p>在介绍这个演算法之前，我们先来讲一下上节课就介绍过的bagging。Bagging的核心是bootstrapping，通过对原始数据集D不断进行bootstrap的抽样动作，得到与D类似的数据集<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e8eab833bceb02874c7bd2299dfef69f.jpg" />，每组<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e8eab833bceb02874c7bd2299dfef69f.jpg" />都能得到相应的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />，从而进行aggregation的操作。现在，假如包含四个样本的D经过bootstrap，得到新的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e8eab833bceb02874c7bd2299dfef69f.jpg" />如下：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e2caf9121a8b0e40b304823f52f45136.jpg" alt="这里写图片描述" title="" /></p>

        <p>那么，对于新的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e8eab833bceb02874c7bd2299dfef69f.jpg" />，把它交给base algorithm，找出<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />最小时对应的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />，如下图右边所示。</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dd06142bfafc50489eea60d72cc01f27.jpg" /></p>

        <p>由于<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e8eab833bceb02874c7bd2299dfef69f.jpg" />完全是D经过bootstrap得到的，其中样本<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c2ba479317c47d58318502dd60ae2bbf.jpg" />出现2次，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/61acfc46814617be74c0b0a53af35fbc.jpg" />出现1次，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/42e2d96f122a0bc63e8fa398bfe4ce3a.jpg" />出现0次，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/79ef70201a9e89f35281d79f0ee88b65.jpg" />出现1次。引入一个参数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/64bf21665984f24b2e0af82d08070870.jpg" />来表示原D中第i个样本在<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e8eab833bceb02874c7bd2299dfef69f.jpg" />中出现的次数，如下图左边所示。</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2cd7c1996bef282063777611f5fff1c3.jpg" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/19d628b0f103345b89d745fe2548544c.jpg" alt="这里写图片描述" title="" /></p>

        <p>参数u相当于是权重因子，当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e8eab833bceb02874c7bd2299dfef69f.jpg" />中第i个样本出现的次数越多的时候，那么对应的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/64bf21665984f24b2e0af82d08070870.jpg" />越大，表示在error
            function中对该样本的惩罚越多。所以，从另外一个角度来看bagging，它其实就是通过bootstrap的方式，来得到这些<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/64bf21665984f24b2e0af82d08070870.jpg" />值，作为犯错样本的权重因子，再用base
            algorithn最小化包含<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/64bf21665984f24b2e0af82d08070870.jpg" />的error function，得到不同的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />。这个error
            function被称为bootstrap-weighted error。</p>

        <p>这种算法叫做Weightd Base Algorithm，目的就是最小化bootstrap-weighted error。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0e74236eb700380a3ead62adb1a22a28.jpg" alt="这里写图片描述" title="" /></p>

        <p>其实，这种weightd base algorithm我们之前就介绍过类似的算法形式。例如在soft-margin SVM中，我们引入允许犯错的项，同样可以将每个点的error乘以权重因子<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7b56b6accdfa58d7250aa8c8ea130313.jpg" />。加上该项前的参数C，经过QP，最终得到<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f800e849bead8011bf68cf7ea31c3af4.jpg" />，有别于之前介绍的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e1eeab325f056fd2a5283f0f8f4ffa09.jpg" />。这里的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7b56b6accdfa58d7250aa8c8ea130313.jpg" />相当于每个犯错的样本的惩罚因子，并会反映到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />的范围限定上。</p>

        <p>同样在logistic regression中，同样可以对每个犯错误的样本乘以相应的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7b56b6accdfa58d7250aa8c8ea130313.jpg" />，作为惩罚因子。<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7b56b6accdfa58d7250aa8c8ea130313.jpg" />表示该错误点出现的次数，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7b56b6accdfa58d7250aa8c8ea130313.jpg" />越大，则对应的惩罚因子越大，则在最小化error时就应该更加重视这些点。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2ba3e81ad54489506f78181e98717747.jpg" alt="这里写图片描述" title="" /></p>

        <p>其实这种example-weighted learning，我们在机器学习基石课程第8次笔记中就介绍过class-weighted的思想。二者道理是相通的。</p>

        <p>知道了u的概念后，我们知道不同的u组合经过base algorithm得到不同的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />。那么如何选取u，使得到的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />之间有很大的不同呢？之所以要让所有的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />差别很大，是因为上节课aggregation中，我们介绍过<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />越不一样，其aggregation的效果越好，即每个人的意见越不相同，越能运用集体的智慧，得到好的预测模型。</p>

        <p>为了得到不同的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />，我们先来看看<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6c734ff5b88bd86a4833667b3d445a6d.jpg" />是怎么得到的：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6e6718e7b786f597b688aeeac8e85f95.jpg" alt="这里写图片描述" title="" /></p>

        <p>如上所示，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />是由<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/997e5f198082970175c75387b75c565a.jpg" />得到的，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6c734ff5b88bd86a4833667b3d445a6d.jpg" />是由<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2894b6a675c0fb8a35bbcf881e375efb.jpg" />得到的。如果<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />这个模型在使用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2894b6a675c0fb8a35bbcf881e375efb.jpg" />的时候得到的error很大，即预测效果非常不好，那就表示由<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2894b6a675c0fb8a35bbcf881e375efb.jpg" />计算的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6c734ff5b88bd86a4833667b3d445a6d.jpg" />会与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />有很大不同。而<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6c734ff5b88bd86a4833667b3d445a6d.jpg" />与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />差异性大正是我们希望看到的。</p>

        <p>怎么做呢？方法是利用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />在使用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2894b6a675c0fb8a35bbcf881e375efb.jpg" />的时候表现很差的条件，越差越好。如果在<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />作用下，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2894b6a675c0fb8a35bbcf881e375efb.jpg" />中的表现（即error）近似为0.5的时候，表明<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2894b6a675c0fb8a35bbcf881e375efb.jpg" />的预测分类没有什么作用，就像抛硬币一样，是随机选择的。这样的做法就能最大限度地保证<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6c734ff5b88bd86a4833667b3d445a6d.jpg" />会与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />有较大的差异性。其数学表达式如下所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e7d5a541d99085ab5f040f3067ca77cd.jpg" alt="这里写图片描述" title="" /></p>

        <p>乍看上面这个式子，似乎不好求解。但是，我们对它做一些等价处理，其中分式中分子可以看成<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />作用下犯错误的点，而分母可以看成犯错的点和没有犯错误的点的集合，即所有样本点。其中犯错误的点和没有犯错误的点分别用橘色方块和绿色圆圈表示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c3283314992b5df680e7e192ea6a9444.jpg" alt="这里写图片描述" title="" /></p>

        <p>要让分式等于0.5，显然只要将犯错误的点和没有犯错误的点的数量调成一样就可以了。也就是说，在<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />作用下，让犯错的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2894b6a675c0fb8a35bbcf881e375efb.jpg" />数量和没有犯错的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2894b6a675c0fb8a35bbcf881e375efb.jpg" />数量一致就行（包含权重<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8c2658f1603875ed8af2c84a563c7a41.jpg" />）。一种简单的方法就是利用放大和缩小的思想（本节课开始引入识别苹果的例子中提到的放大图片和缩小图片就是这个目的），将犯错误的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/997e5f198082970175c75387b75c565a.jpg" />和没有犯错误的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/997e5f198082970175c75387b75c565a.jpg" />做相应的乘积操作，使得二者值变成相等。例如<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/997e5f198082970175c75387b75c565a.jpg" /> of incorrect为1126，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/997e5f198082970175c75387b75c565a.jpg" />
            of correct为6211，要让<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2894b6a675c0fb8a35bbcf881e375efb.jpg" />中错误比例正好是0.5，可以这样做，对于incorrect
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2894b6a675c0fb8a35bbcf881e375efb.jpg" />：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/01685888cdad7a4319f44dcffa12dfed.jpg" /></p>

        <p>对于correct <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2894b6a675c0fb8a35bbcf881e375efb.jpg" />：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/404b5c473a017b5b468cf923652a71ad.jpg" /></p>

        <p>或者利用犯错的比例来做，令weighted incorrect rate和weighted correct rate分别设为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/584de61676474f365c58cce11c85738f.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/79e1682862eecf6f6720804de5c3f8ee.jpg" />。一般求解方式是令犯错率为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cb0532fb968b27375acebebfefbb4122.jpg" />，在计算<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2894b6a675c0fb8a35bbcf881e375efb.jpg" />的时候，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/997e5f198082970175c75387b75c565a.jpg" />分别乘以<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e9cf5f88111a781a4c1c6bd56d7f033d.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cb0532fb968b27375acebebfefbb4122.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cdc48dd3955b71ea98e40d8a1d84df21.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="adaptive-boosting-algorithm" class="sigil_not_in_toc"><strong>Adaptive Boosting Algorithm</strong></h3>

        <p>上一部分，我们介绍了在计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2894b6a675c0fb8a35bbcf881e375efb.jpg" />的时候，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/997e5f198082970175c75387b75c565a.jpg" />分别乘以<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e9cf5f88111a781a4c1c6bd56d7f033d.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cb0532fb968b27375acebebfefbb4122.jpg" />。下面将构造一个新的尺度因子：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52fbf734c9ec5cafa6e1c235c4f9f507.jpg" /></p>

        <p>那么引入这个新的尺度因子之后，对于错误的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/997e5f198082970175c75387b75c565a.jpg" />，将它乘以<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1b2614ea0213c05b9f1f85148e8afde4.jpg" />；对于正确的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/997e5f198082970175c75387b75c565a.jpg" />，将它除以<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1b2614ea0213c05b9f1f85148e8afde4.jpg" />。这种操作跟之前介绍的分别乘以<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e9cf5f88111a781a4c1c6bd56d7f033d.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cb0532fb968b27375acebebfefbb4122.jpg" />的效果是一样的。之所以引入<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1b2614ea0213c05b9f1f85148e8afde4.jpg" />是因为它告诉我们更多的物理意义。因为如果<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8850f62abc5eb7e21b7058d20f215c6b.jpg" />，得到<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd7d71a452a011e9912f23291d12488f.jpg" />，那么接下来错误的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/997e5f198082970175c75387b75c565a.jpg" />与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1b2614ea0213c05b9f1f85148e8afde4.jpg" />的乘积就相当于把错误点放大了，而正确的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/997e5f198082970175c75387b75c565a.jpg" />与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1b2614ea0213c05b9f1f85148e8afde4.jpg" />的相除就相当于把正确点缩小了。这种scale up incorrect和scale down
            correct的做法与本节课开始介绍的学生识别苹果的例子中放大错误的图片和缩小正确的图片是一个原理，让学生能够将注意力更多地放在犯错误的点上。通过这种scaling-up
            incorrect的操作，能够保证得到不同于<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6c734ff5b88bd86a4833667b3d445a6d.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7ec9ec233ec0d164c2ccde49994f75bd.jpg" alt="这里写图片描述" title="" /></p>

        <p>值得注意的是上述的结论是建立在<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8850f62abc5eb7e21b7058d20f215c6b.jpg" />的基础上，如果<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/429b8fb7036422fe78587f1675adfe8b.jpg" />，那么就做相反的推论即可。关于<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/429b8fb7036422fe78587f1675adfe8b.jpg" />的情况，我们稍后会进行说明。</p>

        <p>从这个概念出发，我们可以得到一个初步的演算法。其核心步骤是每次迭代时，利用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52fbf734c9ec5cafa6e1c235c4f9f507.jpg" />把<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f12c35987540e74fcb6a9fab7957a05a.jpg" />更新为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/44f8fa24ab89925f7252c5d3e3c95696.jpg" />。具体迭代步骤如下：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c834626096fde387e58f02ca2619b174.jpg" alt="这里写图片描述" title="" /></p>

        <p>但是，上述步骤还有两个问题没有解决，第一个问题是初始的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/da4363232a03011824d1e66cbd566bf4.jpg" />应为多少呢？一般来说，为了保证第一次<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />最小的话，设<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8bd68413756a186760f02bc512d0b56c.jpg" />即可。这样最开始的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/098d359092c821d17fb2252ea6026951.jpg" />就能由此推导。第二个问题，最终的G(x)应该怎么求？是将所有的g(t)合并uniform在一起吗？一般来说并不是这样直接uniform求解，因为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6c734ff5b88bd86a4833667b3d445a6d.jpg" />是通过<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />得来的，二者在<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />上的表现差别比较大。所以，一般是对所有的g(t)进行linear或者non-linear组合来得到G(t)。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/378cb1ec46cde0127040e8a491656d9a.jpg" alt="这里写图片描述" title="" /></p>

        <p>接下来的内容，我们将对上面的第二个问题进行探讨，研究一种算法，将所有的g(t)进行linear组合。方法是计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c66f2f2012a92b6c77b274794a0e77ae.jpg" />的同时，就能计算得到其线性组合系数<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />，即aggregate linearly on the fly。这种算法使最终求得<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6c734ff5b88bd86a4833667b3d445a6d.jpg" />的时候，所有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的线性组合系数<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/82005cc2e0087e2a52c7e43df4a19a00.jpg" />也求得了，不用再重新计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/82005cc2e0087e2a52c7e43df4a19a00.jpg" />了。这种Linear
            Aggregation on the Fly算法流程为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/186041d65828e1f08af51f25c2b4a063.jpg" alt="这里写图片描述" title="" /></p>

        <p>如何在每次迭代的时候计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />呢？我们知道<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cb0532fb968b27375acebebfefbb4122.jpg" />是相关的：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cb0532fb968b27375acebebfefbb4122.jpg" />越小，对应的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />应该越大，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cb0532fb968b27375acebebfefbb4122.jpg" />越大，对应的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />应该越小。又因为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1b2614ea0213c05b9f1f85148e8afde4.jpg" />与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cb0532fb968b27375acebebfefbb4122.jpg" />是正相关的，所以，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />应该是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1b2614ea0213c05b9f1f85148e8afde4.jpg" />的单调函数。我们构造<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9e46d1f73a6d7e1a4ffb34e1ae2524b0.jpg" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />这样取值是有物理意义的，例如当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d32d2fbbfdf8c54a63942ad5fecee4c7.jpg" />时，error很大，跟掷骰子这样的随机过程没什么两样，此时对应的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/003761f25e082bf077efc2ac8f60f011.jpg" />，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/33c02d31f3f2c4d72b82a5bbe7e3436f.jpg" />，即此<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />对G没有什么贡献，权重应该设为零。而当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fe9c1fe9553957a9ff31b6f226055a38.jpg" />时，没有error，表示该<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />预测非常准，此时对应的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3f3d7eb65f1515e9efc9b054a042b78f.jpg" />，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/58bc3b588d586611f68b61d4ece7fe76.jpg" />，即此<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />对G贡献非常大，权重应该设为无穷大。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b490afa0f5aed0e882e3869dc9cdeb49.jpg" alt="这里写图片描述" title="" /></p>

        <p>这种算法被称为Adaptive Boosting。它由三部分构成：base learning algorithm A，re-weighting factor <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1b2614ea0213c05b9f1f85148e8afde4.jpg" />和linear
            aggregation <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />。这三部分分别对应于我们在本节课开始介绍的例子中的Student，Teacher和Class。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ff302df3c36218d11278b31a3da1f641.jpg" alt="这里写图片描述" title="" /></p>

        <p>综上所述，完整的adaptive boosting（AdaBoost）Algorithm流程如下：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a7d1a1c3b0af7656197f081683567cbd.jpg" alt="这里写图片描述" title="" /></p>

        <p>从我们之前介绍过的VC bound角度来看，AdaBoost算法理论上满足：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/20401ffb9397bf4ec3fc6fc61a19133b.jpg" alt="这里写图片描述" title="" /></p>

        <p>上式中，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8da047ff10b88bd892d623d42617317c.jpg" />的上界由两部分组成，一项是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e7a24bae1a3e51c9b14095d17938eb24.jpg" />，另一项是模型复杂度O(*)。模型复杂度中<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2f15d5377caebbc2df91ebdd4aa60857.jpg" />是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的VC
            Dimension，T是迭代次数，可以证明G的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/63926b21692667f723efd5f25797c88c.jpg" />服从<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e2bd2278ead905998155fe3c0bb65e1.jpg" />。</p>

        <p>对这个VC bound中的第一项<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e7a24bae1a3e51c9b14095d17938eb24.jpg" />来说，有一个很好的性质：如果满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f139b3ec8fb68def11f839acc525c1e6.jpg" />，则经过<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/56697a132614a2d8b482fb4fe0667ba4.jpg" />次迭代之后，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e7a24bae1a3e51c9b14095d17938eb24.jpg" />能减小到等于零的程度。而当N很大的时候，其中第二项也能变得很小。因为这两项都能变得很小，那么整个<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8da047ff10b88bd892d623d42617317c.jpg" />就能被限定在一个有限的上界中。</p>

        <p>其实，这种性质也正是AdaBoost算法的精髓所在。只要每次的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f139b3ec8fb68def11f839acc525c1e6.jpg" />，即所选择的矩g比乱猜的表现好一点点，那么经过每次迭代之后，矩g的表现都会比原来更好一些，逐渐变强，最终得到<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8979e87b0fb1d13fdfaad13dcfe4638b.jpg" />且<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/da16864d4ac2352ee42fb0fdda4c9cfb.jpg" />很小。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/35dd166dbdc05408225eab936523cba8.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="adaptive-boosting-in-action" class="sigil_not_in_toc"><strong>Adaptive Boosting in Action</strong></h3>

        <p>上一小节我们已经介绍了选择一个“弱弱”的算法A（<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f139b3ec8fb68def11f839acc525c1e6.jpg" />，比乱猜好就行），就能经过多次迭代得到<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8979e87b0fb1d13fdfaad13dcfe4638b.jpg" />。我们称这种形式为decision
            stump模型。下面介绍一个例子，来看看AdaBoost是如何使用decision stump解决实际问题的。</p>

        <p>如下图所示，二维平面上分布一些正负样本点，利用decision stump来做切割。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dbcdd588c2cf89096c344c4ebf4a3bba.jpg" alt="这里写图片描述" title="" /></p>

        <p>第一步：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/852806c365649a8c317f338597050743.jpg" alt="这里写图片描述" title="" /></p>

        <p>第二步：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9838b172a0d33eb4eb9d5de9f9877388.jpg" alt="这里写图片描述" title="" /></p>

        <p>第三步：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aced8d8f2f2958c8bf9aebde4f4ba899.jpg" alt="这里写图片描述" title="" /></p>

        <p>第四步：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/405d9293330883e7cdbb8d8f8b353e10.jpg" alt="这里写图片描述" title="" /></p>

        <p>第五步：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3de4b01a75d75b0228064fd31ed36a00.jpg" alt="这里写图片描述" title="" /></p>

        <p>可以看到，经过5次迭代之后，所有的正负点已经被完全分开了，则最终得到的分类线为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/00435f35f99b5cfa52f0b936f7fdad25.jpg" alt="这里写图片描述" title="" /></p>

        <p>另外一个例子，对于一个相对比较复杂的数据集，如下图所示。它的分界线从视觉上看应该是一个sin波的形式。如果我们再使用AdaBoost算法，通过decision
            stump来做切割。在迭代切割100次后，得到的分界线如下所示。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f6227e62c9f5d1e1d0c747480204af91.jpg" alt="这里写图片描述" title="" /></p>

        <p>可以看出，AdaBoost-Stump这种非线性模型得到的分界线对正负样本有较好的分离效果。</p>

        <p>课程中还介绍了一个AdaBoost-Stump在人脸识别方面的应用：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/12761ae82d7b9f27e1452e03014aa6c7.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="总结" class="sigil_not_in_toc"><strong>总结</strong></h3>

        <p>本节课主要介绍了Adaptive
            Boosting。首先通过讲一个老师教小学生识别苹果的例子，来引入Boosting的思想，即把许多“弱弱”的hypotheses合并起来，变成很强的预测模型。然后重点介绍这种算法如何实现，关键在于每次迭代时，给予样本不同的系数u，宗旨是放大错误样本，缩小正确样本，得到不同的小矩g。并且在每次迭代时根据错误<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aeb302325ebc29add21f094ad38ad261.jpg" />值的大小，给予不同<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />不同的权重。最终由不同的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />进行组合得到整体的预测模型G。实际证明，Adaptive
            Boosting能够得到有效的预测模型。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习技法》课程</p>

        <p><strong>更多AI资源请关注公众号：红色石头的机器学习之路（ID：redstonewill）</strong> <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ff7f67bfdb901f63cf4cfb7d682d3249.jpg" alt="这里写图片描述" title="" /></p>
    </div>

    <h1 class="title-article">9 -- Decision Tree</h1>
    <div class="markdown_views">
        <blockquote>
            <p>红色石头的个人网站：<a href="http://redstonewill.com/" rel="nofollow">redstonewill.com</a></p>
        </blockquote>

        <p>上节课我们主要介绍了Adaptive Boosting。AdaBoost演算法通过调整每笔资料的权重，得到不同的hypotheses，然后将不同的hypothesis乘以不同的系数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/82005cc2e0087e2a52c7e43df4a19a00.jpg" />进行线性组合。这种演算法的优点是，即使底层的演算法g不是特别好（只要比乱选好点），经过多次迭代后算法模型会越来越好，起到了boost提升的效果。本节课将在此基础上介绍一种新的aggregation算法：决策树（Decision
            Tree）。</p>

        <h3 id="decision-tree-hypothesis" class="sigil_not_in_toc"><strong>Decision Tree Hypothesis</strong></h3>

        <p>从第7节课开始，我们就一直在介绍aggregation
            model。aggregation的核心就是将许多可供选择使用的比较好的hypothesis融合起来，利用集体的智慧组合成G，使其得到更好的机器学习预测模型。下面，我们先来看看已经介绍过的aggregation
            type有哪些。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/335a621c5ff3e4f9421fbb6003c74037.jpg" alt="这里写图片描述" title="" /></p>

        <p>aggregation
            type有三种：uniform，non-uniform，conditional。它有两种情况，一种是所有的g是已知的，即blending。对应的三种类型分别是voting/averaging，linear和stacking。另外一种情况是所有g未知，只能通过手上的资料重构g，即learning。其中uniform和non-uniform分别对应的是Bagging和AdaBoost算法，而conditional对应的就是我们本节课将要介绍的Decision
            Tree算法。</p>

        <p>决策树（Decision
            Tree）模型是一种传统的算法，它的处理方式与人类思维十分相似。例如下面这个例子，对下班时间、约会情况、提交截止时间这些条件进行判断，从而决定是否要进行在线课程测试。如下图所示，整个流程类似一个树状结构。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5191c1136cb5444c662d9aade6fe49ad.jpg" alt="这里写图片描述" title="" /></p>

        <p>图中每个条件和选择都决定了最终的结果，Y or N。蓝色的圆圈表示树的叶子，即最终的决定。</p>

        <p>把这种树状结构对应到一个hypothesis G(x)中，G(x)的表达式为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f774652dffc954b1614aeb44ed06cc8d.jpg" /></p>

        <p>G(x)由许多<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4131ab539ff96aa53dce85b56410010.jpg" />组成，即aggregation的做法。每个<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4131ab539ff96aa53dce85b56410010.jpg" />就代表上图中的蓝色圆圈（树的叶子）。这里的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4131ab539ff96aa53dce85b56410010.jpg" />是常数，因为是处理简单的classification问题。我们把这些<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4131ab539ff96aa53dce85b56410010.jpg" />称为base
            hypothesis。<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fc978c9071b652a2fb72509fe7d6d846.jpg" />表示每个<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4131ab539ff96aa53dce85b56410010.jpg" />成立的条件，代表上图中橘色箭头的部分。不同的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4131ab539ff96aa53dce85b56410010.jpg" />对应于不同的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fc978c9071b652a2fb72509fe7d6d846.jpg" />，即从树的根部到顶端叶子的路径不同。图中中的菱形代表每个简单的节点。所以，这些base
            hypothesis和conditions就构成了整个G(x)的形式，就像一棵树一样，从根部到顶端所有的叶子都安全映射到上述公式上去了。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b5e6764fb19b9668a49cba7a34de1ff6.jpg" alt="这里写图片描述" title="" /></p>

        <p>决策树实际上就是在模仿人类做决策的过程。一直以来，决策树的应用十分广泛而且分类预测效果都很不错，而它在数学上的理论完备性不充分，倒也不必在意。</p>

        <p>如果从另外一个方面来看决策树的形式，不同于上述G(x)的公式，我们可以利用条件分支的思想，将整体G(x)分成若干个<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a32efbdaa5d5b2929c2826ff1852dd6.jpg" />，也就是把整个大树分成若干个小树，如下所示：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5374effeef8636caf6de17c1a63e5baf.jpg" /></p>

        <p>上式中，G(x)表示完整的大树，即full-tree hypothesis，b(x)表示每个分支条件，即branching criteria，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a32efbdaa5d5b2929c2826ff1852dd6.jpg" />表示第c个分支下的子树，即sub-tree。这种结构被称为递归型的数据结构，即将大树分割成不同的小树，再将小树继续分割成更小的子树。所以，决策树可以分为两部分：root和sub-trees。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/42f91a5a4cc4d57573e3a019340cd859.jpg" alt="这里写图片描述" title="" /></p>

        <p>在详细推导决策树算法之前，我们先来看一看它的优点和缺点。首先，decision tree的优点有：</p>

        <ul>
            <li>
                <p><strong>模型直观，便于理解，应用广泛</strong></p>
            </li>
            <li>
                <p><strong>算法简单，容易实现</strong></p>
            </li>
            <li>
                <p><strong>训练和预测时，效率较高</strong></p>
            </li>
        </ul>

        <p>然而，decision tree也有相应的缺点：</p>

        <ul>
            <li>
                <p><strong>缺少足够的理论支持</strong></p>
            </li>
            <li>
                <p><strong>如何选择合适的树结构对初学者来说比较困惑</strong></p>
            </li>
            <li>
                <p><strong>决策树代表性的演算法比较少</strong></p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0facac5de98d55371076f7e14eb6e395.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="decision-tree-algorithm" class="sigil_not_in_toc"><strong>Decision Tree Algorithm</strong></h3>

        <p>我们可以用递归形式将decision tree表示出来，它的基本的算法可以写成：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3a3c3bccac945addac63bb1be21a69b6.jpg" alt="这里写图片描述" title="" /></p>

        <p>这个Basic Decision Tree
            Algorithm的流程可以分成四个部分，首先学习设定划分不同分支的标准和条件是什么；接着将整体数据集D根据分支个数C和条件，划为不同分支下的子集Dc；然后对每个分支下的Dc进行训练，得到相应的机器学习模型Gc；最后将所有分支下的Gc合并到一起，组成大矩G(x)。但值得注意的是，这种递归的形式需要终止条件，否则程序将一直进行下去。当满足递归的终止条件之后，将会返回基本的hypothesis
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4131ab539ff96aa53dce85b56410010.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b04ac57988942ffaa2eea7b3c557fd89.jpg" alt="这里写图片描述" title="" /></p>

        <p>所以，决策树的基本演算法包含了四个选择：</p>

        <ul>
            <li>
                <p><strong>分支个数（number of branches）</strong></p>
            </li>
            <li>
                <p><strong>分支条件（branching criteria）</strong></p>
            </li>
            <li>
                <p><strong>终止条件（termination criteria）</strong></p>
            </li>
            <li>
                <p><strong>基本算法（base hypothesis）</strong></p>
            </li>
        </ul>

        <p>下面我们来介绍一种常用的决策树模型算法，叫做Classification and Regression
            Tree(C&amp;RT)。C&amp;RT算法有两个简单的设定，首先，分支的个数C=2，即二叉树（binary tree）的数据结构；然后，每个分支最后的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4131ab539ff96aa53dce85b56410010.jpg" />（数的叶子）是一个常数。按照最小化<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />的目标，对于binary/multiclass classification(0/1
            error)问题，看正类和负类哪个更多，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4131ab539ff96aa53dce85b56410010.jpg" />取所占比例最多的那一类<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd32e7f8488e6575c81fd5ec787f53a7.jpg" />；对于regression(squared
            error)问题，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4131ab539ff96aa53dce85b56410010.jpg" />则取所有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd32e7f8488e6575c81fd5ec787f53a7.jpg" />的平均值。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7720d750767c39a8ef5c0fa0585c5584.jpg" alt="这里写图片描述" title="" /></p>

        <p>对于决策树的基本演算法流程，C&amp;RT还有一些简单的设定。首先，C&amp;RT分支个数C=2，一般采用上节课介绍过的decision
            stump的方法进行数据切割。也就是每次在一个维度上，只对一个特征feature将数据一分为二，左子树和右子树，分别代表不同的类别。然而，怎么切割才能让数据划分得最好呢（error最小）？C&amp;RT中使用纯净度purifying这个概念来选择最好的decision
            stump。purifying的核心思想就是每次切割都尽可能让左子树和右子树中同类样本占得比例最大或者<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd32e7f8488e6575c81fd5ec787f53a7.jpg" />都很接近（regression），即错误率最小。比如说classifiacation问题中，如果左子树全是正样本，右子树全是负样本，那么它的纯净度就很大，说明该分支效果很好。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7c2e0444cd2a3d412b5ebbd3c62abd49.jpg" alt="这里写图片描述" title="" /></p>

        <p>根据C&amp;RT中purifying的思想，我们得到选择合适的分支条件b(x)的表达式如上所示。最好的decision
            stump重点包含两个方面：一个是刚刚介绍的分支纯净度purifying，purifying越大越好，而这里使用purifying相反的概念impurity，则impurity越小越好；另外一个是左右分支纯净度所占的权重，权重大小由该分支的数据量决定，分支包含的样本个数越多，则所占权重越大，分支包含的样本个数越少，则所占权重越小。上式中的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ae94614347d4f548594e303d15e68ef3.jpg" />代表了分支c所占的权重。这里b(x)类似于error
            function（这也是为什么使用impurity代替purifying的原因），选择最好的decision stump，让所有分支的不纯度最小化，使b(x)越小越好。</p>

        <p>不纯度Impurity如何用函数的形式量化？一种简单的方法就是类比于<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />，看预测值与真实值的误差是多少。对于regression问题，它的impurity可表示为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/69c8b2ac28e38fc54f1d3294c2acdbc4.jpg" /></p>

        <p>其中，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8829c84fca311ee5b4b919d67d04877a.jpg" />表示对应分支下所有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd32e7f8488e6575c81fd5ec787f53a7.jpg" />的均值。</p>

        <p>对应classification问题，它的impurity可表示为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0b0322e844b8c96d3fdc052161a93059.jpg" /></p>

        <p>其中，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ddaf657fa3c559112dd57626d0ef3b85.jpg" />表示对应分支下所占比例最大的那一类。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/828c87a5e04664da41ccc0f264075c15.jpg" alt="这里写图片描述" title="" /></p>

        <p>以上这些impurity是基于原来的regression error和classification error直接推导的。进一步来看classification的impurity
            functions，如果某分支条件下，让其中一个分支纯度最大，那么就选择对应的decision stump，即得到的classification error为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fac83a95c63910237a73a79545802815.jpg" /></p>

        <p>其中，K为分支个数。</p>

        <p>上面这个式子只考虑纯度最大的那个分支，更好的做法是将所有分支的纯度都考虑并计算在内，用基尼指数（Gini index）表示：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a68dcc388ec49b98f204ac6a7740ae0f.jpg" /></p>

        <p>Gini index的优点是将所有的class在数据集中的分布状况和所占比例全都考虑了，这样让decision stump的选择更加准确。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/68f5dfcc34433759106480e6e5295518.jpg" alt="这里写图片描述" title="" /></p>

        <p>对于决策树C&amp;RT算法，通常来说，上面介绍的各种impurity functions中，Gini index更适合求解classification问题，而regression
            error更适合求解regression问题。</p>

        <p>C&amp;RT算法迭代终止条件有两种情况，第一种情况是当前各个分支下包含的所有样本<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd32e7f8488e6575c81fd5ec787f53a7.jpg" />都是同类的，即不纯度impurity为0，表示该分支已经达到了最佳分类程度。第二种情况是该特征下所有的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />相同，无法对其进行区分，表示没有decision
            stumps。遇到这两种情况，C&amp;RT算法就会停止迭代。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f9a04bf9ac4e921f4e505918f3b77513.jpg" alt="这里写图片描述" title="" /></p>

        <p>所以，C&amp;RT算法遇到迭代终止条件后就成为完全长成树（fully-grown tree）。它每次分支为二，是二叉树结构，采用purify来选择最佳的decision stump来划分，最终得到的叶子（<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4131ab539ff96aa53dce85b56410010.jpg" />）是常数。</p>

        <h3 id="decision-tree-heuristics-in-crt" class="sigil_not_in_toc"><strong>Decision Tree Heuristics in C&amp;RT</strong></h3>

        <p>现在我们已经知道了C&amp;RT算法的基本流程：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/635721ef8ee2362a97ef754ad582ae99.jpg" alt="这里写图片描述" title="" /></p>

        <p>可以看到C&amp;RT算法在处理binary classification和regression问题时非常简单实用，而且，处理muti-class classification问题也十分容易。</p>

        <p>考虑这样一个问题，有N个样本，如果我们每次只取一个样本点作为分支，那么在经过N-1次分支之后，所有的样本点都能完全分类正确。最终每片叶子上只有一个样本，有N片叶子，即必然能保证<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8979e87b0fb1d13fdfaad13dcfe4638b.jpg" />。这样看似是完美的分割，但是不可避免地造成VC
            Dimension无限大，造成模型复杂度增加，从而出现过拟合现象。为了避免overfit，我们需要在C&amp;RT算法中引入正则化，来控制整个模型的复杂度。</p>

        <p>考虑到避免模型过于复杂的方法是减少叶子（<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4131ab539ff96aa53dce85b56410010.jpg" />）的数量，那么可以令regularizer就为决策树中叶子的总数，记为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fcf59cea61937d9041a5ad53570fe9e7.jpg" />。正则化的目的是尽可能减少<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fcf59cea61937d9041a5ad53570fe9e7.jpg" />的值。这样，regularized
            decision tree的形式就可以表示成：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/be7efd3df811b2ca2ecfe72c8838c887.jpg" /></p>

        <p>我们把这种regularized decision tree称为pruned decision
            tree。pruned是修剪的意思，通过regularization来修剪决策树，去掉多余的叶子，更简洁化，从而达到避免过拟合的效果。</p>

        <p>那么如何确定修剪多少叶子，修剪哪些叶子呢？假设由C&amp;RT算法得到一棵完全长成树（fully-grown tree），总共10片叶子。首先分别减去其中一片叶子，剩下9片，将这10种情况比较，取<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />最小的那个模型；然后再从9片叶子的模型中分别减去一片，剩下8片，将这9种情况比较，取<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />最小的那个模型。以此类推，继续修建叶子。这样，最终得到包含不同叶子的几种模型，将这几个使用regularized
            decision tree的error function来进行选择，确定包含几片叶子的模型误差最小，就选择该模型。另外，参数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" />可以通过validation来确定最佳值。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cea3126c93e734ba6aa7bf1b96500932.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们一直讨论决策树上的叶子（features）都是numerical features，而实际应用中，决策树的特征值可能不是数字量，而是类别（categorical features）。对于numerical
            features，我们直接使用decision stump进行数值切割；而对于categorical features，我们仍然可以使用decision
            subset，对不同类别进行“左”和“右”，即是与不是（0和1）的划分。numerical features和categorical features的具体区别如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/daba0de5f99bb14871ff3bef61a47866.jpg" alt="这里写图片描述" title="" /></p>

        <p>在决策树中预测中，还会遇到一种问题，就是当某些特征缺失的时候，没有办法进行切割和分支选择。一种常用的方法就是surrogate
            branch，即寻找与该特征相似的替代feature。如何确定是相似的feature呢？做法是在决策树训练的时候，找出与该特征相似的feature，如果替代的feature与原feature切割的方式和结果是类似的，那么就表明二者是相似的，就把该替代的feature也存储下来。当预测时遇到原feature缺失的情况，就用替代feature进行分支判断和选择。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3c44566e2fcdf806cd7c0ea95b39988b.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="decision-tree-in-action" class="sigil_not_in_toc"><strong>Decision Tree in Action</strong></h3>

        <p>最后我们来举个例子看看C&amp;RT算法究竟是如何进行计算的。例如下图二维平面上分布着许多正负样本，我们使用C&amp;RT算法来对其进行决策树的分类。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b4940f1f32fdb53d6bb5abaec2a0d639.jpg" alt="这里写图片描述" title="" /></p>

        <p>第一步：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/703f78dbd59070711cb18a8126b2451d.jpg" alt="这里写图片描述" title="" /></p>

        <p>第二步：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/89694d774b1a4e212cebcfe1dfc9e8e6.jpg" alt="这里写图片描述" title="" /></p>

        <p>第三步：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/56c61e766d39e5a6c88ae1ef20469ed2.jpg" alt="这里写图片描述" title="" /></p>

        <p>第四步：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/97bd61932bf923c128a1e1cc590c6669.jpg" alt="这里写图片描述" title="" /></p>

        <p>在进行第四步切割之后，我们发现每个分支都已经非常纯净了，没有办法继续往下切割。此时表明已经满足了迭代终止条件，这时候就可以回传base hypothesis，构成sub tree，然后每个sub
            tree再往上整合形成tree，最后形成我们需要的完全决策树。如果将边界添加上去，可得到下图：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/12c824903181421e1ca4bbc0c65f5028.jpg" alt="这里写图片描述" title="" /></p>

        <p>得到C&amp;RT算法的切割方式之后，我们与AdaBoost-Stump算法进行比较：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/743fe9a22b7027361c59244de0674b23.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们之前就介绍过，AdaBoost-Stump算法的切割线是横跨整个平面的；而C&amp;RT算法的切割线是基于某个条件的，所以一般不会横跨整个平面。比较起来，虽然C&amp;RT和AdaBoost-Stump都采用decision
            stump方式进行切割，但是二者在细节上还是有所区别。</p>

        <p>再看一个数据集分布比较复杂的例子，C&amp;RT和AdaBoost-Stump的切割方式对比效果如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dd3eb40aa7105b0d9560819925a80f11.jpg" alt="这里写图片描述" title="" /></p>

        <p>通常来说，由于C&amp;RT是基于条件进行切割的，所以C&amp;RT比AdaBoost-Stump分类切割更有效率。总结一下，C&amp;RT决策树有以下特点：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b59791e27733987dae59b85b7af46840.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="总结" class="sigil_not_in_toc"><strong>总结：</strong></h3>

        <p>本节课主要介绍了Decision Tree。首先将decision tree hypothesis对应到不同分支下的矩<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4131ab539ff96aa53dce85b56410010.jpg" />。然后再介绍决策树算法是如何通过递归的形式建立起来。接着详细研究了决策树C&amp;RT算法对应的数学模型和算法架构流程。最后通过一个实际的例子来演示决策树C&amp;RT算法是如何一步一步进行分类的。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习技法》课程</p>

        <p><strong>更多AI资源请关注公众号：红色石头的机器学习之路（ID：redstonewill）</strong> <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d2874316502c598f3db9244027a7a617.jpg" alt="这里写图片描述" title="" /></p>
    </div>

    <h1 class="title-article">10 -- Random Forest</h1>
    <div class="markdown_views">
        <blockquote>
            <p>红色石头的个人网站：<a href="http://redstonewill.com/" rel="nofollow">redstonewill.com</a></p>
        </blockquote>

        <p>上节课我们主要介绍了Decision Tree模型。Decision
            Tree算法的核心是通过递归的方式，将数据集不断进行切割，得到子分支，最终形成数的结构。C&amp;RT算法是决策树比较简单和常用的一种算法，其切割的标准是根据纯度来进行，每次切割都是为了让分支内部纯度最大。最终，决策树不同的分支得到不同的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4131ab539ff96aa53dce85b56410010.jpg" />（即树的叶子，C&amp;RT算法中，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4131ab539ff96aa53dce85b56410010.jpg" />是常数）。本节课将介绍随机森林（Random
            Forest）算法，它是我们之前介绍的Bagging和上节课介绍的Decision Tree的结合。</p>

        <h3 id="random-forest-algorithm" class="sigil_not_in_toc"><strong>Random Forest Algorithm</strong></h3>

        <p>首先我们来复习一下之前介绍过的两个机器学习模型：Bagging和Decision Tree。Bagging是通过bootstrap的方式，从原始的数据集D中得到新的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4f19727ce07f460b5598e1742ac12442.jpg" />；然后再使用一些base
            algorithm对每个<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4f19727ce07f460b5598e1742ac12442.jpg" />都得到相应的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />；最后将所有的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />通过投票uniform的形式组合成一个G，G即为我们最终得到的模型。Decision
            Tree是通过递归形式，利用分支条件，将原始数据集D切割成一个个子树结构，长成一棵完整的树形结构。Decision Tree最终得到的G(x)是由相应的分支条件b(x)和分支树<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a32efbdaa5d5b2929c2826ff1852dd6.jpg" />递归组成。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dac0f737bbafe495392601f0a71c8016.jpg" alt="这里写图片描述" title="" /></p>

        <p>Bagging和Decison Tree算法各自有一个很重要的特点。Bagging具有减少不同<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的方差variance的特点。这是因为Bagging采用投票的形式，将所有<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />uniform结合起来，起到了求平均的作用，从而降低variance。而Decision
            Tree具有增大不同<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的方差variance的特点。这是因为Decision
            Tree每次切割的方式不同，而且分支包含的样本数在逐渐减少，所以它对不同的资料D会比较敏感一些，从而不同的D会得到比较大的variance。</p>

        <p>所以说，Bagging能减小variance，而Decision Tree能增大variance。如果把两者结合起来，能否发挥各自的优势，起到优势互补的作用呢？这就是我们接下来将要讨论的aggregation of
            aggregation，即使用Bagging的方式把众多的Decision Tree进行uniform结合起来。这种算法就叫做随机森林（Random
            Forest），它将完全长成的C&amp;RT决策树通过bagging的形式结合起来，最终得到一个庞大的决策模型。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7324fa80ac068d0e241d11cbe2fc770b.jpg" alt="这里写图片描述" title="" /></p>

        <p>Random Forest算法流程图如下所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd755253517df20ba090c767652046c8.jpg" alt="这里写图片描述" title="" /></p>

        <p>Random
            Forest算法的优点主要有三个。第一，不同决策树可以由不同主机并行训练生成，效率很高；第二，随机森林算法继承了C&amp;RT的优点；第三，将所有的决策树通过bagging的形式结合起来，避免了单个决策树造成过拟合的问题。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ded4d4ce4aacff050aa906b2124f2449.jpg" alt="这里写图片描述" title="" /></p>

        <p>以上是基本的Random Forest算法，我们再来看一下如何让Random Forest中决策树的结构更有多样性。Bagging中，通过bootstrap的方法得到不同于D的D’，使用这些随机抽取的资料得到不同的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />。除了随机抽取资料获得不同<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的方式之外，还有另外一种方法，就是随机抽取一部分特征。例如，原来有100个特征，现在只从中随机选取30个来构成决策树，那么每一轮得到的树都由不同的30个特征构成，每棵树都不一样。假设原来样本维度是d，则只选择其中的d’（d’小于d）个维度来建立决策树结构。这类似是一种从d维到d’维的特征转换，相当于是从高维到低维的投影，也就是说d’维z空间其实就是d维x空间的一个随机子空间（subspace）。通常情况下，d’远小于d，从而保证算法更有效率。Random
            Forest算法的作者建议在构建C&amp;RT每个分支b(x)的时候，都可以重新选择子特征来训练，从而得到更具有多样性的决策树。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0711b8da357e16f73c955d76df397da7.jpg" alt="这里写图片描述" title="" /></p>

        <p>所以说，这种增强的Random Forest算法增加了random-subspace。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4eaeb390f34628476aa7ebbf53d3271a.jpg" alt="这里写图片描述" title="" /></p>

        <p>上面我们讲的是随机抽取特征，除此之外，还可以将现有的特征x，通过数组p进行线性组合，来保持多样性：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ec18e2b4b8e37b871389c503d29ffb40.jpg" /></p>

        <p>这种方法使每次分支得到的不再是单一的子特征集合，而是子特征的线性组合（权重不为1）。好比在二维平面上不止得到水平线和垂直线，也能得到各种斜线。这种做法使子特征选择更加多样性。值得注意的是，不同分支i下的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f606c9d9ec8e9e435d0c0914939cac85.jpg" />是不同的，而且向量<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f606c9d9ec8e9e435d0c0914939cac85.jpg" />中大部分元素为零，因为我们选择的只是一部分特征，这是一种低维映射。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0c0704cfd1f07066ea681ecedf495ce5.jpg" alt="这里写图片描述" title="" /></p>

        <p>所以，这里的Random
            Forest算法又有增强，由原来的random-subspace变成了random-combination。顺便提一下，这里的random-combination类似于perceptron模型。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/34b1700968f6692a26cc5b05d193c51c.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="out-of-bag-estimate" class="sigil_not_in_toc"><strong>Out-Of-Bag Estimate</strong></h3>

        <p>上一部分我们已经介绍了Random Forest算法，而Random Forest算法重要的一点就是Bagging。接下来将继续探讨bagging中的bootstrap机制到底蕴含了哪些可以为我们所用的东西。</p>

        <p>通过bootstrap得到新的样本集D’，再由D’训练不同的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />。我们知道D’中包含了原样本集D中的一些样本，但也有些样本没有涵盖进去。如下表所示，不同的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />下，红色的<em>表示在<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d342979caefc7139c17230b0bf4e97b0.jpg" />中没有这些样本。例如对<img
                    src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/098d359092c821d17fb2252ea6026951.jpg" />来说，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/61acfc46814617be74c0b0a53af35fbc.jpg" />和<img
                    src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e3453ba632c833baba5e712c8dcda115.jpg" />没有包含进去，对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5d14f76946479b52a3dd77916314157c.jpg" />来说，<img
                    src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c2ba479317c47d58318502dd60ae2bbf.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/61acfc46814617be74c0b0a53af35fbc.jpg" />没有包含进去，等等。每个<img
                    src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />中，红色</em>表示的样本被称为out-of-bag(OOB) example。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/51d83939dd12566fe0eea39e28e49ba9.jpg" alt="这里写图片描述" title="" /></p>

        <p>首先，我们来计算OOB样本到底有多少。假设bootstrap的数量N’=N，那么某个样本<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52044980121cb72960d9993d9e8fb1b2.jpg" />是OOB的概率是：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aab55f795057fe3ac0e1598610d08c0c.jpg" /></p>

        <p>其中，e是自然对数，N是原样本集的数量。由上述推导可得，每个<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />中，OOB数目大约是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2775cf817cfcad3aaddb21d300c7d1a3.jpg" />，即大约有三分之一的样本没有在bootstrap中被抽到。</p>

        <p>然后，我们将OOB与之前介绍的Validation进行对比：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/08d643c1f74c06659d1ec4eb23aed3cb.jpg" alt="这里写图片描述" title="" /></p>

        <p>在Validation表格中，蓝色的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/03b4575acb3128cff010ac1f6cd63a35.jpg" />用来得到不同的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a445e34721910171483152b28b187621.jpg" />，而红色的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/977979aa1cc07f26ade219397d82ad4e.jpg" />用来验证各自的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a445e34721910171483152b28b187621.jpg" />。<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/03b4575acb3128cff010ac1f6cd63a35.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/977979aa1cc07f26ade219397d82ad4e.jpg" />没有交集，一般<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/03b4575acb3128cff010ac1f6cd63a35.jpg" />是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/977979aa1cc07f26ade219397d82ad4e.jpg" />的数倍关系。再看左边的OOB表格，之前我们也介绍过，蓝色的部分用来得到不同的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />，而红色的部分是OOB样本。而我们刚刚也推导过，红色部分大约占N的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1094c6971f58cce27c6604b5726db7cf.jpg" />。通过两个表格的比较，我们发现OOB样本类似于<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/977979aa1cc07f26ade219397d82ad4e.jpg" />，那么是否能使用OOB样本来验证<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的好坏呢？答案是肯定的。但是，通常我们并不需要对单个<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />进行验证。因为我们更关心的是由许多<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />组合成的G，即使<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />表现不太好，只要G表现足够好就行了。那么问题就转化成了如何使用OOB来验证G的好坏。方法是先看每一个样本<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/52044980121cb72960d9993d9e8fb1b2.jpg" />是哪些<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的OOB资料，然后计算其在这些<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />上的表现，最后将所有样本的表现求平均即可。例如，样本<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a1ae50efc4bd11027491db192d2c9492.jpg" />是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5d14f76946479b52a3dd77916314157c.jpg" />，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d455c1c3004ada8fb5da0194c3e1e782.jpg" />，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/93656903511519858c243436374feffa.jpg" />的OOB，则可以计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a1ae50efc4bd11027491db192d2c9492.jpg" />在<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/60e42353ce5ee707f116411e8b56896e.jpg" />上的表现为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4980ecf49880fede51fd3272aadfeb6a.jpg" /></p>

        <p>这种做法我们并不陌生，就像是我们之前介绍过的Leave-One-Out Cross Validation，每次只对一个样本进行<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6e13d48295705250fcf81d059020b15e.jpg" />的验证一样，只不过这里选择的是每个样本是哪些<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的OOB，然后再分别进行<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/80963ff85792cff5a6ff76556bb72669.jpg" />的验证。每个样本都当成验证资料一次（与留一法相同），最后计算所有样本的平均表现：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d9539e9c3b1b97b953182de64a6fa51c.jpg" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ff4a2c23935073fcfb07569e8a03a9a3.jpg" />估算的就是G的表现好坏。我们把<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6114509137bde052c3192c875c86332a.jpg" />称为bagging或者Random
            Forest的self-validation。</p>

        <p>这种self-validation相比于validation来说还有一个优点就是它不需要重复训练。如下图左边所示，在通过<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/977979aa1cc07f26ade219397d82ad4e.jpg" />选择到表现最好的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/873266cfc566ff070e775d1935c53cd0.jpg" />之后，还需要在<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/03b4575acb3128cff010ac1f6cd63a35.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/977979aa1cc07f26ade219397d82ad4e.jpg" />组成的所有样本集D上重新对该模型<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/873266cfc566ff070e775d1935c53cd0.jpg" />训练一次，以得到最终的模型系数。但是self-validation在调整随机森林算法相关系数并得到最小的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6114509137bde052c3192c875c86332a.jpg" />之后，就完成了整个模型的建立，无需重新训练模型。随机森林算法中，self-validation在衡量G的表现上通常相当准确。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d3f3ddf919414abd83b6ecb085b41503.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="feature-selection" class="sigil_not_in_toc"><strong>Feature Selection</strong></h3>

        <p>如果样本资料特征过多，假如有10000个特征，而我们只想从中选取300个特征，这时候就需要舍弃部分特征。通常来说，需要移除的特征分为两类：一类是冗余特征，即特征出现重复，例如“年龄”和“生日”；另一类是不相关特征，例如疾病预测的时候引入的“保险状况”。这种从d维特征到d’维特征的subset-transform
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aed0c138deb8fbac62918bb5c5351399.jpg" />称为Feature Selection，最终使用这些d’维的特征进行模型训练。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/257ef36b51182040028b191bedba9cf5.jpg" alt="这里写图片描述" title="" /></p>

        <p>特征选择的优点是：</p>

        <ul>
            <li>
                <p><strong>提高效率，特征越少，模型越简单</strong></p>
            </li>
            <li>
                <p><strong>正则化，防止特征过多出现过拟合</strong></p>
            </li>
            <li>
                <p><strong>去除无关特征，保留相关性大的特征，解释性强</strong></p>
            </li>
        </ul>

        <p>同时，特征选择的缺点是：</p>

        <ul>
            <li>
                <p><strong>筛选特征的计算量较大</strong></p>
            </li>
            <li>
                <p><strong>不同特征组合，也容易发生过拟合</strong></p>
            </li>
            <li>
                <p><strong>容易选到无关特征，解释性差</strong></p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9cfe658b70afa5b3cf7c37c8dcf9c26f.jpg" alt="这里写图片描述" title="" /></p>

        <p>值得一提的是，在decision tree中，我们使用的decision stump切割方式也是一种feature selection。</p>

        <p>那么，如何对许多维特征进行筛选呢？我们可以通过计算出每个特征的重要性（即权重），然后再根据重要性的排序进行选择即可。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/419919d70bdc75f0244052d5f294615e.jpg" alt="这里写图片描述" title="" /></p>

        <p>这种方法在线性模型中比较容易计算。因为线性模型的score是由每个特征经过加权求和而得到的，而加权系数的绝对值<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/71f80d0da783efae17376a0d802f96b9.jpg" />正好代表了对应特征<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c9ac354d02519119ea19a09b8560296e.jpg" />的重要性为多少。<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/71f80d0da783efae17376a0d802f96b9.jpg" />越大，表示对应特征<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c9ac354d02519119ea19a09b8560296e.jpg" />越重要，则该特征应该被选择。w的值可以通过对已有的数据集<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/afd62c343d0af37b0cf763fa404dffde.jpg" />建立线性模型而得到。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9ef9514b6b2d8385a0b1d64c7770ddf3.jpg" alt="这里写图片描述" title="" /></p>

        <p>然而，对于非线性模型来说，因为不同特征可能是非线性交叉在一起的，所以计算每个特征的重要性就变得比较复杂和困难。例如，Random Forest就是一个非线性模型，接下来，我们将讨论如何在RF下进行特征选择。</p>

        <p>RF中，特征选择的核心思想是random test。random
            test的做法是对于某个特征，如果用另外一个随机值替代它之后的表现比之前更差，则表明该特征比较重要，所占的权重应该较大，不能用一个随机值替代。相反，如果随机值替代后的表现没有太大差别，则表明该特征不那么重要，可有可无。所以，通过比较某特征被随机值替代前后的表现，就能推断出该特征的权重和重要性。</p>

        <p>那么random
            test中的随机值如何选择呢？通常有两种方法：一是使用uniform或者gaussian抽取随机值替换原特征；一是通过permutation的方式将原来的所有N个样本的第i个特征值重新打乱分布（相当于重新洗牌）。比较而言，第二种方法更加科学，保证了特征替代值与原特征的分布是近似的（只是重新洗牌而已）。这种方法叫做permutation
            test（随机排序测试），即在计算第i个特征的重要性的时候，将N个样本的第i个特征重新洗牌，然后比较D和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/93716d6c986ed3ea9f6932ffcaf695d8.jpg" />表现的差异性。如果差异很大，则表明第i个特征是重要的。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/89178e9003061ad7242da73c357b56ec.jpg" alt="这里写图片描述" title="" /></p>

        <p>知道了permutation test的原理后，接下来要考虑的问题是如何衡量上图中的performance，即替换前后的表现。显然，我们前面介绍过performance可以用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ff4a2c23935073fcfb07569e8a03a9a3.jpg" />来衡量。但是，对于N个样本的第i个特征值重新洗牌重置的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/93716d6c986ed3ea9f6932ffcaf695d8.jpg" />，要对它进行重新训练，而且每个特征都要重复训练，然后再与原D的表现进行比较，过程非常繁琐。为了简化运算，RF的作者提出了一种方法，就是把permutation的操作从原来的training上移到了OOB
            validation上去，记为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/34a2755f81473a6549866013e631e960.jpg" />。也就是说，在训练的时候仍然使用D，但是在OOB验证的时候，将所有的OOB样本的第i个特征重新洗牌，验证G的表现。这种做法大大简化了计算复杂度，在RF的feature
            selection中应用广泛。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4a260cda25114d93e0c6e00097ac2ab2.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="random-forest-in-action" class="sigil_not_in_toc"><strong>Random Forest in Action</strong></h3>

        <p>最后，我们通过实际的例子来看一下RF的特点。首先，仍然是一个二元分类的例子。如下图所示，左边是一个C&amp;RT树没有使用bootstrap得到的模型分类效果，其中不同特征之间进行了随机组合，所以有斜线作为分类线；中间是由bootstrap（N’=N/2）后生成的一棵决策树组成的随机森林，图中加粗的点表示被bootstrap选中的点；右边是将一棵决策树进行bagging后的分类模型，效果与中间图是一样的，都是一棵树。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/32aa72abb2c54b7a1595b6633f4c737c.jpg" alt="这里写图片描述" title="" /></p>

        <p>当t=100，即选择了100棵树时，中间的模型是第100棵决策树构成的，还是只有一棵树；右边的模型是由100棵决策树bagging起来的，如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/44dc716c86a226aaed6fa3f01e6d81a8.jpg" alt="这里写图片描述" title="" /></p>

        <p>当t=200时：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c65a5260b01850c5226525678af20a44.jpg" alt="这里写图片描述" title="" /></p>

        <p>当t=300时：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b48ef3e754e783fb3a8a0b4d03860684.jpg" alt="这里写图片描述" title="" /></p>

        <p>当t=400时：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6e36927da41886c4ba445186b73c04b9.jpg" alt="这里写图片描述" title="" /></p>

        <p>当t=500时：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0b4be2f93f2e336c75672728368eafac.jpg" alt="这里写图片描述" title="" /></p>

        <p>当t=600时：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c42a7bb8e3204dac194ae82de16daab2.jpg" alt="这里写图片描述" title="" /></p>

        <p>当t=700时：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6245089cd7bec082012d42e4c327303f.jpg" alt="这里写图片描述" title="" /></p>

        <p>当t=800时：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2999adbe9560c74ceee663b76c94a370.jpg" alt="这里写图片描述" title="" /></p>

        <p>当t=900时：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1f27d7c9980bd2b12c62fbe81be0fca9.jpg" alt="这里写图片描述" title="" /></p>

        <p>当t=1000时：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4184753ba78c25e02775e74d1b5b7d7.jpg" alt="这里写图片描述" title="" /></p>

        <p>随着树木个数的增加，我们发现，分界线越来越光滑而且得到了large-margin-like boundary，类似于SVM一样的效果。也就是说，树木越多，分类器的置信区间越大。</p>

        <p>然后，我们再来看一个比较复杂的例子，二维平面上分布着许多离散点，分界线形如sin函数。当只有一棵树的时候（t=1），下图左边表示单一树组成的RF，右边表示所有树bagging组合起来构成的RF。因为只有一棵树，所以左右两边效果一致。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/03ca4cd4b79ef034abfbf7b5a9425f2a.jpg" alt="这里写图片描述" title="" /></p>

        <p>当t=6时：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3ff89a3ae72d8b66dc6502e2a8d49697.jpg" alt="这里写图片描述" title="" /></p>

        <p>当t=11时：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/571c6c896ab52e05a4999702092425d8.jpg" alt="这里写图片描述" title="" /></p>

        <p>当t=16时：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dfb9eb680141f3af524c21f32d173bab.jpg" alt="这里写图片描述" title="" /></p>

        <p>当t=21时：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/93382ee38d77270abbfd1a5d5ed18983.jpg" alt="这里写图片描述" title="" /></p>

        <p>可以看到，当RF由21棵树构成的时候，分界线就比较平滑了，而且它的边界比单一树构成的RF要robust得多，更加平滑和稳定。</p>

        <p>最后，基于上面的例子，再让问题复杂一点：在平面上添加一些随机噪声。当t=1时，如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e6026dedd342fc4a1a5294912bfc17f9.jpg" alt="这里写图片描述" title="" /></p>

        <p>当t=6时：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/395e4cb28f9b76d776ead1d98f44ad0c.jpg" alt="这里写图片描述" title="" /></p>

        <p>当t=11时：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/40e7b48260ab680ecb12d05f8762d61a.jpg" alt="这里写图片描述" title="" /></p>

        <p>当t=16时：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0969ecc57970a84cf2cad2022e0a7bd7.jpg" alt="这里写图片描述" title="" /></p>

        <p>当t=21时：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4a65a1d809f003b644eebff415ed8f5a.jpg" alt="这里写图片描述" title="" /></p>

        <p>从上图中，我们发现21棵树的时候，随机noise的影响基本上能够修正和消除。这种bagging投票的机制能够保证较好的降噪性，从而得到比较稳定的结果。</p>

        <p>经过以上三个例子，我们发现RF中，树的个数越多，模型越稳定越能表现得好。在实际应用中，应该尽可能选择更多的树。值得一提的是，RF的表现同时也与random seed有关，即随机的初始值也会影响RF的表现。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c58139ce9df92f02b3adbf551822c375.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="总结" class="sigil_not_in_toc"><strong>总结：</strong></h3>

        <p>本节课主要介绍了Random Forest算法模型。RF将bagging与decision
            tree结合起来，通过把众多的决策树组进行组合，构成森林的形式，利用投票机制让G表现最佳，分类模型更稳定。其中为了让decision tree的随机性更强一些，可以采用randomly projected
            subspaces操作，即将不同的features线性组合起来，从而进行各式各样的切割。同时，我们也介绍了可以使用OOB样本来进行self-validation，然后可以使用self-validation来对每个特征进行permutaion
            test，得到不同特征的重要性，从而进行feature selection。总的来说，RF算法能够得到比较平滑的边界，稳定性强，前提是有足够多的树。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习技法》课程</p>

        <p><strong>更多AI资源请关注公众号：AI有道（ID：redstonewill）</strong> <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bcfd4502ab6871092be264c682958b45.jpg" alt="这里写图片描述" title="" /></p>
    </div>

    <h1 class="title-article">11 -- Gradient Boosted Decision Tree</h1>
    <div class="markdown_views">
        <blockquote>
            <p>红色石头的个人网站：<a href="http://redstonewill.com/" rel="nofollow">redstonewill.com</a></p>
        </blockquote>

        <p>上节课我们主要介绍了Random Forest算法模型。Random Forest就是通过bagging的方式将许多不同的decision tree组合起来。除此之外，在decision
            tree中加入了各种随机性和多样性，比如不同特征的线性组合等。RF还可以使用OOB样本进行self-validation，而且可以通过permutation test进行feature
            selection。本节课将使用Adaptive Boosting的方法来研究decision tree的一些算法和模型。</p>

        <h3 id="adaptive-boosted-decision-tree" class="sigil_not_in_toc"><strong>Adaptive Boosted Decision Tree</strong></h3>

        <p>Random Forest的算法流程我们上节课也详细介绍过，就是先通过bootstrapping“复制”原样本集D，得到新的样本集D’；然后对每个D’进行训练得到不同的decision tree和对应的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />；最后再将所有的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />通过uniform的形式组合起来，即以投票的方式得到G。这里采用的Bagging的方式，也就是把每个<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的预测值直接相加。现在，如果将Bagging替换成AdaBoost，处理方式有些不同。首先每轮bootstrap得到的D’中每个样本会赋予不同的权重<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d135de29fec53e869a6c92d8d1a59d7f.jpg" />；然后在每个decision tree中，利用这些权重训练得到最好的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />；最后得出每个<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />所占的权重，线性组合得到G。这种模型称为AdaBoost-D Tree。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50175624c1f33a4bd82e2f9956c2608b.jpg" alt="这里写图片描述" title="" /></p>

        <p>但是在AdaBoost-DTree中需要注意的一点是每个样本的权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d135de29fec53e869a6c92d8d1a59d7f.jpg" />。我们知道，在Adaptive
            Boosting中进行了bootstrap操作，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d135de29fec53e869a6c92d8d1a59d7f.jpg" />表示D中每个样本在D’中出现的次数。但是在决策树模型中，例如C&amp;RT算法中并没有引入<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d135de29fec53e869a6c92d8d1a59d7f.jpg" />。那么，如何在决策树中引入这些权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d135de29fec53e869a6c92d8d1a59d7f.jpg" />来得到不同的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />而又不改变原来的决策树算法呢？</p>

        <p>在Adaptive Boosting中，我们使用了weighted algorithm，形如：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/abc170a92c8696c33ea238c30f93a7aa.jpg" /></p>

        <p>每个犯错误的样本点乘以相应的权重，求和再平均，最终得到了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dca6eaa7ea2fc8a58ca74196bfc23783.jpg" />。如果在决策树中使用这种方法，将当前分支下犯错误的点赋予权重，每层分支都这样做，会比较复杂，不易求解。为了简化运算，保持决策树算法本身的稳定性和封闭性，我们可以把决策树算法当成一个黑盒子，即不改变其结构，不对算法本身进行修改，而从数据来源D’上做一些处理。按照这种思想，我们来看权重u实际上表示该样本在bootstrap中出现的次数，反映了它出现的概率。那么可以根据u值，对原样本集D进行一次重新的随机sampling，也就是带权重的随机抽样。sampling之后，会得到一个新的D’，D’中每个样本出现的几率与它权重u所占的比例应该是差不多接近的。因此，使用带权重的sampling操作，得到了新的样本数据集D’，可以直接代入决策树进行训练，从而无需改变决策树算法结构。sampling可看成是bootstrap的反操作，这种对数据本身进行修改而不更改算法结构的方法非常重要！</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b8d9e2568293d1fd8807375c8f305c50.jpg" alt="这里写图片描述" title="" /></p>

        <p>所以，AdaBoost-DTree结合了AdaBoost和DTree，但是做了一点小小的改变，就是使用sampling替代权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d135de29fec53e869a6c92d8d1a59d7f.jpg" />，效果是相同的。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dae0b92d62f357a408e9e2d1acfcd6b7.jpg" alt="这里写图片描述" title="" /></p>

        <p>上面我们通过使用sampling，将不同的样本集代入决策树中，得到不同的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />。除此之外，我们还要确定每个<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />所占的权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />。之前我们在AdaBoost中已经介绍过，首先算出每个<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的错误率<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cb0532fb968b27375acebebfefbb4122.jpg" />，然后计算权重：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/635ece859fe5de86f27b266e20a215ae.jpg" /></p>

        <p>如果现在有一棵完全长成的树（fully grown tree），由所有的样本<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />训练得到。若每个样本都不相同的话，一刀刀切割分支，直到所有的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />都被完全分开。这时候，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/22db00cd2b84a37256ca5ec966d6cc79.jpg" />，加权的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/01ceb4d18a653473fd627e6d05fc60f0.jpg" />而且<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cb0532fb968b27375acebebfefbb4122.jpg" />也为0，从而得到权重<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/58bc3b588d586611f68b61d4ece7fe76.jpg" />。<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/58bc3b588d586611f68b61d4ece7fe76.jpg" />表示该<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />所占的权重无限大，相当于它一个就决定了G结构，是一种autocracy，而其它的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />对G没有影响。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/12cbfc656d65abf36595a1521edcd06b.jpg" alt="这里写图片描述" title="" /></p>

        <p>显然<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/58bc3b588d586611f68b61d4ece7fe76.jpg" />不是我们想看到的，因为autocracy总是不好的，我们希望使用aggregation将不同的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />结合起来，发挥集体智慧来得到最好的模型G。首先，我们来看一下什么原因造成了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/58bc3b588d586611f68b61d4ece7fe76.jpg" />。有两个原因：一个是使用了所有的样本<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />进行训练；一个是树的分支过多，fully
            grown。针对这两个原因，我们可以对树做一些修剪（pruned），比如只使用一部分样本，这在sampling的操作中已经起到这类作用，因为必然有些样本没有被采样到。除此之外，我们还可以限制树的高度，让分支不要那么多，从而避免树fully
            grown。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dfec8504b5a83ca34f1cdbde2f7d1983.jpg" alt="这里写图片描述" title="" /></p>

        <p>因此，AdaBoost-DTree使用的是pruned DTree，也就是说将这些预测效果较弱的树结合起来，得到最好的G，避免出现autocracy。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a6991cd616b3675e813276ac6d0b563e.jpg" alt="这里写图片描述" title="" /></p>

        <p>刚才我们说了可以限制树的高度，那索性将树的高度限制到最低，即只有1层高的时候，有什么特性呢？当树高为1的时候，整棵树只有两个分支，切割一次即可。如果impurity是binary classification
            error的话，那么此时的AdaBoost-DTree就跟AdaBoost-Stump没什么两样。也就是说AdaBoost-Stump是AdaBoost-DTree的一种特殊情况。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a2ee67a9e5ea4302cc9021cf29bf775e.jpg" alt="这里写图片描述" title="" /></p>

        <p>值得一提是，如果树高为1时，通常较难遇到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fe9c1fe9553957a9ff31b6f226055a38.jpg" />的情况，且一般不采用sampling的操作，而是直接将权重u代入到算法中。这是因为此时的AdaBoost-DTree就相当于是AdaBoost-Stump，而AdaBoost-Stump就是直接使用u来优化模型的。</p>

        <h3 id="optimization-view-of-adaboost" class="sigil_not_in_toc"><strong>Optimization View of AdaBoost</strong></h3>

        <p>接下来，我们继续将继续探讨AdaBoost算法的一些奥妙之处。我们知道AdaBoost中的权重的迭代计算如下所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/debe9b24fb26cecae83bf5ef378538ad.jpg" alt="这里写图片描述" title="" /></p>

        <p>之前对于incorrect样本和correct样本，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2894b6a675c0fb8a35bbcf881e375efb.jpg" />的表达式不同。现在，把两种情况结合起来，将<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2894b6a675c0fb8a35bbcf881e375efb.jpg" />写成一种简化的形式：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b06691a00f8cba18c3f1f1da566e9c8e.jpg" /></p>

        <p>其中，对于incorrect样本，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b3fe1e35c43ec9a65b7cf79d9219d026.jpg" />，对于correct样本，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a7e0d436399e1879b91587416db66b3b.jpg" />。从上式可以看出，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2894b6a675c0fb8a35bbcf881e375efb.jpg" />由<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/41b5bc38db46319c44f9c547817f73db.jpg" />与某个常数相乘得到。所以，最后一轮更新的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a7f957fd48c2cc6455c17dd3d4a5d0f.jpg" />可以写成<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/73e2b94bec483f27245d7cfbf2e7d043.jpg" />的级联形式，我们之前令<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ac7d30b4f97388a5512df744845f9ad4.jpg" />，则有如下推导：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ddbf2d97f159cd111dcb393f2e5e75d4.jpg" /></p>

        <p>上式中<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7d74f95d4c3e965e25102a4a9ccb2239.jpg" />被称为voting score，最终的模型<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7e427832566c4ea1d3492fb0780c9758.jpg" />。可以看出，在AdaBoost中，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a7f957fd48c2cc6455c17dd3d4a5d0f.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/12bbe493521477a8ee572cc8327d4746.jpg" />成正比。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/57ac34b520525c4efb50e3a6a2b6a741.jpg" alt="这里写图片描述" title="" /></p>

        <p>接下来我们继续看一下voting score中蕴含了哪些内容。如下图所示，voting score由许多<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1d768b793875ea4602e56a1cb2feb04a.jpg" />乘以各自的系数<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />线性组合而成。从另外一个角度来看，我们可以把<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1d768b793875ea4602e56a1cb2feb04a.jpg" />看成是对<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />的特征转换<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f9b5f7ad8489157f13297606969fa12b.jpg" />，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />就是线性模型中的权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7c33d0107578f4b8c92b64cbc2044221.jpg" />。看到这里，我们回忆起之前SVM中，w与<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d721754e47f0da85a06ecc878acfd7e3.jpg" />的乘积再除以w的长度就是margin，即点到边界的距离。另外，乘积项再与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd32e7f8488e6575c81fd5ec787f53a7.jpg" />相乘，表示点的位置是在正确的那一侧还是错误的那一侧。所以，回过头来，这里的voting
            score实际上可以看成是没有正规化（没有除以w的长度）的距离，即可以看成是该点到分类边界距离的一种衡量。从效果上说，距离越大越好，也就是说voting score要尽可能大一些。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f236947e613aa856f3a6834d9341d8e4.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们再来看，若voting score与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd32e7f8488e6575c81fd5ec787f53a7.jpg" />相乘，则表示一个有对错之分的距离。也就是说，如果二者相乘是负数，则表示该点在错误的一边，分类错误；如果二者相乘是正数，则表示该点在正确的一边，分类正确。所以，我们算法的目的就是让<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd32e7f8488e6575c81fd5ec787f53a7.jpg" />与voting score的乘积是正的，而且越大越好。那么在刚刚推导的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a7f957fd48c2cc6455c17dd3d4a5d0f.jpg" />中，得到<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c3afc0865b3dc5a3efbe170723436831.jpg" />越小越好，从而得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a7f957fd48c2cc6455c17dd3d4a5d0f.jpg" />越小越好。也就是说，如果voting
            score表现不错，与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd32e7f8488e6575c81fd5ec787f53a7.jpg" />的乘积越大的话，那么相应的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a7f957fd48c2cc6455c17dd3d4a5d0f.jpg" />应该是最小的。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c25ce9f190965d755cf2314fd1fd246d.jpg" alt="这里写图片描述" title="" /></p>

        <p>那么在AdaBoost中，随着每轮学习的进行，每个样本的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/41b5bc38db46319c44f9c547817f73db.jpg" />是逐渐减小的，直到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a7f957fd48c2cc6455c17dd3d4a5d0f.jpg" />最小。以上是从单个样本点来看的。总体来看，所有样本的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a7f957fd48c2cc6455c17dd3d4a5d0f.jpg" />之和应该也是最小的。我们的目标就是在最后一轮（T+1）学习后，让所有样本的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a7f957fd48c2cc6455c17dd3d4a5d0f.jpg" />之和尽可能地小。<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a7f957fd48c2cc6455c17dd3d4a5d0f.jpg" />之和表示为如下形式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4f87a58f5f145ef50afe0e4f716200e4.jpg" alt="这里写图片描述" title="" /></p>

        <p>上式中，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7d74f95d4c3e965e25102a4a9ccb2239.jpg" />被称为linear score，用s表示。对于0/1 error：若ys&lt;0，则<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/58b16d0edb128d309537fa9cd8ae8b35.jpg" />；若ys&gt;=0，则<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a9e6115d6ac3e822fa95762e17389549.jpg" />。如下图右边黑色折线所示。对于上式中提到的指数error，即<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/85d994ff590ce29d5eed0e710d58b3a4.jpg" />，随着ys的增加，error单调下降，且始终落在0/1
            error折线的上面。如下图右边蓝色曲线所示。很明显，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6987d8cf9c0b07462be3e9ced0e7e792.jpg" />可以看成是0/1
            error的上界。所以，我们可以使用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6987d8cf9c0b07462be3e9ced0e7e792.jpg" />来替代0/1 error，能达到同样的效果。从这点来说，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d8b9c6f0cdc6c0b65fb9d024971fa039.jpg" />可以看成是一种error measure，而我们的目标就是让其最小化，求出最小值时对应的各个<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1d768b793875ea4602e56a1cb2feb04a.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4cb74b5bdbf603ba1fb39816226739e1.jpg" alt="这里写图片描述" title="" /></p>

        <p>下面我们来研究如何让<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d8b9c6f0cdc6c0b65fb9d024971fa039.jpg" />取得最小值，思考是否能用梯度下降（gradient
            descent）的方法来进行求解。我们之前介绍过gradient descent的核心是在某点处做一阶泰勒展开：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/94c8502e1694a62c3359f1d9feb91eb5.jpg" alt="这里写图片描述" title="" /></p>

        <p>其中，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/46064cf8b27e1ac7d12ad6607a747a10.jpg" />是泰勒展开的位置，v是所要求的下降的最好方向，它是梯度<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/299c936afe5797ad30d79fa63e8f4fb5.jpg" />的反方向，而<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />是每次前进的步长。则每次沿着当前梯度的反方向走一小步，就会不断逼近谷底（最小值）。这就是梯度下降算法所做的事情。</p>

        <p>现在，我们对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b02db3b1b0d4dda94b80760b1be2bca6.jpg" />做梯度下降算法处理，区别是这里的方向是一个函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />，而不是一个向量<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/46064cf8b27e1ac7d12ad6607a747a10.jpg" />。其实，函数和向量的唯一区别就是一个下标是连续的，另一个下标是离散的，二者在梯度下降算法应用上并没有大的区别。因此，按照梯度下降算法的展开式，做出如下推导：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ce8439c871562ec9f0905f6f033cd6ef.jpg" alt="这里写图片描述" title="" /></p>

        <p>上式中，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/209fecd898b7fd5cb96b521679d9cfc2.jpg" />表示当前的方向，它是一个矩，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />是沿着当前方向前进的步长。我们要求出这样的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/209fecd898b7fd5cb96b521679d9cfc2.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />，使得<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b02db3b1b0d4dda94b80760b1be2bca6.jpg" />是在不断减小的。当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b02db3b1b0d4dda94b80760b1be2bca6.jpg" />取得最小值的时候，那么所有的方向即最佳的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/209fecd898b7fd5cb96b521679d9cfc2.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />就都解出来了。上述推导使用了在<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/82b9dab223e14e4f830fb223425b9b99.jpg" />处的一阶泰勒展开近似。这样经过推导之后，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b02db3b1b0d4dda94b80760b1be2bca6.jpg" />被分解为两个部分，一个是前N个u之和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d87c677023567584f832fea91e1093fc.jpg" />，也就是当前所有的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />之和；另外一个是包含下一步前进的方向<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/209fecd898b7fd5cb96b521679d9cfc2.jpg" />和步进长度<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />的项<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9e9a3849f85bdff2b1f483b4c15aef06.jpg" />。<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b02db3b1b0d4dda94b80760b1be2bca6.jpg" />的这种形式与gradient
            descent的形式基本是一致的。</p>

        <p>那么接下来，如果要最小化<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b02db3b1b0d4dda94b80760b1be2bca6.jpg" />的话，就要让第二项<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9e9a3849f85bdff2b1f483b4c15aef06.jpg" />越小越好。则我们的目标就是找到一个好的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/209fecd898b7fd5cb96b521679d9cfc2.jpg" />（即好的方向）来最小化<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5990d425117ae31565229f2bad6ecaa7.jpg" />，此时先忽略步进长度<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c664d0daaf4473ee8f373b128538db03.jpg" alt="这里写图片描述" title="" /></p>

        <p>对于binary classification，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd32e7f8488e6575c81fd5ec787f53a7.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/209fecd898b7fd5cb96b521679d9cfc2.jpg" />均限定取值-1或+1两种。我们对<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5990d425117ae31565229f2bad6ecaa7.jpg" />做一些推导和平移运算：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e44e0fe84c3436e70109a8123a7546d9.jpg" alt="这里写图片描述" title="" /></p>

        <p>最终<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5990d425117ae31565229f2bad6ecaa7.jpg" />化简为两项组成，一项是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/86076b05032905b66eb670b65494c691.jpg" />；另一项是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9d16c16355259fb8aae945e5178ef8bf.jpg" />。则最小化<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5990d425117ae31565229f2bad6ecaa7.jpg" />就转化为最小化<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a87734d8a2e7ae1471d91097f1e90a59.jpg" />。要让<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a87734d8a2e7ae1471d91097f1e90a59.jpg" />最小化，正是由AdaBoost中的base
            algorithm所做的事情。所以说，AdaBoost中的base algorithm正好帮我们找到了梯度下降中下一步最好的函数方向。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/63ee18ab67a037667fa15c5577381047.jpg" alt="这里写图片描述" title="" /></p>

        <p>以上就是从数学上，从gradient descent角度验证了AdaBoost中使用base algorithm得到的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />就是让<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b02db3b1b0d4dda94b80760b1be2bca6.jpg" />减小的方向，只不过这个方向是一个函数而不是向量。</p>

        <p>在解决了方向问题后，我们需要考虑步进长度<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />如何选取。方法是在确定方向<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />后，选取合适的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />，使<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b02db3b1b0d4dda94b80760b1be2bca6.jpg" />取得最小值。也就是说，把<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b02db3b1b0d4dda94b80760b1be2bca6.jpg" />看成是步进长度<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />的函数，目标是找到<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b02db3b1b0d4dda94b80760b1be2bca6.jpg" />最小化时对应的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />值。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/94a5dadcdfabc37b1ced8c6de1eb23ff.jpg" alt="这里写图片描述" title="" /></p>

        <p>目的是找到在最佳方向上的最大步进长度，也就是steepest decent。我们先把<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b02db3b1b0d4dda94b80760b1be2bca6.jpg" />表达式写下来：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7074a88973946d40de397a9d53a2884f.jpg" /></p>

        <p>上式中，有两种情况需要考虑：</p>

        <ul>
            <li>
                <p><strong><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3e7054a2506d2e20658f679b1dbbe035.jpg" />：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/68f5f4d3e9c861be78711e7aec460712.jpg" />
                        correct</strong></p>
            </li>
            <li>
                <p><strong><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f60f4669964f3489941870c1cc0be728.jpg" />：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aeb05d2aa3530cafcfe1b2494b088a7c.jpg" />
                        incorrect</strong></p>
            </li>
        </ul>

        <p>经过推导，可得：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3548e0ba90e1d394f1ceace3de1e81b7.jpg" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/39d36b53cc5887d645ed865ea4f477e3.jpg" alt="这里写图片描述" title="" /></p>

        <p>然后对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />求导，令<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/60cb7a767dde854eaf4f906f160d1ec6.jpg" />，得：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0cc0243f9215a8314f157e0d14c99a74.jpg" /></p>

        <p>由此看出，最大的步进长度就是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />，即AdaBoost中计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />所占的权重。所以，AdaBoost算法所做的其实是在gradient
            descent上找到下降最快的方向和最大的步进长度。这里的方向就是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />，它是一个函数，而步进长度就是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />。也就是说，在AdaBoost中确定<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8140acd2df093e6980aedb817e79b64a.jpg" />的过程就相当于在gradient descent上寻找最快的下降方向和最大的步进长度。</p>

        <h3 id="gradient-boosting" class="sigil_not_in_toc"><strong>Gradient Boosting</strong></h3>

        <p>前面我们从gradient descent的角度来重新介绍了AdaBoost的最优化求解方法。整个过程可以概括为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f266408fa78d167c260129f62679114c.jpg" alt="这里写图片描述" title="" /></p>

        <p>以上是针对binary classification问题。如果往更一般的情况进行推广，对于不同的error function，比如logistic error
            function或者regression中的squared error function，那么这种做法是否仍然有效呢？这种情况下的GradientBoost可以写成如下形式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/78d0d8f7831b25b7f06dd43e3142f2e0.jpg" alt="这里写图片描述" title="" /></p>

        <p>仍然按照gradient descent的思想，上式中，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/209fecd898b7fd5cb96b521679d9cfc2.jpg" />是下一步前进的方向，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />是步进长度。此时的error
            function不是前面所讲的exp了，而是任意的一种error function。因此，对应的hypothesis也不再是binary
            classification，最常用的是实数输出的hypothesis，例如regression。最终的目标也是求解最佳的前进方向<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/209fecd898b7fd5cb96b521679d9cfc2.jpg" />和最快的步进长度<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ec69185ce51c7d8b7a264ac1aba8db9e.jpg" alt="这里写图片描述" title="" /></p>

        <p>接下来，我们就来看看如何求解regression的GradientBoost问题。它的表达式如下所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9749c95dbb5f0ee1c4f25d88b2dc0b0c.jpg" alt="这里写图片描述" title="" /></p>

        <p>利用梯度下降的思想，我们把上式进行一阶泰勒展开，写成梯度的形式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3a2a8cec9c048f0eb9773ab58fccaccb.jpg" alt="这里写图片描述" title="" /></p>

        <p>上式中，由于regression的error function是squared的，所以，对s的导数就是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b95a6d17e09539d8a0ea8045ed453b72.jpg" />。其中标注灰色的部分表示常数，对最小化求解并没有影响，所以可以忽略。很明显，要使上式最小化，只要令<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/209fecd898b7fd5cb96b521679d9cfc2.jpg" />是梯度<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b95a6d17e09539d8a0ea8045ed453b72.jpg" />的反方向就行了，即<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ed247b3dfb6998b4c904b3a8ff6339a9.jpg" />。但是直接这样赋值，并没有对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/209fecd898b7fd5cb96b521679d9cfc2.jpg" />的大小进行限制，一般不直接利用这个关系求出<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/209fecd898b7fd5cb96b521679d9cfc2.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/13216a0c08f5a4ea5c15a70713491e37.jpg" alt="这里写图片描述" title="" /></p>

        <p>实际上<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/209fecd898b7fd5cb96b521679d9cfc2.jpg" />的大小并不重要，因为有步进长度<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />。那么，我们上面的最小化问题中需要对<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/209fecd898b7fd5cb96b521679d9cfc2.jpg" />的大小做些限制。限制<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/209fecd898b7fd5cb96b521679d9cfc2.jpg" />的一种简单做法是把<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/209fecd898b7fd5cb96b521679d9cfc2.jpg" />的大小当成一个惩罚项（<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b8dc246ab469a6f8d3cf0d369808d9e8.jpg" />）添加到上面的最小化问题中，这种做法与regularization类似。如下图所示，经过推导和整理，忽略常数项，我们得到最关心的式子是：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3c44991594d1589ea55483bc2745c5f8.jpg" /></p>

        <p>上式是一个完全平方项之和，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5066bbbc76f0b4e1577b75b464d9dd7a.jpg" />表示当前第n个样本真实值和预测值的差，称之为余数。余数表示当前预测能够做到的效果与真实值的差值是多少。那么，如果我们想要让上式最小化，求出对应的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/209fecd898b7fd5cb96b521679d9cfc2.jpg" />的话，只要让<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/209fecd898b7fd5cb96b521679d9cfc2.jpg" />尽可能地接近余数<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5066bbbc76f0b4e1577b75b464d9dd7a.jpg" />即可。在平方误差上尽可能接近其实很简单，就是使用regression的方法，对所有N个点<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/60db66cd54c984f4827ed63a6c0e48c1.jpg" />做squared-error的regression，得到的回归方程就是我们要求的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1d768b793875ea4602e56a1cb2feb04a.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/564f6d918a72ef240f42e7c6e8b9bf1f.jpg" alt="这里写图片描述" title="" /></p>

        <p>以上就是使用GradientBoost的思想来解决regression问题的方法，其中应用了一个非常重要的概念，就是余数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5066bbbc76f0b4e1577b75b464d9dd7a.jpg" />。根据这些余数做regression，得到好的矩<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1d768b793875ea4602e56a1cb2feb04a.jpg" />，方向函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1d768b793875ea4602e56a1cb2feb04a.jpg" />也就是由余数决定的。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/afb4a00292931085b5746458085d48ae.jpg" alt="这里写图片描述" title="" /></p>

        <p>在求出最好的方向函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1d768b793875ea4602e56a1cb2feb04a.jpg" />之后，就要来求相应的步进长度<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />。表达式如下：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cb554b581b4818adf30a39878514272f.jpg" alt="这里写图片描述" title="" /></p>

        <p>同样，对上式进行推导和化简，得到如下表达式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fa41edcdf7fd11e3d5d36c847cd4f3f9.jpg" alt="这里写图片描述" title="" /></p>

        <p>上式中也包含了余数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5066bbbc76f0b4e1577b75b464d9dd7a.jpg" />，其中<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1d768b793875ea4602e56a1cb2feb04a.jpg" />可以看成是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />的特征转换，是已知量。那么，如果我们想要让上式最小化，求出对应的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />的话，只要让<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cbc0beecc4fbd9e859e442acfbc007db.jpg" />尽可能地接近余数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5066bbbc76f0b4e1577b75b464d9dd7a.jpg" />即可。显然，这也是一个regression问题，而且是一个很简单的形如y=ax的线性回归，只有一个未知数<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />。只要对所有N个点<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/394dfb30a05376f085c44f1a3c30d1b3.jpg" />做squared-error的linear
            regression，利用梯度下降算法就能得到最佳的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />。</p>

        <p>将上述这些概念合并到一起，我们就得到了一个最终的演算法Gradient Boosted Decision Tree(GBDT)。可能有人会问，我们刚才一直没有说到Decison
            Tree，只是讲到了GradientBoost啊？下面我们来看看Decison Tree究竟是在哪出现并使用的。其实刚刚我们在计算方向函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的时候，是对所有N个点<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/60db66cd54c984f4827ed63a6c0e48c1.jpg" />做squared-error的regression。那么这个回归算法就可以是决策树C&amp;RT模型（决策树也可以用来做regression）。这样，就引入了Decision
            Tree，并将GradientBoost和Decision Tree结合起来，构成了真正的GBDT算法。GBDT算法的基本流程图如下所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6c54625c90106ce8cf0e732648deb268.jpg" alt="这里写图片描述" title="" /></p>

        <p>值得注意的是，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/584ff0d1b52eb036995dea37498a8a66.jpg" />的初始值一般均设为0，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/afe6c90a7ac152b131f3ce7c388639ce.jpg" />。每轮迭代中，方向函数<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />通过C&amp;RT算法做regression，进行求解；步进长度<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />通过简单的单参数线性回归进行求解；然后每轮更新<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/584ff0d1b52eb036995dea37498a8a66.jpg" />的值，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2595c53485e1094051446019e69df6b7.jpg" />。T轮迭代结束后，最终得到<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/af7f57a323356e7bf2b07844a6117d84.jpg" />。</p>

        <p>值得一提的是，本节课第一部分介绍的AdaBoost-DTree是解决binary
            classification问题，而此处介绍的GBDT是解决regression问题。二者具有一定的相似性，可以说GBDT就是AdaBoost-DTree的regression版本。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7561dce0267f06052a263120b23be29e.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="summary-of-aggregation-models" class="sigil_not_in_toc"><strong>Summary of Aggregation Models</strong></h3>

        <p>从机器学习技法课程的第7节课笔记到现在的第11节课笔记，我们已经介绍完所有的aggregation模型了。接下来，我们将对这些内容进行一个简单的总结和概括。</p>

        <p>首先，我们介绍了blending。blending就是将所有已知的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />
            aggregate结合起来，发挥集体的智慧得到G。值得注意的一点是这里的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />都是已知的。blending通常有三种形式：</p>

        <ul>
            <li>
                <p><strong>uniform：简单地计算所有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的平均值</strong></p>
            </li>
            <li>
                <p><strong>non-uniform：所有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的线性组合</strong></p>
            </li>
            <li>
                <p><strong>conditional：所有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的非线性组合</strong></p>
            </li>
        </ul>

        <p>其中，uniform采用投票、求平均的形式更注重稳定性；而non-uniform和conditional追求的更复杂准确的模型，但存在过拟合的危险。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bda053dad3d5026912fb3052c59f60f9.jpg" alt="这里写图片描述" title="" /></p>

        <p>刚才讲的blending是建立在所有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />已知的情况。那如果所有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />未知的情况，对应的就是learning模型，做法就是一边学<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />，一边将它们结合起来。learning通常也有三种形式（与blending的三种形式一一对应）：</p>

        <ul>
            <li>
                <p><strong>Bagging：通过bootstrap方法，得到不同<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />，计算所有<img
                            src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的平均值</strong></p>
            </li>
            <li>
                <p><strong>AdaBoost：通过bootstrap方法，得到不同<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />，所有<img
                            src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的线性组合</strong></p>
            </li>
            <li>
                <p><strong>Decision Tree：通过数据分割的形式得到不同的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />，所有<img
                            src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />的非线性组合</strong></p>
            </li>
        </ul>

        <p>然后，本节课我们将AdaBoost延伸到另一个模型GradientBoost。对于regression问题，GradientBoost通过residual fitting的方式得到最佳的方向函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />和步进长度<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14e6a804a95c0f4a8f841691fe2ad0c4.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c3969edd151c5527591e6fb1112e3799.jpg" alt="这里写图片描述" title="" /></p>

        <p>除了这些基本的aggregation模型之外，我们还可以把某些模型结合起来得到新的aggregation模型。例如，Bagging与Decision Tree结合起来组成了Random Forest。Random
            Forest中的Decision Tree是比较“茂盛”的树，即每个树的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />都比较强一些。AdaBoost与Decision
            Tree结合组成了AdaBoost-DTree。AdaBoost-DTree的Decision Tree是比较“矮弱”的树，即每个树的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />都比较弱一些，由AdaBoost将所有弱弱的树结合起来，让综合能力更强。同样，GradientBoost与Decision
            Tree结合就构成了经典的算法GBDT。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/54dedca61435ce209fa88921edf14a7a.jpg" alt="这里写图片描述" title="" /></p>

        <p>Aggregation的核心是将所有的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />结合起来，融合到一起，即集体智慧的思想。这种做法之所以能得到很好的模型G，是因为aggregation具有两个方面的优点：cure
            underfitting和cure overfitting。</p>

        <p>第一，aggregation models有助于防止欠拟合（underfitting）。它把所有比较弱的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />结合起来，利用集体智慧来获得比较好的模型G。aggregation就相当于是feature
            transform，来获得复杂的学习模型。</p>

        <p>第二，aggregation models有助于防止过拟合（overfitting）。它把所有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />进行组合，容易得到一个比较中庸的模型，类似于SVM的large
            margin一样的效果，从而避免一些极端情况包括过拟合的发生。从这个角度来说，aggregation起到了regularization的效果。</p>

        <p>由于aggregation具有这两个方面的优点，所以在实际应用中aggregation models都有很好的表现。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/590d005abe4f17aa7e951229cdf6c7cc.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="总结" class="sigil_not_in_toc"><strong>总结</strong></h3>

        <p>本节课主要介绍了Gradient Boosted Decision Tree。首先讲如何将AdaBoost与Decision Tree结合起来，即通过sampling和pruning的方法得到AdaBoost-D
            Tree模型。然后，我们从optimization的角度来看AdaBoost，找到好的hypothesis也就是找到一个好的方向，找到权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/82005cc2e0087e2a52c7e43df4a19a00.jpg" />也就是找到合适的步进长度。接着，我们从binary
            classification的0/1 error推广到其它的error function，从Gradient Boosting角度推导了regression的squared error形式。Gradient
            Boosting其实就是不断迭代，做residual fitting。并将其与Decision Tree算法结合，得到了经典的GBDT算法。最后，我们将所有的aggregation
            models做了总结和概括，这些模型有的能防止欠拟合有的能防止过拟合，应用十分广泛。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习技法》课程</p>

        <p><strong>更多AI资源请关注公众号：红色石头的机器学习之路（ID：redstonewill）</strong> <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5f84203244b34f14c4b5b8d1289cdeb4.jpg" alt="这里写图片描述" title="" /></p>
    </div>

    <h1 class="title-article">12 -- Neural Network</h1>
    <div class="markdown_views">
        <blockquote>
            <p>红色石头的个人网站：<a href="http://redstonewill.com/" rel="nofollow">redstonewill.com</a></p>
        </blockquote>

        <p>上节课我们主要介绍了Gradient Boosted Decision Tree。GBDT通过使用functional gradient的方法得到一棵一棵不同的树，然后再使用steepest
            descent的方式给予每棵树不同的权重，最后可以用来处理任何而定error measure。上节课介绍的GBDT是以regression为例进行介绍的，使用的是squared error
            measure。本节课讲介绍一种出现时间较早，但当下又非常火的一种机器算法模型，就是神经网络（Neural Network）。</p>

        <h3 id="motivation" class="sigil_not_in_toc"><strong>Motivation</strong></h3>

        <p>在之前的机器学习基石课程中，我们就接触过Perceptron模型了，例如PLA算法。Perceptron就是在矩<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a4131ab539ff96aa53dce85b56410010.jpg" />外面加上一个sign函数，取值为{-1,+1}。现在，如果把许多perceptrons线性组合起来，得到的模型G就如下图所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/64b1a469039cf56b9521986fb29bb32e.jpg" alt="这里写图片描述" title="" /></p>

        <p>将左边的输入<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c87d3a7995693c0d045f870533f7e0ef.jpg" />与T个不同的权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/687b3d6191a6de00e904f5d641d1d7f4.jpg" />相乘（每个<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7c33d0107578f4b8c92b64cbc2044221.jpg" />是d+1维的），得到T个不同的perceptrons为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c4d2ce0186d93c4c7b67d7b7ed5581e8.jpg" />。最后，每个<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />给予不同的权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a0c62f457b87122ddef3f3206a6f792d.jpg" />，线性组合得到G。G也是一个perceptron模型。</p>

        <p>从结构上来说，上面这个模型包含了两层的权重，分别是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/46064cf8b27e1ac7d12ad6607a747a10.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/82005cc2e0087e2a52c7e43df4a19a00.jpg" />。同时也包含了两层的sign函数，分别是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />和G。那么这样一个由许多感知机linear
            aggregation的模型能实现什么样的boundary呢？</p>

        <p>举个简单的例子，如下图所示，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/098d359092c821d17fb2252ea6026951.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5d14f76946479b52a3dd77916314157c.jpg" />分别是平面上两个perceptrons。其中，红色表示-1，蓝色表示+1。这两个perceptrons线性组合可能得到下图右侧的模型，这表示的是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/098d359092c821d17fb2252ea6026951.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5d14f76946479b52a3dd77916314157c.jpg" />进行与（AND）的操作，蓝色区域表示+1。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4c06a1043967bee2cab3427a4a090c87.jpg" alt="这里写图片描述" title="" /></p>

        <p>如何通过感知机模型来实现上述的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/eda743b35823598d3cb2028caa40d695.jpg" />逻辑操作呢？一种方法是令第二层中的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/49cb96aeb56656f7ef383cba3754d435.jpg" />。这样，G(x)就可表示为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0c59903ce370162fb6fdbefc2f2a7c57.jpg" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/098d359092c821d17fb2252ea6026951.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5d14f76946479b52a3dd77916314157c.jpg" />的取值是{-1,+1}，当<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/60f9292facb2a31c781806602b4b6b67.jpg" />时，G(x)=0；当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8434a7e946872235da255d719517e76.jpg" />时，G(x)=0；当<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/54bf4ac43fdb17aeb563303c42602708.jpg" />时，G(x)=0；当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9291b780fa4ea70a8bd76568f309f209.jpg" />时，G(x)=1。感知机模型如下所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/349726504ec2c616ccfc895043c92e4e.jpg" alt="这里写图片描述" title="" /></p>

        <p>这个例子说明了一些简单的线性边界，如上面的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/098d359092c821d17fb2252ea6026951.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5d14f76946479b52a3dd77916314157c.jpg" />，在经过一层感知机模型，经线性组合后，可以得到一些非线性的复杂边界（AND运算）G(x)。</p>

        <p>除此之外，或（OR）运算和非（NOT）运算都可以由感知机建立相应的模型，非常简单。</p>

        <p>所以说，linear aggregation of
            perceptrons实际上是非常powerful的模型同时也是非常complicated模型。再看下面一个例子，如果二维平面上有个圆形区域，圆内表示+1，圆外表示-1。这样复杂的圆形边界是没有办法使用单一perceptron来解决的。如果使用8个perceptrons，用刚才的方法线性组合起来，能够得到一个很接近圆形的边界（八边形）。如果使用16个perceptrons，那么得到的边界更接近圆形（十六边形）。因此，使用的perceptrons越多，就能得到各种任意的convex
            set，即凸多边形边界。之前我们在机器学习基石中介绍过，convex set的VC Dimension趋向于无穷大（<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/263d556f5792c056c8687688165cfe06.jpg" />）。这表示只要perceptrons够多，我们能得到任意可能的情况，可能的模型。但是，这样的坏处是模型复杂度可能会变得很大，从而造成过拟合（overfitting）。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14c912835c41566b43a7592c7a290757.jpg" alt="这里写图片描述" title="" /></p>

        <p>总的来说，足够数目的perceptrons线性组合能够得到比较平滑的边界和稳定的模型，这也是aggregation的特点之一。</p>

        <p>但是，也有单层perceptrons线性组合做不到的事情。例如刚才我们将的AND、OR、NOT三种逻辑运算都可以由单层perceptrons做到，而如果是异或（XOR）操作，就没有办法只用单层perceptrons实现。这是因为XOR得到的是非线性可分的区域，如下图所示，没有办法由<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/098d359092c821d17fb2252ea6026951.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5d14f76946479b52a3dd77916314157c.jpg" />线性组合实现。所以说linear
            aggregation of perceptrons模型的复杂度还是有限制的。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c8e799aa9f60765e097a756a18da0327.jpg" alt="这里写图片描述" title="" /></p>

        <p>那么，为了实现XOR操作，可以使用多层perceptrons，也就是说一次transform不行，我们就用多层的transform，这其实就是Basic Neural
            Network的基本原型。下面我们就尝试使用两层perceptrons来实现XOR的操作。</p>

        <p>首先，根据布尔运算，异或XOR操作可以拆分成：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1ce5340ee1c1e0a9af94141dc3335af6.jpg" /></p>

        <p>这种拆分实际上就包含了两层transform。第一层仅有AND操作，第二层是OR操作。这种两层的感知机模型如下所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4cfd74e094594ba9af2f44e06949b6fc.jpg" alt="这里写图片描述" title="" /></p>

        <p>这样，从AND操作到XOR操作，从简单的aggregation of perceptrons到multi-layer
            perceptrons，感知机层数在增加，模型的复杂度也在增加，使最后得到的G能更容易解决一些非线性的复杂问题。这就是基本神经网络的基本模型。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/189a6004b9546d5f273907ddaa61816c.jpg" alt="这里写图片描述" title="" /></p>

        <p>顺便提一下，这里所说的感知机模型实际上就是在模仿人类的神经元模型（这就是Neural
            Network名称的由来）。感知机模型每个节点的输入就对应神经元的树突dendrite，感知机每个节点的输出就对应神经元的轴突axon。</p>

        <h3 id="neural-network-hypothesis" class="sigil_not_in_toc"><strong>Neural Network Hypothesis</strong></h3>

        <p>上一部分我们介绍的这种感知机模型其实就是Neural
            Network。输入部分经过一层一层的运算，相当于一层一层的transform，最后通过最后一层的权重，得到一个分数score。即在OUTPUT层，输出的就是一个线性模型。得到s后，下一步再进行处理。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/243e52c816ff5bf6aaf00f6dbfdaa1fa.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们之前已经介绍过三种线性模型：linear classification，linear regression，logistic
            regression。那么，对于OUTPUT层的分数s，根据具体问题，可以选择最合适的线性模型。如果是binary classification问题，可以选择linear
            classification模型；如果是linear regression问题，可以选择linear regression模型；如果是soft classification问题，则可以选择logistic
            regression模型。本节课接下来将以linear regression为例，选择squared error来进行衡量。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6939fbebeee3a613f2ca46aab4075c8b.jpg" alt="这里写图片描述" title="" /></p>

        <p>上面讲的是OUTPUT层，对于中间层，每个节点对应一个perceptron，都有一个transform运算。上文我们已经介绍过的transformation
            function是阶梯函数sign()。那除了sign()函数外，有没有其他的transformation function呢？</p>

        <p>如果每个节点的transformation
            function都是线性运算（跟OUTPUT端一样），那么由每个节点的线性模型组合成的神经网络模型也必然是线性的。这跟直接使用一个线性模型在效果上并没有什么差异，模型能力不强，反而花费了更多不必要的力气。所以一般来说，中间节点不会选择线性模型。</p>

        <p>如果每个节点的transformation
            function都是阶梯函数（即sign()函数）。这是一个非线性模型，但是由于阶梯函数是离散的，并不是处处可导，所以在优化计算时比较难处理。所以，一般也不选择阶梯函数作为transformation
            function。</p>

        <p>既然线性函数和阶梯函数都不太适合作为transformation function，那么最常用的一种transformation function就是tanh(s)，其表达式如下：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/42907d7199c098b93886fb06d44b793c.jpg" /></p>

        <p>tanh(s)函数是一个平滑函数，类似“s”型。当|s|比较大的时候，tanh(s)与阶梯函数相近；当|s|比较小的时候，tanh(s)与线性函数比较接近。从数学上来说，由于处处连续可导，便于最优化计算。而且形状上类似阶梯函数，具有非线性的性质，可以得到比较复杂强大的模型。</p>

        <p>顺便提一下，tanh(x)函数与sigmoid函数存在下列关系：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4d05a9f647b0d58aa87bb1ee5038019d.jpg" /></p>

        <p>其中，</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c7776602faf6f78c91ad9c7d8c42b3cd.jpg" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d7397ef834edf0a25a31625c23db3390.jpg" alt="这里写图片描述" title="" /></p>

        <p>那么，接下来我们就使用tanh函数作为神经网络中间层的transformation function，所有的数学推导也基于此。实际应用中，可以选择其它的transformation
            function，不同的transformation function，则有不同的推导过程。</p>

        <p>下面我们将仔细来看看Neural Network
            Hypothesis的结构。如下图所示，该神经网络左边是输入层，中间两层是隐藏层，右边是输出层。整体上来说，我们设定输入层为第0层，然后往右分别是第一层、第二层，输出层即为第3层。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f2b27398f2f94dd602aa139b61e0739b.jpg" alt="这里写图片描述" title="" /></p>

        <p>Neural Network Hypothesis中，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8ace50502bf16adb160c510a9d36f140.jpg" />分别表示神经网络的第几层，其中L为总层数。例如上图所示的是3层神经网络，L=3。我们先来看看每一层的权重<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14dadf2fbfe175207fc54eedd80f822a.jpg" />，上标l满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/525f531305445390dc0271d9f8f4380d.jpg" />，表示是位于哪一层。下标i满足<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c07ccb2bd49a8ddb2b0d764cdcc82d7c.jpg" />，表示前一层输出的个数加上bias项（常数项）。下标j满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ad74a1a281342557e37d115406e28bf6.jpg" />，表示该层节点的个数（不包括bias项）。</p>

        <p>对于每层的分数score，它的表达式为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fc578c3ac9b69007810ffd2431368407.jpg" /></p>

        <p>对于每层的transformation function，它的表达式为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e99d5d8dbb63083d16a2eff8de45ce0f.jpg" /></p>

        <p>因为是regression模型，所以在输出层（l=L）直接得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fc4f4fc81e59ec3d7c6c4e295f3e230a.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/87d7e9525b06f18e83b2a0a98589bc6a.jpg" alt="这里写图片描述" title="" /></p>

        <p>介绍完Neural Network
            Hypothesis的结构之后，我们来研究下这种算法结构到底有什么实际的物理意义。还是看上面的神经网络结构图，每一层输入到输出的运算过程，实际上都是一种transformation，而转换的关键在于每个权重值<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14dadf2fbfe175207fc54eedd80f822a.jpg" />。每层网络利用输入x和权重w的乘积，在经过tanh函数，得到该层的输出，从左到右，一层一层地进行。其中，很明显，x和w的乘积<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ad38abb30ac004115d20d7ce77854081.jpg" />越大，那么tanh(wx)就会越接近1，表明这种transformation效果越好。再想一下，w和x是两个向量，乘积越大，表明两个向量内积越大，越接近平行，则表明w和x有模式上的相似性。从而，更进一步说明了如果每一层的输入向量x和权重向量w具有模式上的相似性，比较接近平行，那么transformation的效果就比较好，就能得到表现良好的神经网络模型。也就是说，神经网络训练的核心就是pattern
            extraction，即从数据中找到数据本身蕴含的模式和规律。通过一层一层找到这些模式，找到与输入向量x最契合的权重向量w，最后再由G输出结果。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cdb2aca8dc96fb030bf05227f75c3cd0.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="neural-network-learning" class="sigil_not_in_toc"><strong>Neural Network Learning</strong></h3>

        <p>我们已经介绍了Neural Network Hypothesis的结构和算法流程。确定网络结构其实就是确定各层的权重值<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14dadf2fbfe175207fc54eedd80f822a.jpg" />。那如何根据已有的样本数据，找到最佳的权重<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14dadf2fbfe175207fc54eedd80f822a.jpg" />使error最小化呢？下面我们将详细推导。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/54b629b98fd2c95aa707b320cd6782c7.jpg" alt="这里写图片描述" title="" /></p>

        <p>首先，我们的目标是找到最佳的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14dadf2fbfe175207fc54eedd80f822a.jpg" />让<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/070097777c940c4c9e1ab5eaca40dee8.jpg" />最小化。如果只有一层隐藏层，就相当于是aggregation
            of perceptrons。可以使用我们上节课介绍的gradient
            boosting算法来一个一个确定隐藏层每个神经元的权重，输入层到隐藏层的权重可以通过C&amp;RT算法计算的到。这不是神经网络常用的算法。如果隐藏层个数有两个或者更多，那么aggregation of
            perceptrons的方法就行不通了。就要考虑使用其它方法。</p>

        <p>根据error function的思想，从输出层来看，我们可以得到每个样本神经网络预测值与实际值之间的squared error：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3f169c5c1b4032ffa59ee0b121778a89.jpg" />，这是单个样本点的error。那么，我们只要能建立<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75fb59032c7133e35610b1b36ff8cfe2.jpg" />与每个权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14dadf2fbfe175207fc54eedd80f822a.jpg" />的函数关系，就可以利用GD或SGD算法对<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14dadf2fbfe175207fc54eedd80f822a.jpg" />求偏微分，不断迭代优化<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14dadf2fbfe175207fc54eedd80f822a.jpg" />值，最终得到使<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75fb59032c7133e35610b1b36ff8cfe2.jpg" />最小时对应的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14dadf2fbfe175207fc54eedd80f822a.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/80a0ebaf9d180ebb697d3fa6cb6776bd.jpg" alt="这里写图片描述" title="" /></p>

        <p>为了建立<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75fb59032c7133e35610b1b36ff8cfe2.jpg" />与各层权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14dadf2fbfe175207fc54eedd80f822a.jpg" />的函数关系，求出<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75fb59032c7133e35610b1b36ff8cfe2.jpg" />对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14dadf2fbfe175207fc54eedd80f822a.jpg" />的偏导数<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4727f01745d4bd4f66ac62615e7567cf.jpg" />，我们先来看输出层如何计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/edc75c381ebdd02b644279313bc28517.jpg" />。<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75fb59032c7133e35610b1b36ff8cfe2.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/92b55253344c821059b65c917fde1188.jpg" />的函数关系为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c9cf4b8391eefb5ec4cf41decc48c93f.jpg" alt="这里写图片描述" title="" /></p>

        <p>计算<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75fb59032c7133e35610b1b36ff8cfe2.jpg" />对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/92b55253344c821059b65c917fde1188.jpg" />的偏导数，得到：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1ca02e2a8b20ab0788a2f8adb8211729.jpg" alt="这里写图片描述" title="" /></p>

        <p>以上是输出层求偏导的结果。如果是其它层，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/89537b1694318852e302ef637eb8412c.jpg" />，偏导计算可以写成如下形式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bae19a058721b49c421a455e4c3763a6.jpg" alt="这里写图片描述" title="" /></p>

        <p>上述推导中，令<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75fb59032c7133e35610b1b36ff8cfe2.jpg" />与第l层第j个神经元的分数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fad1f704dbbbedd479ee10b01eade90c.jpg" />的偏导数记为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5e039c279530de8d1db0883af30c54f.jpg" />。即：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4fc4ad53d98321bdb6ceaecef91a4160.jpg" /></p>

        <p>当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d1ebfc9239b219bc2a0b3fe526e7a8d5.jpg" />时，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4aeac3a29261da1bb0858fe83e6f9473.jpg" />；当<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/89537b1694318852e302ef637eb8412c.jpg" />时，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5e039c279530de8d1db0883af30c54f.jpg" />是未知的，下面我们将进行运算推导，看看不同层之间的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5e039c279530de8d1db0883af30c54f.jpg" />是否有递推关系。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e4226d5ffb486c0c657879a9f4f7847e.jpg" alt="这里写图片描述" title="" /></p>

        <p>如上图所示，第l层第j个神经元的分数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fad1f704dbbbedd479ee10b01eade90c.jpg" />经过tanh函数，得到该层输出<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bb67ec0bd6240b1f78846f65b2f8bb4e.jpg" />，再与下一层权重<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/53fb1052fa63bc7606ba8c795af4d00c.jpg" />相乘，得到第l+1层的分数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1c1779eb6f3255af301a32dc0c40f838.jpg" />，直到最后的输出层<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75fb59032c7133e35610b1b36ff8cfe2.jpg" />。</p>

        <p>那么，利用上面<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fad1f704dbbbedd479ee10b01eade90c.jpg" />到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1c1779eb6f3255af301a32dc0c40f838.jpg" />这样的递推关系，我们可以对偏导数<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5e039c279530de8d1db0883af30c54f.jpg" />做一些中间变量替换处理，得到如下表达式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5316038efbdda2799175ea112d285386.jpg" alt="这里写图片描述" title="" /></p>

        <p>值得一提的是，上式中有个求和项，其中k表示下一层即l+1层神经元的个数。表明l层的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fad1f704dbbbedd479ee10b01eade90c.jpg" />与l+1层的所有<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/de49e53344aff137c9f42d659a5b01fb.jpg" />都有关系。因为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fad1f704dbbbedd479ee10b01eade90c.jpg" />参与到每个<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/de49e53344aff137c9f42d659a5b01fb.jpg" />的运算中了。</p>

        <p>这样，我们得到了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5e039c279530de8d1db0883af30c54f.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d2c35b4e94903d1be57a9322e7f143d3.jpg" />的递推关系。也就是说如果知道了<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d2c35b4e94903d1be57a9322e7f143d3.jpg" />的值，就能推导出<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5e039c279530de8d1db0883af30c54f.jpg" />的值。而最后一层，即输出层的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4aeac3a29261da1bb0858fe83e6f9473.jpg" />，那么就能一层一层往前推导，得到每一层的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f5e039c279530de8d1db0883af30c54f.jpg" />，从而可以计算出<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75fb59032c7133e35610b1b36ff8cfe2.jpg" />对各个<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14dadf2fbfe175207fc54eedd80f822a.jpg" />的偏导数<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4727f01745d4bd4f66ac62615e7567cf.jpg" />。计算完偏微分之后，就可以使用GD或SGD算法进行权重的迭代优化，最终得到最优解。</p>

        <p>神经网络中，这种从后往前的推导方法称为Backpropagation Algorithm，即我们常常听到的BP神经网络算法。它的算法流程如下所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/509938e597883d0d58e0780ebe049a74.jpg" alt="这里写图片描述" title="" /></p>

        <p>上面采用的是SGD的方法，即每次迭代更新时只取一个点，这种做法一般不够稳定。所以通常会采用mini-batch的方法，即每次选取一些数据，例如<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8a54530d43b050dc281c76417516048a.jpg" />，来进行训练，最后求平均值更新权重w。这种做法的实际效果会比较好一些。</p>

        <h3 id="optimization-and-regularization" class="sigil_not_in_toc"><strong>Optimization and Regularization</strong></h3>

        <p>经过以上的分析和推导，我们知道神经网络优化的目标就是让<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fa6b0684009de027b008aa70202bdda3.jpg" />最小化。本节课我们采用error
            measure是squared error，当然也可以采用其它的错误衡量方式，只要在推导上做稍稍修改就可以了，此处不再赘述。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4165d3fe601245310d2a15de8e1c6daf.jpg" alt="这里写图片描述" title="" /></p>

        <p>下面我们将主要分析神经网络的优化问题。由于神经网络由输入层、多个隐藏层、输出层构成，结构是比较复杂的非线性模型，因此<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fa6b0684009de027b008aa70202bdda3.jpg" />可能有许多局部最小值，是non-convex的，找到全局最小值（globalminimum）就会困难许多。而我们使用GD或SGD算法得到的很可能就是局部最小值（local
            minimum）。</p>

        <p>基于这个问题，不同的初始值权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14dadf2fbfe175207fc54eedd80f822a.jpg" />通常会得到不同的local
            minimum。也就是说最终的输出G与初始权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14dadf2fbfe175207fc54eedd80f822a.jpg" />有很大的关系。在选取<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14dadf2fbfe175207fc54eedd80f822a.jpg" />上有个技巧，就是通常选择比较小的值，而且最好是随机random选择。这是因为，如果权重<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14dadf2fbfe175207fc54eedd80f822a.jpg" />很大，那么根据tanh函数，得到的值会分布在两侧比较平缓的位置（类似于饱和saturation），这时候梯度很小，每次迭代权重可能只有微弱的变化，很难在全局上快速得到最优解。而随机选择的原因是通常对权重<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14dadf2fbfe175207fc54eedd80f822a.jpg" />如何选择没有先验经验，只能通过random，从普遍概率上选择初始值，随机性避免了人为因素的干预，可以说更有可能经过迭代优化得到全局最优解。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/241b0c339460f312a75817f7af1d3df3.jpg" alt="这里写图片描述" title="" /></p>

        <p>下面从理论上看一下神经网络模型的VC Dimension。对于tanh这样的transfer function，其对应的整个模型的复杂度<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2ea7e172ea7f45c883081578c87b4a8f.jpg" />。其中V是神经网络中神经元的个数（不包括bias点）,D表示所有权值的数量。所以，如果V足够大的时候，VC
            Dimension也会非常大，这样神经网络可以训练出非常复杂的模型。但同时也可能会造成过拟合overfitting。所以，神经网络中神经元的数量V不能太大。</p>

        <p>为了防止神经网络过拟合，一个常用的方法就是使用regularization。之前我们就介绍过可以在error function中加入一个regularizer，例如熟悉的L2 regularizer <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/be0cc3545264ee72a7f1eff8e996de73.jpg" />：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/eabaa28e989cc6fee99865d55211ac3c.jpg" /></p>

        <p>但是，使用L2 regularizer
            有一个缺点，就是它使每个权重进行等比例缩小（shrink）。也就是说大的权重缩小程度较大，小的权重缩小程度较小。这会带来一个问题，就是等比例缩小很难得到值为零的权重。而我们恰恰希望某些权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3468842e907e672e6fae253c77ac13a3.jpg" />，即权重的解是松散（sparse）的。因为这样能有效减少VC
            Dimension，从而减小模型复杂度，防止过拟合发生。</p>

        <p>那么为了得到sparse解，有什么方法呢？我们之前就介绍过可以使用L1 regularizer：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c24df885d378bdfa834728db6dc1d3d8.jpg" />，但是这种做法存在一个缺点，就是包含绝对值不容易微分。除此之外，另外一种比较常用的方法就是使用weight-elimination
            regularizer。weight-elimination regularizer类似于L2 regularizer，只不过是在L2 regularizer上做了尺度的缩小，这样能使large
            weight和small weight都能得到同等程度的缩小，从而让更多权重最终为零。weight-elimination regularizer的表达式如下：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/998af6c61e3262b297f797abad96339c.jpg" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/de337b319f742d5c8f607e01c24bca32.jpg" alt="这里写图片描述" title="" /></p>

        <p>除了weight-elimination regularizer之外，还有另外一个很有效的regularization的方法，就是Early
            Stopping。简而言之，就是神经网络训练的次数t不能太多。因为，t太大的时候，相当于给模型寻找最优值更多的可能性，模型更复杂，VC
            Dimension增大，可能会overfitting。而t不太大时，能有效减少VC Dimension，降低模型复杂度，从而起到regularization的效果。<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0962be87afa58c19297be4ab752af67d.jpg" />随训练次数t的关系如下图右下角所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/33475222d4167b0ebb7a01e9add73e62.jpg" alt="这里写图片描述" title="" /></p>

        <p>那么，如何选择最佳的训练次数t呢？可以使用validation进行验证选择。</p>

        <h3 id="总结" class="sigil_not_in_toc"><strong>总结</strong></h3>

        <p>本节课主要介绍了Neural Network模型。首先，我们通过使用一层甚至多层的perceptrons来获得更复杂的非线性模型。神经网络的每个神经元都相当于一个Neural Network
            Hypothesis，训练的本质就是在每一层网络上进行pattern extraction，找到最合适的权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14dadf2fbfe175207fc54eedd80f822a.jpg" />，最终得到最佳的G。本课程以regression模型为例，最终的G是线性模型，而中间各层均采用tanh函数作为transform
            function。计算权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/14dadf2fbfe175207fc54eedd80f822a.jpg" />的方法就是采用GD或者SGD，通过Backpropagation算法，不断更新优化权重值，最终使得<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fa6b0684009de027b008aa70202bdda3.jpg" />最小化，即完成了整个神经网络的训练过程。最后，我们提到了神经网络的可以使用一些regularization来防止模型过拟合。这些方法包括随机选择较小的权重初始值，使用weight-elimination
            regularizer或者early stopping等。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习技法》课程</p>

        <p><strong>更多AI资源请关注公众号：红色石头的机器学习之路（ID：redstonewill）</strong> <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cee1a2d958e1483bfcf25d5bac2e7f55.jpg" alt="这里写图片描述" title="" /></p>
    </div>

    <h1 class="title-article">13 -- Deep Learning</h1>
    <div class="markdown_views">
        <blockquote>
            <p>红色石头的个人网站：<a href="http://redstonewill.com/" rel="nofollow">redstonewill.com</a></p>
        </blockquote>

        <p>上节课我们主要介绍了神经网络Neural Network。神经网络是由一层一层的神经元构成，其作用就是帮助提取原始数据中的模式即特征，简称为pattern feature
            extraction。神经网络模型的关键是计算出每个神经元的权重，方法就是使用Backpropagation算法，利用GD/SGD，得到每个权重的最优解。本节课我们将继续对神经网络进行深入研究，并介绍层数更多、神经元个数更多、模型更复杂的神经网络模型，即深度学习模型。</p>

        <h3 id="deep-neural-network" class="sigil_not_in_toc"><strong>Deep Neural Network</strong></h3>

        <p>总的来说，根据神经网络模型的层数、神经元个数、模型复杂度不同，大致可分为两类：Shallow Neural Networks和Deep Neural
            Networks。上节课介绍的神经网络模型层数较少，属于Shallow Neural Networks，而本节课将着重介绍Deep Neural Networks。首先，比较一下二者之间的优缺点有哪些：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/037c143da84c341ef5afbfffa9e2cf89.jpg" alt="这里写图片描述" title="" /></p>

        <p>值得一提的是，近些年来，deep learning越来越火，尤其在电脑视觉和语音识别等领域都有非常广泛的应用。原因在于一层一层的神经网络有助于提取图像或者语音的一些物理特征，即pattern feature
            extraction，从而帮助人们掌握这些问题的本质，建立准确的模型。</p>

        <p>下面举个例子，来看一下深度学习是如何提取出问题潜在的特征从而建立准确的模型的。如下图所示，这是一个手写识别的问题，简单地识别数字1和数字5。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9f3bc5df19f46b2bc69e2e8c7fc56bd6.jpg" alt="这里写图片描述" title="" /></p>

        <p>如何进行准确的手写识别呢？我们可以将写上数字的图片分解提取出一块一块不同部位的特征。例如左边三幅图每张图代表了数字1的某个部位的特征，三幅图片组合起来就是完整的数字1。右边四幅图也是一样，每张图代表了数字5的某个部位的特征，五幅图组合起来就是完整的数字5。对计算机来说，图片由许多像素点组成。要达到识别的目的，每层神经网络从原始像素中提取出更复杂的特征，再由这些特征对图片内容进行匹配和识别。层数越多，提取特征的个数和深度就越大，同时解决复杂问题的能量就越强，其中每一层都具有相应的物理意义。以上就是深度学习的作用和意义。</p>

        <p>深度学习很强大，同时它也面临很多挑战和困难：</p>

        <ul>
            <li>
                <p><strong>difficult structural decisions</strong></p>
            </li>
            <li>
                <p><strong>high model complexity</strong></p>
            </li>
            <li>
                <p><strong>hard optimization problem</strong></p>
            </li>
            <li>
                <p><strong>huge computational complexity</strong></p>
            </li>
        </ul>

        <p>面对以上深度学习的4个困难，有相应的技术和解决的办法：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e8b69f74d458e191b1cfe6cf359d7d11.jpg" alt="这里写图片描述" title="" /></p>

        <p>其中，最关键的技术就是regularization和initialization。</p>

        <p>深度学习中，权重的初始化选择很重要，好的初始值能够帮助避免出现局部最优解的出现。常用的方法就是pre-train，即先权重进行初始值的选择，选择之后再使用backprop算法训练模型，得到最佳的权重值。在接下来的部分，我们将重点研究pre-training的方法。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0cc0d213b491c84580bb86ab2ca37efd.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="autoencoder" class="sigil_not_in_toc"><strong>Autoencoder</strong></h3>

        <p>我们已经介绍了深度学习的架构，那么从算法模型上来说，如何进行pre-training，得到较好的权重初始值呢？首先，我们来看看，权重是什么？神经网络模型中，权重代表了特征转换（feature
            transform）。从另一个方面也可以说，权重表示一种编码（encoding），就是把数据编码成另外一些数据来表示。因为神经网络是一层一层进行的，有先后顺序，所以就单一层来看，好的权重初始值应该是尽可能地包含了该层输入数据的所有特征，即类似于information-preserving
            encoding。也就是说，能够把第i层的输入数据的特征传输到第i+1层，再把第i+1层的输入数据的特征传输到第i+2层，一层一层进行下去。这样，每层的权重初始值起到了对该层输入数据的编码作用，能够最大限度地保持其特征。</p>

        <p>举个例子，上一小节我们讲了简单的手写识别的例子。从原始的一张像素图片转换到分解的不同笔画特征，那么反过来，这几个笔画特征也可以组合成原来的数字。这种可逆的转换被称为information-preserving，即转换后的特征保留了原输入的特征，而且转换是可逆的。这正是pre-train希望做到的，通过encoding将输入转换为一些特征，而这些特征又可以复原原输入x，实现information-preserving。所以，pre-training得到的权重初始值就应该满足这样的information-preserving特性。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/01c997f76dd36b6b5accda1f4802a05c.jpg" alt="这里写图片描述" title="" /></p>

        <p>如何在pre-training中得到这样的权重初始值（即转换特征）呢？方法是建立一个简单的三层神经网络（一个输入层、一个隐藏层、一个输出层），如下图所示。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ae0f2f55140d03e3a9f81ed0c5c62eca.jpg" alt="这里写图片描述" title="" /></p>

        <p>该神经网络中，输入层是原始数据（即待pre-training的数据），经过权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e98999cf2775df31e3b8d7e639340bbd.jpg" />得到隐藏层的输出为原始数据新的表达方式（即转换特征）。这些转换特征再经过权重<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a1b7ec86f415c3e8bac414ffa0dc2cac.jpg" />得到输出层，输出层的结果要求跟原始数据类似，即输入层和输出层是近似相等的。整个网络是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/de8cbc01283796d37d55cd2bf988d182.jpg" />
            NNet结构。其核心在于“重构性”，从输入层到隐藏层实现特征转换，从隐藏层到输出层实现重构，满足上文所说的information-preserving的特性。这种结构的神经网络我们称之为autoencoder，输入层到隐藏层对应编码，而隐藏层到输出层对应解码。其中，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e98999cf2775df31e3b8d7e639340bbd.jpg" />表示编码权重，而<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a1b7ec86f415c3e8bac414ffa0dc2cac.jpg" />表示解码权重。整个过程类似于在学习如何近似逼近identity
            function。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/260ca59984561fc3e6b9cb1cb4931243.jpg" alt="这里写图片描述" title="" /></p>

        <p>那么为什么要使用这样的结构来逼近identity function，有什么好处呢？首先对于监督式学习（supervised learning），这种<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/de8cbc01283796d37d55cd2bf988d182.jpg" />的NNet结构中含有隐藏层。隐藏层的输出实际上就是对原始数据合理的特征转换<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7e8cdd1914e3f109de96359b361281d5.jpg" />，例如手写识别中隐藏层分解的各个笔画，包含了有用的信息。这样就可以从数据中学习得到一些有用的具有代表性的信息。然后，对于非监督式学习（unsupervised
            learning），autoencoder也可以用来做density estimation。如果网络最终的输出<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2d0e7c0053cbf226a6933dde58d5b3bb.jpg" />，则表示密度较大；如果g(x)与x相差甚远，则表示密度较小。也就是说可以根据g(x)与x的接近程度来估计测试数据是落在密度较大的地方还是密度较小的地方。这种方法同样适用于outlier
            detection，异常检测。这样就可以从数据中学习得到一些典型的具有代表性的信息，找出哪些是典型资料，哪些不是典型资料。所以说，通过autoencoder不断逼近identity
            function，对监督式学习和非监督式学习都具有深刻的物理意义和非常广泛的应用。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1ab96fdd6051c5674536c32ab43b0691.jpg" alt="这里写图片描述" title="" /></p>

        <p>其实，对于autoencoder来说，我们更关心的是网络中间隐藏层，即原始数据的特征转换以及特征转换的编码权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e98999cf2775df31e3b8d7e639340bbd.jpg" />。</p>

        <p>Basic Autoencoder一般采用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/de8cbc01283796d37d55cd2bf988d182.jpg" />的NNet结构，对应的error
            function是squared error，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0e19f1d85bb6c285e28ff34819a975d8.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/da515b8c4a71b9f3ade83d0639565ede.jpg" alt="这里写图片描述" title="" /></p>

        <p>basic autoencoder在结构上比较简单，只有三层网络，容易训练和优化。各层之间的神经元数量上，通常限定<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/628f95ce22e39fc84a9ab87153b03871.jpg" />，便于数据编码。数据集可表示为：<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cdcf579c599ff8de7672e5d1bd523ce7.jpg" />，即输入输出都是x，可以看成是非监督式学习。一个重要的限制条件是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2d29f975e53ac1d8f01b00978e42bfa6.jpg" />，即编码权重与解码权重相同。这起到了regularization的作用，但是会让计算复杂一些。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/445bad6346dd7e590ae4a7adcad96af1.jpg" alt="这里写图片描述" title="" /></p>

        <p>以上就是basic autoencoder的结构和一些限定条件。深度学习中，basic
            autoencoder的过程也就对应着pre-training的过程，使用这种方法，对无label的原始数据进行编码和解码，得到的编码权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e98999cf2775df31e3b8d7e639340bbd.jpg" />就可以作为pre-trained的比较不错的初始化权重，也就是作为深度学习中层与层之间的初始化权重。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b457a2ace152a38915ebf8b1b0ae1e2e.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们在本节课第一部分就说了深度学习中非常重要的一步就是pre-training，即权重初始化，而autoencoder可以作为pre-training的一个合理方法。Pre-training的整个过程是：首先，autoencoder会对深度学习网络第一层（即原始输入）进行编码和解码，得到编码权重<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e98999cf2775df31e3b8d7e639340bbd.jpg" />，作为网络第一层到第二层的的初始化权重；然后再对网络第二层进行编码和解码，得到编码权重<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e98999cf2775df31e3b8d7e639340bbd.jpg" />，作为网络第二层到第三层的初始化权重，以此类推，直到深度学习网络中所有层与层之间都得到初始化权重。值得注意的是，对于l-1层的网络<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8b00433e53808fc0a422ee1637b1dfb0.jpg" />，autoencoder中的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fd6b9429dfaedff3a2b6a3f3e1be6525.jpg" />应与下一层（即l层）的神经元个数相同。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/87d54d96d48355e756395f7de5b2456b.jpg" alt="这里写图片描述" title="" /></p>

        <p>当然，除了basic autoencoder之外还有许多其它表现不错的pre-training方法。这些方法大都采用不同的结构和正则化技巧来得到不同的’fancier’ autoencoders，这里不再赘述。</p>

        <h3 id="denoising-autoencoder" class="sigil_not_in_toc"><strong>Denoising Autoencoder</strong></h3>

        <p>上一部分，我们使用autoencoder解决了deep learning中pre-training的问题。接下来，我们将讨论deep learning中有什么样的regularization方式来控制模型的复杂度。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/924e9324bc7873d849b27cb984c0a469.jpg" alt="这里写图片描述" title="" /></p>

        <p>由于深度学习网络中神经元和权重的个数非常多，相应的模型复杂度就会很大，因此，regularization非常必要。之前我门也介绍过一些regularization的方法，包括：</p>

        <ul>
            <li>
                <p><strong>structural decisions/constraints</strong></p>
            </li>
            <li>
                <p><strong>weight decay or weight elimination regularizers</strong></p>
            </li>
            <li>
                <p><strong>early stopping</strong></p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5610918a336e729c9f6ecb60e3ec6fb7.jpg" alt="这里写图片描述" title="" /></p>

        <p>下面我们将介绍另外一种regularization的方式，它在deep learning和autoencoder中都有很好的效果。</p>

        <p>首先我们来复习一下之前介绍的overfitting产生的原因有哪些。如下图所示，我们知道overfitting与样本数量、噪声大小都有关系，数据量减少或者noise增大都会造成overfitting。如果数据量是固定的，那么noise的影响就非常大，此时，实现regularization的一个方法就是消除noise的影响。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e5acb66510425ca0b27ff559b8f0cc02.jpg" alt="这里写图片描述" title="" /></p>

        <p>去除noise的一个简单方法就是对数据进行cleaning/pruning的操作。但是，这种方法通常比较麻烦，费时费力。此处，有一种比较“疯狂”的方法，就是往数据中添加一些noise。注意是添加noise！下面我们来解释这样做到底有什么作用。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/84822962593e9a374bfe5fe9bc57bb7e.jpg" alt="这里写图片描述" title="" /></p>

        <p>这种做法的idea来自于如何建立一个健壮（robust）的autoencoder。在autoencoder中，编码解码后的输出g(x)会非常接近真实样本值x。此时，如果对原始输入加入一些noise，对于健壮的autoencoder，编码解码后的输出g(x)同样会与真实样本值x很接近。举个例子，手写识别中，通常情况下，写的很规范的数字1经过autoencoder后能够复原为数字1。如果原始图片数字1歪斜或加入噪声，经过autoencoder后应该仍然能够解码为数字1。这表明该autoencoder是robust的，一定程度上起到了抗噪声和regularization的作用，这正是我们希望看到的。</p>

        <p>所以，这就引出了denoising autoencoder的概念。denoising
            autoencoder不仅能实现编码和解码的功能，还能起到去噪声、抗干扰的效果，即输入一些混入noise的数据，经过autoencoder之后能够得到较纯净的数据。这样，autoencoder的样本集为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/084ce1d42d0ca6f2bd1cf0a9716b990c.jpg" /></p>

        <p>其中<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ccf2801c67cf4c7f682b7c5989aef8cb.jpg" />，为混入噪声的样本，而<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />为纯净样本。</p>

        <p>autoencoder训练的目的就是让<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/492cea5cf7fc0acb6877024968309645.jpg" />经过编码解码后能够复原为纯净的样本<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />。那么，在deep
            learning的pre-training中，如果使用这种denoising
            autoencoder，不仅能从纯净的样本中编解码得到纯净的样本，还能从混入noise的样本中编解码得到纯净的样本。这样得到的权重初始值更好，因为它具有更好的抗噪声能力，即健壮性好。实际应用中，denoising
            autoencoder非常有用，在训练过程中，输入混入人工noise，输出纯净信号，让模型本身具有抗噪声的效果，让模型健壮性更强，最关键的是起到了regularization的作用。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aeda0bc006885c1c48ac901adbf5bcf8.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="principal-component-analysis" class="sigil_not_in_toc"><strong>Principal Component Analysis</strong></h3>

        <p>刚刚我们介绍的autoencoder是非线性的，因为其神经网络模型中包含了tanh()函数。这部分我们将介绍linear autoencoder。nonlinear
            autoencoder通常比较复杂，多应用于深度学习中；而linear autoencoder通常比较简单，我们熟知的主成分分析（Principal Component
            Analysis，PCA），其实跟linear autoencoder有很大的关系。</p>

        <p>对于一个linear autoencoder，它的第k层输出不包含tanh()函数，可表示为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6e360f6d65b54271c54695496d4e5ae3.jpg" /></p>

        <p>其中，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c666a0d86be323308c0bc4fe2b64237c.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/74ca6d7ca28389005ad3fc7124c6f870.jpg" />分别是编码权重和解码权重。而且，有三个限制条件，分别是：</p>

        <ul>
            <li>
                <p><strong>移除常数项<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ddfc662b32da3468fabb177c80db8ea6.jpg" />，让输入输出维度一致</strong></p>
            </li>
            <li>
                <p><strong>编码权重与解码权重一致：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6d7be1da23946795c4d95772f1605c7b.jpg" /></strong></p>
            </li>
            <li>
                <p><strong><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8b7e12fe9c08edc57e90dd5d48ec8881.jpg" /></strong></p>
            </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/496591a7d3586107a1d24bdb0c812cc8.jpg" alt="这里写图片描述" title="" /></p>

        <p>这样，编码权重用W表示，维度是d x <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4f2212c1b8cd6a64ae9e17c38c50c6c6.jpg" />，解码权重用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e49209da2cab93b8f38765bec99ba7fa.jpg" />表示。x的维度为d
            x 1。则linear autoencoder hypothesis可经过下式计算得到：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3c603aaec464f611bba5314823d81c6f.jpg" /></p>

        <p>其实，linear autoencoder hypothesis就应该近似于原始输入x的值，即h(x)=x。根据这个，我们可以写出它的error function：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7c050562247692c358cbc1ae28a31473.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们的目的是计算出<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ea12556df1214d85311d83fdd4a07d4d.jpg" />最小化时对应的W。根据线性代数知识，首先进行特征值分解：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/28c6c4b72e97371d9666bf4504d19a99.jpg" /></p>

        <p>其中<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cd9292e70871e419617e2215c06e7b52.jpg" />是半正定矩阵。V矩阵满足<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8ffe1518cf9e3d467384a15b0c844660.jpg" />。<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4dc34652464a2921ba3ed30a50e35465.jpg" />是对角矩阵，对角线上有不超过<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4f2212c1b8cd6a64ae9e17c38c50c6c6.jpg" />个非零值（即为1），即对角线零值个数大于等于<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aa8fd9de2f1fef9272e5720b58d7d176.jpg" />。根据特征值分解的思想，我们可以把<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />进行类似分解：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/777aad73c7e11ab0d57bdd4d6afbbac3.jpg" /></p>

        <p>其中，I是单位矩阵，维度为dxd。这样，通过特征值分解我们就把对W的优化问题转换成对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4dc34652464a2921ba3ed30a50e35465.jpg" />和V的优化问题。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a06e7080023fff7b8545c4cdc06fddfb.jpg" alt="这里写图片描述" title="" /></p>

        <p>首先，我们来优化<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4dc34652464a2921ba3ed30a50e35465.jpg" />值，表达式如下：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/334d5f59128311667eecf72f5b0b0a3b.jpg" alt="这里写图片描述" title="" /></p>

        <p>要求上式的最小化，可以转化为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6f1704cee18a43d29251421e99cbe3bc.jpg" />越小越好，其结果对角线上零值越多越好，即I与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4dc34652464a2921ba3ed30a50e35465.jpg" />越接近越好。因为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4dc34652464a2921ba3ed30a50e35465.jpg" />的秩是小于等于<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4f2212c1b8cd6a64ae9e17c38c50c6c6.jpg" />的，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4dc34652464a2921ba3ed30a50e35465.jpg" />最多有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4f2212c1b8cd6a64ae9e17c38c50c6c6.jpg" />个1。所以，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4dc34652464a2921ba3ed30a50e35465.jpg" />的最优解是其对角线上有<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4f2212c1b8cd6a64ae9e17c38c50c6c6.jpg" />个1。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9a6aab1b81bb2c5c1aed4ed99369d389.jpg" alt="这里写图片描述" title="" /></p>

        <p>那么，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4dc34652464a2921ba3ed30a50e35465.jpg" />的最优解已经得出，表达式变成：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bcc779c709d4c9fa9236837c7dcec658.jpg" alt="这里写图片描述" title="" /></p>

        <p>这里的最小化问题似乎有点复杂，我们可以做一些转换，把它变成最大化问题求解，转换后的表达式为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e5c1e23d47ed4222a7b483403a69a2bf.jpg" alt="这里写图片描述" title="" /></p>

        <p>当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b8db6ff324cfe553b01094aa3a99b3ba.jpg" />时，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f96bf33398bdc80fa55a5369484c3b41.jpg" />中只有第一行<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2f8f699e0a4d33706c6411ad38a8b8db.jpg" />有用，最大化问题转化为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/64b0799768089f09641bf78c7a198eba.jpg" /></p>

        <p>引入拉格朗日因子<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" />，表达式的微分与条件微分应该是平行的，且由<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" />联系起来，即：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9facb359037475b6c2c40ba7798d8ac4.jpg" /></p>

        <p>根据线性代数的知识，很明显能够看出，v就是矩阵<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a290c753bbb51f078237ffa708533b91.jpg" />的特征向量，而<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" />就是相对应的特征值。我们要求的是最大值，所以最优解v就是矩阵<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a290c753bbb51f078237ffa708533b91.jpg" />最大特征值对应的特征向量。</p>

        <p>当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cbfbda0b864ce2f4a7b91a1611a674b0.jpg" />时，求解方法是类似的，最优解<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/95766e22e14c6685d5c19dfcf839ddb1.jpg" />就是矩阵<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a290c753bbb51f078237ffa708533b91.jpg" />前<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4f2212c1b8cd6a64ae9e17c38c50c6c6.jpg" />大的特征值对应的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4f2212c1b8cd6a64ae9e17c38c50c6c6.jpg" />个特征向量。</p>

        <p>经过以上分析，我们得到了<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4dc34652464a2921ba3ed30a50e35465.jpg" />和V的最优解。这就是linear
            autoencoder的编解码推导过程。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/48631d3956aeadaef71872c585d977e9.jpg" alt="这里写图片描述" title="" /></p>

        <p>值得一提的是，linear autoencoder与PCA推导过程十分相似。但有一点不同的是，一般情况下，PCA会对原始数据x进行处理，即减去其平均值。这是为了在推导过程中的便利。这两种算法的计算流程大致如下：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/38b8e30b637df3ef4a3da395c3b76536.jpg" alt="这里写图片描述" title="" /></p>

        <p>linear
            autoencoder与PCA也有差别，PCA是基于统计学分析得到的。一般我们认为，将高维数据投影（降维）到低维空间中，应该保证数据本身的方差越大越好，而噪声方差越小越好，而PCA正是基于此原理推导的。linear
            autoencoder与PCA都可以用来进行数据压缩，但是PCA应用更加广泛一些。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b1767c1389f2717f25172a86539e86a5.jpg" alt="这里写图片描述" title="" /></p>

        <p>以上关于PCA的推导基本上是从几何的角度，而没有从代数角度进行详细的数学推导。网上关于PCA的资料很多，这里附上一篇个人觉得讲解得通俗易懂的PCA原理介绍：<a href="http://blog.codinglabs.org/articles/pca-tutorial.html"
                rel="nofollow">PCA的数学原理</a>。有兴趣的朋友可以看一看。</p>

        <h3 id="总结" class="sigil_not_in_toc"><strong>总结</strong></h3>

        <p>本节课主要介绍了深度学习（deep
            learning）的数学模型，也是上节课讲的神经网络的延伸。由于深度学习网络的复杂性，其建模优化是比较困难的。通常，我们可以从pre-training和regularization的角度来解决这些困难。首先，autoencoder可以得到比较不错的初始化权重，起到pre-training的效果。然后，denoising
            autoencoder通过引入人工噪声，训练得到初始化权重，从而使模型本身抗噪声能力更强，更具有健壮性，起到了regularization的效果。最后，我们介绍了linear
            autoencoder并从几何角度详述了其推导过程。linear autoencoder与PCA十分类似，都可以用来进行数据压缩和数据降维处理。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习技法》课程</p>

        <p><strong>更多AI资源请关注公众号：红色石头的机器学习之路（ID：redstonewill）</strong> <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b7b0fb694b2acb4b26c0363b53103204.jpg" alt="这里写图片描述" title="" /></p>
    </div>

    <h1 class="title-article">14 -- Radial Basis Function Network</h1>
    <div class="markdown_views">
        <blockquote>
            <p>红色石头的个人网站：<a href="http://redstonewill.com/" rel="nofollow">redstonewill.com</a></p>
        </blockquote>

        <p>上节课我们主要介绍了Deep Learning的概念。Deep Learing其实是Neural
            Networ的延伸，神经元更多，网络结构更加复杂。深度学习网络在训练的过程中最核心的问题就是pre-training和regularization。pre-training中，我们使用denoising
            autoencoder来对初始化权重进行选择。denoising autoencoder与统计学中经常用来进行数据处理的PCA算法具有很大的关联性。这节课我们将介绍Radial Basis Function
            Network，把之前介绍的adial Basis Function和Neural Network联系起来。</p>

        <h3 id="rbf-network-hypothesis" class="sigil_not_in_toc"><strong>RBF Network Hypothesis</strong></h3>

        <p>之前我们介绍过，在SVM中引入Gaussian Kernel就能在无限多维的特征转换中得到一条“粗壮”的分界线（或者高维分界平面、分界超平面）。从结果来看，Gaussian
            SVM其实就是将一些Gaussian函数进行线性组合，而Gaussian函数的中心就位于Support Vectors上，最终得到预测模型<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d4cab5a23bba251834b236c5af3d001d.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/95d159c37be633f434d16c5c648920ca.jpg" alt="这里写图片描述" title="" /></p>

        <p>Gaussian kernel的另一种叫法是Radial Basis Function(RBF) kernel，即径向基函数。这个名字从何而来？首先，radial表示Gaussian函数计算结果只跟新的点x与中心点<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />的距离有关，与其它无关。basis function就是指Gaussian函数，最终的矩<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d4cab5a23bba251834b236c5af3d001d.jpg" />就是由这些basis function线性组合而成。</p>

        <p>从另外一个角度来看Gaussian SVM。首先，构造一个函数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f08db1774d1d11ffae78951e2b821dd8.jpg" />：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/2b62fed96c88c99e9c4ff14a3469d434.jpg" /></p>

        <p>上式中，指数项表示新的点x与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />之间的距离大小。距离越近，即权重越大，相当于对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd32e7f8488e6575c81fd5ec787f53a7.jpg" />投的票数更多；而距离越远，权重越小，相当于对<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd32e7f8488e6575c81fd5ec787f53a7.jpg" />投的票数更少。其物理意义是新的点与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />的距离远近决定了<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f08db1774d1d11ffae78951e2b821dd8.jpg" />与<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd32e7f8488e6575c81fd5ec787f53a7.jpg" />的接近程度。如果距离越近，则<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd32e7f8488e6575c81fd5ec787f53a7.jpg" />对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f08db1774d1d11ffae78951e2b821dd8.jpg" />的权重影响越大；如果距离越远，则<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd32e7f8488e6575c81fd5ec787f53a7.jpg" />对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f08db1774d1d11ffae78951e2b821dd8.jpg" />的权重影响越小。那么整体来说，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d4cab5a23bba251834b236c5af3d001d.jpg" />就由所有的SV组成的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f08db1774d1d11ffae78951e2b821dd8.jpg" />线性组合而成，不同<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f08db1774d1d11ffae78951e2b821dd8.jpg" />对应的系数是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />，最后由sign函数做最后的选择。这个过程很类型我们之前介绍的aggregation中将所有较好的hypothesis线性组合，不同的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f08db1774d1d11ffae78951e2b821dd8.jpg" />有不同的权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b445498ce7b354c165c2d823865602f9.jpg" />。我们把<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f08db1774d1d11ffae78951e2b821dd8.jpg" />叫做radial hypotheses，Gaussian SVM就是将所有SV对应的radial
            hypotheses进行线性组合（linear aggregation）。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3a9b06a5f72612247ed0d0512f0afaa7.jpg" alt="这里写图片描述" title="" /></p>

        <p>那么，Radial Basis Function(RBF) Network其实就是上面Gaussian SVM概念的延伸，目的就是找到所有radial hypotheses的linear
            aggregation，得到更好的网络模型。</p>

        <p>之所以叫作RBF Network是因为它的模型结构类似于我们之前介绍的Neural Network。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/86d4739f38aafac07b4fd2360b6766d9.jpg" alt="这里写图片描述" title="" /></p>

        <p>Neural Network与RBF Network在输出层基本是类似的，都是上一层hypotheses的线性组合（linear aggregation）。但是对于隐藏层的各个神经元来说，Neural
            Network是使用内积（inner-product）加上tanh()函数的方法，而RBF Network是使用距离（distance）加上Gaussian函数的方法。总的来说，RBF Network是Neural
            Network的一个分支。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0c07e5c87b9ff79c0b30383b261b6e2d.jpg" alt="这里写图片描述" title="" /></p>

        <p>至此，RBF Network Hypothesis以及网络结构可以写成如下形式：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c81826fab8272b6ae6e6f0818d35d065.jpg" alt="这里写图片描述" title="" /></p>

        <p>上式中，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ccf71c74629efc5ec3050a0662f1e434.jpg" />表示每个中心点的位置，隐藏层每个神经元对应一个中心点；<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7a67ab3285ccc1c45c27550ce55ddcd8.jpg" />表示每个RBF的权重，即投票所占比重。
        </p>

        <p>对应到Gaussian SVM上，上式中的RBF就是Gaussian函数。由于是分类问题，上式中的Output就是sign函数。其中，RBF的个数M就等于支持向量的个数SV，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ccf71c74629efc5ec3050a0662f1e434.jpg" />就代表每个SV的坐标<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/83b21b10631c21a91576ed7ec5d4c879.jpg" />，而<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7a67ab3285ccc1c45c27550ce55ddcd8.jpg" />就是在Dual
            SVM中推导得到的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/02043afbfb42a626a05b5c2bbc7e6065.jpg" />值。那我们学习的目标就是根据已知的RBF和Output，来决定最好的中心点位置<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ccf71c74629efc5ec3050a0662f1e434.jpg" />和权重系数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7a67ab3285ccc1c45c27550ce55ddcd8.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/62ab13fdac518e8932c86b11d7d46eac.jpg" alt="这里写图片描述" title="" /></p>

        <p>在之前介绍SVM的时候，我们就讲过Mercer定理：一个矩阵是Kernel的充分必要条件是它是对称的且是半正定的，条件比较苛刻。除了Gaussian kernel还有Polynomial
            kernel等等。Kernel实际上描述了两个向量之间的相似性，通过转换到z空间计算内积的方式，来表征二者之间的相似性。而RBF实际上是直接使用x空间的距离来描述了一种相似性，距离越近，相似性越高。因此，kernel和RBF可以看成是两种衡量相似性（similarity）的方式。本文介绍的Gaussian
            RBF即为二者的交集。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/15acfa9bb7834945a880198830dbe76d.jpg" alt="这里写图片描述" title="" /></p>

        <p>除了kernel和RBF之外，还有其它衡量相似性的函数。例如神经网络中的神经元就是衡量输入和权重之间的相似性。</p>

        <p>经过以上分析，我们知道了RBF Network中distance similarity是一个很好的定义特征转换的方法。除此之外，我们还可以使用其它相似性函数来表征特征转换，从而得到更好的机器学习模型。</p>

        <h3 id="rbf-network-learning" class="sigil_not_in_toc"><strong>RBF Network Learning</strong></h3>

        <p>我们已经介绍了RBF Network的Hypothesis可表示为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4695e0d78b5f4a1ffec6fbdf1b5b3633.jpg" alt="这里写图片描述" title="" /></p>

        <p>其中<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ccf71c74629efc5ec3050a0662f1e434.jpg" />表示中心点的位置。<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ccf71c74629efc5ec3050a0662f1e434.jpg" />的个数M是人为决定的，如果将每个样本点<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/83b21b10631c21a91576ed7ec5d4c879.jpg" />都作为一个中心点，即M=N，则我们把这种结构称为full RBF
            Network。也就是说，对于full RBF Network，每个样本点都对最终的预测都有影响（uniform influence），影响的程度由距离函数和权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7a67ab3285ccc1c45c27550ce55ddcd8.jpg" />决定。如果每个样本点的影响力都是相同的，设为1，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/597d28e8123a8107a02f8cbd9ff3898c.jpg" />，那么相当于只根据距离的远近进行投票。最终将x与所有样本点的RBF距离线性组合，经过sign函数后，得到最终的预测分类结果。这实际上就是aggregation的过程，考虑并计入所有样本点的影响力，最后将x与所有样本点的distance
            similarity进行线性组合。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d240f0ecf81d6c49bda78d66d26c1574.jpg" alt="这里写图片描述" title="" /></p>

        <p>full RBF Network的矩可以表示为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/627452cfe09a64fa9d0045017f4e6b8d.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们来看上式中的Gaussian函数项，当x与样本点<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/83b21b10631c21a91576ed7ec5d4c879.jpg" />越接近的时候，其高斯函数值越大。由于Gaussian函数曲线性质，越靠近中心点，值越大；偏离中心点，其值会下降得很快。也就是说，在所有N个中心样本点中，往往只有距离x最近的那个样本点起到关键作用，而其它距离x较远的样本点其值很小，基本可以忽略。因此，为了简化运算，我们可以找到距离x最近的中心样本点，只用这一个点来代替所有N个点，最后得到的矩<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1da7731d34afd043f5de172709a1485b.jpg" />也只由该最近的中心点决定。这种模型叫做nearest neighbor
            model，只考虑距离x最近的那一个“邻居”。</p>

        <p>当然可以对nearest neighbor model进行扩展，如果不是只选择一个“邻居”，而是选择距离x最近的k个“邻居”，进行uniformly aggregation，得到最终的矩<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1da7731d34afd043f5de172709a1485b.jpg" />。这种方法通常叫做k近邻算法（k
            nearest neighbor）。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e40194415ec5dab863345b12816f9c0.jpg" alt="这里写图片描述" title="" /></p>

        <p>k nearest neighbor通常比nearest neighbor model效果更好，计算量上也比full RBF Network要简单一些。值得一提的是，k nearest neighbor与full
            RBF Network都是比较“偷懒”的方法。因为它们在训练模型的时候比较简单，没有太多的运算，但是在测试的时候却要花费更多的力气，找出最相近的中心点，计算相对复杂一些。</p>

        <p>接下来，我们来看一下Full RBF Network有什么样的优点和好处。考虑一个squared error regression问题，且每个RBF的权重为<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7a67ab3285ccc1c45c27550ce55ddcd8.jpg" />而不是前面简化的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/32ee92891b7d36b681f9a4044f35a086.jpg" />。目的是计算最优化模型对应的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7a67ab3285ccc1c45c27550ce55ddcd8.jpg" />值。该hypothesis可表示为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d2d5fa1ca2fe578521a1b420b47b0920.jpg" alt="这里写图片描述" title="" /></p>

        <p>很明显，这是一个简单的线性回归问题，每个RBF都可以看成是特征转换。特征转换后的向量<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7e718f72f8be683c5df153a397bfe22d.jpg" />可表示为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/cfce13ad01825079bffb79e7c391d522.jpg" /></p>

        <p>那么，根据之前线性回归介绍过的最优化解公式，就能快速地得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />的最优解为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/487ea1328092d3ae371630319f486f57.jpg" /></p>

        <p>上述解的条件是矩阵<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e6a10b1f7bf8ba10a81df7f8104f0b25.jpg" />是可逆的。</p>

        <p>矩阵Z的大小是NxN，是一个方阵。而且，由于Z中每个向量<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7e718f72f8be683c5df153a397bfe22d.jpg" />表示该点与其它所有点的RBF
            distance，所以从形式上来说，Z也是对称矩阵。如果所有的样本点<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />都不一样，则Z一定是可逆的。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9253d9b2dac95be73be298bee39c71ff.jpg" alt="这里写图片描述" title="" /></p>

        <p>根据Z矩阵的这些性质，我们可以对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />的解进行化简，得到：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f75231ab4480cb961b09a29e67b686eb.jpg" /></p>

        <p>将<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />的解代入矩的计算中，以<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/abdadb44ea35aecb39004dd7f55d9543.jpg" />为例，得到：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5491c5b273e41cbbf396e8190c20b1a4.jpg" /></p>

        <p>结果非常有趣，模型的输出与原样本<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/75d94c5c78409a8b42337c55189230d4.jpg" />完全相同。同样，对任意的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />，都能得到<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/869db633062b791c820d7b0a5a461882.jpg" />。因此，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7e15e7977efb3f088b959c32476242e7.jpg" />。看起来，这个模型非常完美了，没有error。但是，我们之前就说过，机器学习中，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8979e87b0fb1d13fdfaad13dcfe4638b.jpg" />并非好事，很可能造成模型复杂度增加及过拟合。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/447d9c34e28ea2ffed91c503abcd5646.jpg" alt="这里写图片描述" title="" /></p>

        <p>当然，这种方法在某些领域还是很有用的。比如在函数拟合（function approximation）中，目标就是让<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8979e87b0fb1d13fdfaad13dcfe4638b.jpg" />，使得原所有样本都尽可能地落在拟合的函数曲线上。</p>

        <p>为了避免发生过拟合，我们可以引入正则项<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" />，得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />的最优解为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6794f77f7113bc3a84406b33086e38fe.jpg" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/58f2a5718b40d1494bb8deb7e0982f6c.jpg" alt="这里写图片描述" title="" /></p>

        <p>我们再来看一下Z矩阵，Z矩阵是由一系列Gaussian函数组成，每个Gaussian函数计算的是两个样本之间的distance similarity。这里的Z与之前我们介绍的Gaussian SVM中的kernel
            K是一致的。当时我们得到kernel ridgeregression中线性系数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />的解为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9f74b4e769fd0ec7574107b541ae4f1f.jpg" /></p>

        <p>比较一下kernel ridgeregression与regularized full RBF Network的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />解，形式上相似但不完全相同。这是因为regularization不一样，在kernel
            ridgeregression中，是对无限多维的特征转换做regularization，而在regularized full RBF
            Network中，是对有限维（N维度）的特征转换做regularization。因此，两者的公式解有细微差别。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8fc7883a4b1211ccad246fdf57e7fd1d.jpg" alt="这里写图片描述" title="" /></p>

        <p>除此之外，还有另外一种regularization的方法，就是不把所有N个样本点都拿来作中心点，而是只选择其中的M个样本点作为中心点。类似于SVM中的SV一样，只选择具有代表性的M个中心点。这样减少中心点数量的同时也就减少了权重的数量，能够起到regularization的效果，避免发生过拟合。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c9e164466eeb0a97efacdcd091c72244.jpg" alt="这里写图片描述" title="" /></p>

        <p>下一部分，我们将讨论如何选取M个中心点作为好的代表。</p>

        <h3 id="k-means-algorithm" class="sigil_not_in_toc"><strong>k-Means Algorithm</strong></h3>

        <p>之所以要选择代表，是因为如果某些样本点很接近，那么就可以用一个中心点来代表它们。这就是聚类（cluster）的思想，从所有N个样本点中选择少数几个代表作为中心点。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fe5e45ade27a01991344b47aec9fd7ae.jpg" alt="这里写图片描述" title="" /></p>

        <p>聚类（clustering）问题是一种典型的非监督式学习（unsupervised learning）。它的优化问题有两个变量需要确定：一个是分类的分群值<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25703e54bf9166069abc2fc242605c43.jpg" />，每一类可表示为<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9eebfaeb25ba8202cd1c085172d803aa.jpg" />；另外一个是每一类对应的中心点<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fa061fdd440bb703459260b1561d021c.jpg" />。那么对于该聚类问题的优化，其error
            function可使用squared error measure来衡量。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a1b942e88fea457b39f4c7ff25301fe4.jpg" alt="这里写图片描述" title="" /></p>

        <p>那么，我们的目标就是通过选择最合适的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9eebfaeb25ba8202cd1c085172d803aa.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fa061fdd440bb703459260b1561d021c.jpg" />，使得<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />最小化。对应的公式可表示为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/adbe549a9cdc3f89a472d7a90a3accba.jpg" alt="这里写图片描述" title="" /></p>

        <p>从这个最小化公式，我们能够发现这是一个组合最佳化的问题，既要优化分群值<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25703e54bf9166069abc2fc242605c43.jpg" />，又要求解每一类的中心点<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b086811270baa24d871dedd2622bcf67.jpg" />。所以，这个最小化问题是比较复杂、难优化的。通常的办法是对S和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4e4d506c887c843f43a8fbcbe1884ffd.jpg" />分别进行最优化求解。</p>

        <p>首先，如果<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fa061fdd440bb703459260b1561d021c.jpg" />是固定的，目标就是只要对所有的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />进行分群归类。这个求解过程很简单，因为每个样本点只能属于一个群S，不能同时属于两个或多个群。所以，只要根据距离公式，计算选择离<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />最近的中心点<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4e4d506c887c843f43a8fbcbe1884ffd.jpg" />即可。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e564bebdbacdba62d3e7372799a31ea.jpg" alt="这里写图片描述" title="" /></p>

        <p>然后，如果<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9eebfaeb25ba8202cd1c085172d803aa.jpg" />是固定的，目标就是只要找出每个类的中心点<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4e4d506c887c843f43a8fbcbe1884ffd.jpg" />。显然，根据上式中的error
            function，所有的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />分群是已知的，那么该最小化问题就是一个典型的数值最优化问题。对于每个类群<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25703e54bf9166069abc2fc242605c43.jpg" />，利用梯度下降算法，即可得到<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ccf71c74629efc5ec3050a0662f1e434.jpg" />的解。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d2a5606b7b131b046aef8a213da3b859.jpg" alt="这里写图片描述" title="" /></p>

        <p>如上图所示，中心点<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ccf71c74629efc5ec3050a0662f1e434.jpg" />就等于所有属于类群<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/25703e54bf9166069abc2fc242605c43.jpg" />的平均位置处。</p>

        <p>经过以上的推导，我们得到了一个非常有名的一种unsupervised learning算法，叫做k-Means Algorithm。这里的k就是代表上面的M，表示类群的个数。</p>

        <p>k-Means Algorithm的流程是这样的：首先，随机选择k个中心点<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0729f71045fb66b71883e35c443d87dd.jpg" />；然后，再由确定的中心点得到不同的类群<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/716e4292d54b27495960279767afe2b7.jpg" />；接着，再由确定的类群计算出新的不同的k个中心点；继续循环迭代计算，交互地对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4e4d506c887c843f43a8fbcbe1884ffd.jpg" />和S值进行最优化计算，不断更新<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4e4d506c887c843f43a8fbcbe1884ffd.jpg" />和S值，直到程序收敛，实现<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />最小化。具体算法流程图如下所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f80d901113821dafdd9c1090292f2fbd.jpg" alt="这里写图片描述" title="" /></p>

        <p>有一个问题是，k-Means Algorithm的循环迭代一定会停止吗？或者说一定能得到最优解吗？答案是肯定的。因为每次迭代更新，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4e4d506c887c843f43a8fbcbe1884ffd.jpg" />和S值都会比上一次的值更接近最优解，也就是说<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />是不断减小的。而<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />的下界是0，所以，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />最终会等于0，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4e4d506c887c843f43a8fbcbe1884ffd.jpg" />和S最终能得到最优解。</p>

        <p>k-Means Algorithm已经介绍完毕。接下来，我们把k-Means Algorithm应用到RBF
            Network中去。首先，使用k-Means，得到原始样本的k个中心点。原始样本到k个中心点组成了RBF特征转换<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aed0c138deb8fbac62918bb5c5351399.jpg" />。然后，根据上面介绍过的线性模型，由最优化公式解计算得到权重<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />值。最后，将所有的<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aed0c138deb8fbac62918bb5c5351399.jpg" />用<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50705df736e9a7919e768cf8c4e4f794.jpg" />线性组合，即得到矩<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/374dab90bf340dbb0608374eebbab37f.jpg" />的表达式。具体的算法流程如下所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c68e0a526d32d6b6500035e9d916be44.jpg" alt="这里写图片描述" title="" /></p>

        <p>值得一提的是，这里我们使用了unsupervised learning（k-Means）与我们上节课介绍的autoencoder类似，同样都是特征转换（feature transform）的方法。</p>

        <p>在最优化求解过程中，参数有k-Means类群个数M、Gaussian函数参数<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" />等。我们可以采用validation的方法来选取最佳的参数值。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a0cb35116c277878373a4015307f4cbe.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="k-means-and-rbf-network-in-action" class="sigil_not_in_toc"><strong>k-means and RBF Network in Action</strong></h3>

        <p>下面这部分，我们将举几个例子，看一下k-Means Algorithm是如何处理分类问题的。</p>

        <p>第一个例子，平面上有4个类群，k=4。首先，我们随机选择4个中心点，如下图中四种颜色的方块所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5e6f15e907cbf4b8c4671d7d1006796d.jpg" alt="这里写图片描述" title="" /></p>

        <p>第一次迭代，由初始中心点，得到4个类群点的分布：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/6256c18bad898900529e82fd2d3db6fe.jpg" alt="这里写图片描述" title="" /></p>

        <p>4个类群点确定后，再更新4个中心点的位置：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a615a2cd5e180e1125682697a78dfa08.jpg" alt="这里写图片描述" title="" /></p>

        <p>第二次迭代，由上面得到的4个中心点，再计算4个类群点的分布：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0e5f45db0429e4882e60a9fb060c3fda.jpg" alt="这里写图片描述" title="" /></p>

        <p>4个类群点确定后，再更新4个中心点的位置：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0d343421e5a87edddcd13287d430d26b.jpg" alt="这里写图片描述" title="" /></p>

        <p>第三次迭代，由上面得到的4个中心点，再计算4个类群点的分布：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/1576f34cca08f2c1b0533bf04619fcbb.jpg" alt="这里写图片描述" title="" /></p>

        <p>4个类群点确定后，再更新4个中心点的位置：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b4ff310591b74ea793c24306c5f43adc.jpg" alt="这里写图片描述" title="" /></p>

        <p>第四次迭代，由上面得到的4个中心点，再计算4个类群点的分布：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/734facd9117e46a43466a385adb0a8cb.jpg" alt="这里写图片描述" title="" /></p>

        <p>4个类群点确定后，再更新4个中心点的位置：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/97076bde03ddb9f9d28801e9d4995386.jpg" alt="这里写图片描述" title="" /></p>

        <p>第五次迭代，由上面得到的4个中心点，再计算4个类群点的分布：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d66f3dbe8594faaf5df2b977ea1c6827.jpg" alt="这里写图片描述" title="" /></p>

        <p>4个类群点确定后，再更新4个中心点的位置：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fe837855781c9f05a67ed989c4ba86ac.jpg" alt="这里写图片描述" title="" /></p>

        <p>第六次迭代，由上面得到的4个中心点，再计算4个类群点的分布：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/72ed50ede60c11bfef8714da5594da2c.jpg" alt="这里写图片描述" title="" /></p>

        <p>4个类群点确定后，再更新4个中心点的位置：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/eedb219147d0bdf8becafab39965c356.jpg" alt="这里写图片描述" title="" /></p>

        <p>从上图我们可以看到，经过六次迭代计算后，聚类的效果已经相当不错了。从另外一个角度来说，k值的选择很重要，下面我们来看看不同的k值对应什么样的分类效果。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/12cbaf6a40683f6d2f82c1b6a1ba8a1c.jpg" alt="这里写图片描述" title="" /></p>

        <p>如上图所示，初始时，我们分别设定k为2，4，7，随机选择中心点位置。在经过多次迭代后，得到的聚类结果如下：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4003b04bd2a653e87d2cef1ac51768a1.jpg" alt="这里写图片描述" title="" /></p>

        <p>通过上面这个例子可以得出，不同的k值会得到不同的聚类效果。还有一点值得注意的是，初始中心点位置也可能会影响最终的聚类。例如上图中k=7的例子，初始值选取的右边三个中心点比较靠近，最后得到的右边三个聚类中心点位置也跟初始位置比较相近。所以，k值大小和初始中心点位置都会影响聚类效果。</p>

        <p>接下来，我们把k-Means应用到RBF Network中，同样分别设定k为2，4，7，不同模型得到的分类效果如下：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/edf960fa650e2c74bf4bb4e0e4a20065.jpg" alt="这里写图片描述" title="" /></p>

        <p>很明显，k=2时，分类效果不是太好；k=4时，分类效果好一些；而k=7时，分类效果更好，能够更细致地将样本准确分类。这说明了k-Means中k值设置得是否合理，对RBF Network的分类效果起到重要的作用。</p>

        <p>再来看一个例子，如果使用full RBF Network进行分类，即k=N，如下图左边所示，设置正则化因子<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/311d76da25afe244699fb70ce4a8fde8.jpg" />。下图右边表示只考虑full
            RBF Network中的nearest neighbor。下图中间表示的是k=4的RBF Network的分类效果。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/94c983970ee2560143f87720f334bcb0.jpg" alt="这里写图片描述" title="" /></p>

        <p>从上图的比较中，我们可以发现full RBF Network得到的分类线比较弯曲复杂。由于full RBF Network的计算量比较大，所以一般情况下，实际应用得不太多。</p>

        <h3 id="总结" class="sigil_not_in_toc"><strong>总结</strong></h3>

        <p>本节课主要介绍了Radial Basis Function Network。RBF Network Hypothesis就是计算样本之间distance
            similarity的Gaussian函数，这类原型替代了神经网络中的神经元。RBF Network的训练学习过程，其实就是对所有的原型Hypotheses进行linear
            aggregation。然后，我们介绍了一个确定k个中心点的unsupervised learning算法，叫做k-Means
            Algorithm。这是一种典型的聚类算法，实现对原始样本数据的聚类分群。接着，将k-Means Algorithm应用到RBF
            Network中，选择合适数量的中心点，得到更好的分类模型。最后，我们列举了几个在实际中使用k-Means和RBF Network的例子，结果显示不同的类群k值对分类的效果影响很大。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习技法》课程</p>

        <p><strong>更多AI资源请关注公众号：红色石头的机器学习之路（ID：redstonewill）</strong> <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d1c0714c07a2b7b95c2628bd2b04f8c9.jpg" alt="这里写图片描述" title="" /></p>
    </div>

    <h1 class="title-article">15 -- Matrix Factorization</h1>
    <div class="markdown_views">
        <blockquote>
            <p>红色石头的个人网站：<a href="http://redstonewill.com/" rel="nofollow">redstonewill.com</a></p>
        </blockquote>

        <p>上节课我们主要介绍了Radial Basis Function Network。它的原理就是基于距离相似性（distance-based similarities）的线性组合（linear
            aggregation）。我们使用k-Means clustering算法找出具有代表性的k个中心点，然后再计算与这些中心点的distance similarity，最后应用到RBF Network中去。</p>

        <h3 id="linearnetwork-hypothesis" class="sigil_not_in_toc"><strong>LinearNetwork Hypothesis</strong></h3>

        <p>回顾一下，我们在机器学习基石课程的第一节课就提到过，机器学习的目的就是让机器从数据data中学习到某种能力skill。我们之前举过一个典型的推荐系统的例子。就是说，假如我们手上有许多不同用户对不同电影的排名rank，通过机器学习，训练一个模型，能够对用户没有看过的某部电影进行排名预测。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f0f4474d4942ce3409d9fae26010abc6.jpg" alt="这里写图片描述" title="" /></p>

        <p>一个典型的电影推荐系统的例子是2006年Netflix举办的一次比赛。数据包含了480189个用户和17770部电影，总共1亿多个排名信息。该推荐系统模型中，我们用<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c128038a692c9b8271127c77288c44bc.jpg" />表示第n个用户，这是一个抽象的特征，常常使用数字编号来代替具体哪个用户。输出方面，我们使用<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f25707a3ab64218c6f78aae08f2fae94.jpg" />表示第n个用户对第m部电影的排名数值。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f39353cdbb7aa37ac2af65c0db46dff3.jpg" alt="这里写图片描述" title="" /></p>

        <p>下面我们来进一步看看这些抽象的特征，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c128038a692c9b8271127c77288c44bc.jpg" />是用户的ID，通常用数字表示。例如1126,5566,6211等。这些编号并没有数值大小上的意义，只是一种ID标识而已。这类特征被称为类别特征（categorical
            features）。常见的categorical features包括：IDs，blood type，programming languages等等。而许多机器学习模型中使用的大部分都是数值特征（numerical
            features）。例如linear models，NNet模型等。但决策树（decision tree）是个例外，它可以使用categorical
            features。所以说，如果要建立一个类似推荐系统的机器学习模型，就要把用户ID这种categorical features转换为numerical
            features。这种特征转换其实就是训练模型之前一个编码（encoding）的过程。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fb6905bc8295ef5cdab2bcd6b780ac46.jpg" alt="这里写图片描述" title="" /></p>

        <p>一种最简单的encoding方式就是binary vector encoding。也就是说，如果输入样本有N个，就构造一个维度为N的向量。第n个样本对应向量上第n个元素为1，其它元素都是0。下图就是一个binary
            vector encoding的例子。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8259f01582ece3e7fc61e876c3dae3e5.jpg" alt="这里写图片描述" title="" /></p>

        <p>经过encoding之后，输入<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />是N维的binary vector，表示第n个用户。输出<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd32e7f8488e6575c81fd5ec787f53a7.jpg" />是M维的向量，表示该用户对M部电影的排名数值大小。注意，用户不一定对所有M部电影都作过评价，未评价的恰恰是我们要预测的（下图中问号？表示未评价的电影）。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a6182786ae175c3a57a3dea6ee1cf859.jpg" alt="这里写图片描述" title="" /></p>

        <p>总共有N个用户，M部电影。对于这样的数据，我们需要掌握每个用户对不同电影的喜爱程度及排名。这其实就是一个特征提取（feature
            extraction）的过程，提取出每个用户喜爱的电影风格及每部电影属于哪种风格，从而建立这样的推荐系统模型。可供选择使用的方法和模型很多，这里，我们使用的是NNet模型。NNet模型中的网络结构是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/5fa45cfc47124a79d994ce5502d60c5e.jpg" />型，其中N是输入层样本个数，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fd6b9429dfaedff3a2b6a3f3e1be6525.jpg" />是隐藏层神经元个数，M是输出层电影个数。该NNet为了简化计算，忽略了常数项。当然可以选择加上常数项，得到较复杂一些的模型。顺便提一下，这个结构跟我们之前介绍的autoencoder非常类似，都是只有一个隐藏层。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7db657a1d8c3ca1e3de8cb7719899b5b.jpg" alt="这里写图片描述" title="" /></p>

        <p>说到这里，有一个问题，就是上图NNet中隐藏层的tanh函数是否一定需要呢？答案是不需要。因为输入向量x是经过encoding得到的，其中大部分元素为0，只有一个元素为1。那么，只有一个元素<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />与相应权重的乘积进入到隐藏层。由于<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/c690c47b0faca158340453b8f403f6d2.jpg" />，则相当于只有一个权重值进入到tanh函数进行运算。从效果上来说，tanh(x)与x是无差别的，只是单纯经过一个函数的计算，并不影响最终的结果，修改权重值即可得到同样的效果。因此，我们把隐藏层的tanh函数替换成一个线性函数y=x，得到下图所示的结构。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a30f4559c203691f456d7bba99db255d.jpg" alt="这里写图片描述" title="" /></p>

        <p>由于中间隐藏层的转换函数是线性的，我们把这种结构称为Linear Network（与linear autoencoder比较相似）。看一下上图这个网络结构，输入层到隐藏层的权重<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/957099dee53f70681bd7162229e91294.jpg" />维度是Nx<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fd6b9429dfaedff3a2b6a3f3e1be6525.jpg" />，用向量<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f96bf33398bdc80fa55a5369484c3b41.jpg" />表示。隐藏层到输出层的权重<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/95790f24a7971c10951938888617f765.jpg" />维度是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fd6b9429dfaedff3a2b6a3f3e1be6525.jpg" />xM，用矩阵W表示。把权重由矩阵表示之后，Linear
            Network的hypothesis 可表示为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e05e3502e2de7ba335b0c0654dd1c5c3.jpg" /></p>

        <p>如果是单个用户<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />，由于X向量中只有元素<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/823e653728df96ee1167569828c41f0e.jpg" />为1，其它均为0，则对应矩阵V只有第n列向量是有效的，其输出hypothesis为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/77c7d7d7601da0076b81cdfd01cdca6a.jpg" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e11a408875e5327158e143234acea873.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="basic-matrix-factorization" class="sigil_not_in_toc"><strong>Basic Matrix Factorization</strong></h3>

        <p>刚刚我们已经介绍了linear network的模型和hypothesis。其中Vx可以看作是对用户x的一种特征转换<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/aed0c138deb8fbac62918bb5c5351399.jpg" />。对于单部电影，其预测的排名可表示为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/482ef3a874e8b608aae7d0161682b615.jpg" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d10dda0d1a17de82ad665630516ef420.jpg" alt="这里写图片描述" title="" /></p>

        <p>推导完linear network模型之后，对于每组样本数据（即第n个用户第m部电影），我们希望预测的排名<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d94293d7a91e9d55f06c972e6365121d.jpg" />与实际样本排名<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bd32e7f8488e6575c81fd5ec787f53a7.jpg" />尽可能接近。所有样本综合起来，我们使用squared error measure的方式来定义<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />的表达式如下所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/970cadf576d1c48e2439f428a524e6ac.jpg" alt="这里写图片描述" title="" /></p>

        <p>上式中，灰色的部分是常数，并不影响最小化求解，所以可以忽略。接下来，我们就要求出<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />最小化时对应的V和W解。</p>

        <p>我们的目标是让真实排名与预测排名尽可能一致，即<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/e0d9c8fcb988cf7f3ea47212d40f785a.jpg" />。把这种近似关系写成矩阵的形式：<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4a35facff95c64db4ea39dc061b891dd.jpg" />。矩阵R表示所有不同用户不同电影的排名情况，维度是NxM。这种用矩阵的方式进行处理的方法叫做Matrix
            Factorization。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d3abc85bc4068e26195326b37df16cfd.jpg" alt="这里写图片描述" title="" /></p>

        <p>上面的表格说明了我们希望将实际排名情况R分解成两个矩阵（V和W）的乘积形式。V的维度是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fd6b9429dfaedff3a2b6a3f3e1be6525.jpg" />xN的，N是用户个数，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fd6b9429dfaedff3a2b6a3f3e1be6525.jpg" />可以是影片类型，例如（喜剧片，爱情片，悬疑片，动作片，…）。根据用户喜欢的类型不同，赋予不同的权重。W的维度是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fd6b9429dfaedff3a2b6a3f3e1be6525.jpg" />xM，M是电影数目，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fd6b9429dfaedff3a2b6a3f3e1be6525.jpg" />同样是影片类型，该部电影属于哪一类型就在那个类型上占比较大的权重。当然，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fd6b9429dfaedff3a2b6a3f3e1be6525.jpg" />维特征不一定就是影片类型，还可以是其它特征，例如明显阵容、年代等等。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/82b88bcf28e2059ad2b87504b075e0c8.jpg" alt="这里写图片描述" title="" /></p>

        <p>那么，Matrix Factorization的目标就是最小化<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />函数。<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />表达式如下所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d52274bfdb3c766fb9bb19795063106f.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />中包含了两组待优化的参数，分别是<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9d81eded70d0314b1361cb867edfafca.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27f5fca1bad0f019f4111bf261455fd3.jpg" />。我们可以借鉴上节课中k-Means的做法，将其中第一个参数固定，优化第二个参数，然后再固定第二个参数，优化第一个参数，一步一步进行优化。</p>

        <p>当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9d81eded70d0314b1361cb867edfafca.jpg" />固定的时候，只需要对每部电影做linear regression即可，优化得到每部电影的<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fd6b9429dfaedff3a2b6a3f3e1be6525.jpg" />维特征值<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27f5fca1bad0f019f4111bf261455fd3.jpg" />。</p>

        <p>当<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27f5fca1bad0f019f4111bf261455fd3.jpg" />固定的时候，因为V和W结构上是对称的，同样只需要对每个用户做linear
            regression即可，优化得到每个用户对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/fd6b9429dfaedff3a2b6a3f3e1be6525.jpg" />维电影特征的喜爱程度<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9d81eded70d0314b1361cb867edfafca.jpg" />。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7668a2c4f80e613297a0daf9cc936525.jpg" alt="这里写图片描述" title="" /></p>

        <p>这种算法叫做alternating least squares algorithm。它的处理思想与k-Means算法相同，其算法流程图如下所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/687c9270016d2263c1042d50a2167189.jpg" alt="这里写图片描述" title="" /></p>

        <p>alternating least squares algorithm有两点需要注意。第一是initialize问题，通常会随机选取<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9d81eded70d0314b1361cb867edfafca.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27f5fca1bad0f019f4111bf261455fd3.jpg" />。第二是converge问题，由于每次迭代更新都能减小<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />，<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />会趋向于0，则保证了算法的收敛性。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/543a309a40fa35f156fa05e5eb5c9c24.jpg" alt="这里写图片描述" title="" /></p>

        <p>在上面的分析中，我们提过Matrix Factorization与Linear Autoencoder的相似性，下图列出了二者之间的比较。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/50adb927c77b7e4acb9b32693f499358.jpg" alt="这里写图片描述" title="" /></p>

        <p>Matrix Factorization与Linear Autoencoder有很强的相似性，都可以从原始资料汇总提取有用的特征。其实，linear autoencoder可以看成是matrix
            factorization的一种特殊形式。</p>

        <h3 id="stochastic-gradient-descent" class="sigil_not_in_toc"><strong>Stochastic Gradient Descent</strong></h3>

        <p>我们刚刚介绍了alternating least squares algorithm来解决Matrix Factorization的问题。这部分我们将讨论使用Stochastic Gradient
            Descent方法来进行求解。之前的alternating least squares algorithm中，我们考虑了所有用户、所有电影。现在使用SGD，随机选取一笔资料，然后只在与这笔资料有关的error
            function上使用梯度下降算法。使用SGD的好处是每次迭代只要处理一笔资料，效率很高；而且程序简单，容易实现；最后，很容易扩展到其它的error function来实现。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ccc8a544b1c3ea472afee1dcc251357e.jpg" alt="这里写图片描述" title="" /></p>

        <p>对于每笔资料，它的error function可表示为：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/bf1fc73c41a24ebb3dee4591d134b861.jpg" alt="这里写图片描述" title="" /></p>

        <p>上式中的err是squared error function，仅与第n个用户<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9d81eded70d0314b1361cb867edfafca.jpg" />，第m部电影<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27f5fca1bad0f019f4111bf261455fd3.jpg" />有关。其对<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9d81eded70d0314b1361cb867edfafca.jpg" />和<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27f5fca1bad0f019f4111bf261455fd3.jpg" />的偏微分结果为：</p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/828cfeb20c9bad910e80ab2712ccfebb.jpg" /></p>

        <p><span class="MathJax_Preview" style="color: inherit; display: none;"></span><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/db77aaf94f0f35779efa10b6f5ea3baa.jpg" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/935bad7de7bcbf01075a5f70bfe5e229.jpg" alt="这里写图片描述" title="" /></p>

        <p>很明显，<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f334054cbbc4f894423a647f334f2571.jpg" />和<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7435d9b4fcf9a1e1d387bd0f9b0ec13e.jpg" />都由两项乘积构成。（忽略常数因子2）。第一项都是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d6c309ec1b212f50657453cad611b818.jpg" />，即余数residual。我们在之前介绍的GBDT算法中也介绍过余数这个概念。<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f334054cbbc4f894423a647f334f2571.jpg" />的第二项是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/27f5fca1bad0f019f4111bf261455fd3.jpg" />，而<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7435d9b4fcf9a1e1d387bd0f9b0ec13e.jpg" />的第二项是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9d81eded70d0314b1361cb867edfafca.jpg" />。二者在结构上是对称的。</p>

        <p>计算完任意一个样本点的SGD后，就可以构建Matrix Factorization的算法流程。SGD for Matrix Factorization的算法流程如下所示：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/496835ff78b3346773c9b0260116b537.jpg" alt="这里写图片描述" title="" /></p>

        <p>在实际应用中，由于SGD算法简单高效，Matrix Factorization大多采用这种算法。</p>

        <p>介绍完SGD for Matrix
            Factorization之后，我们来看一个实际的应用例子。问题大致是这样的：根据现在有的样本资料，预测未来的趋势和结果。显然，这是一个与时间先后有关的预测模型。比如说一个用户三年前喜欢的电影可能现在就不喜欢了。所以在使用SGD选取样本点的时候有一个技巧，就是最后T次迭代，尽量选择时间上靠后的样本放入到SGD算法中。这样最后的模型受这些时间上靠后的样本点影响比较大，也相对来说比较准确，对未来的预测会比较准。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f863b33d30719bd6eb72ebf58ee2f583.jpg" alt="这里写图片描述" title="" /></p>

        <p>所以，在实际应用中，我们除了使用常规的机器学习算法外，还需要根据样本数据和问题的实际情况来修改我们的算法，让模型更加切合实际，更加准确。我们要学会灵活运用各种机器学习算法，而不能只是照搬。</p>

        <h3 id="summary-of-extraction-models" class="sigil_not_in_toc"><strong>Summary of Extraction Models</strong></h3>

        <p>从第12节课开始到现在，我们总共用了四节课的时间来介绍Extraction Models。虽然我们没有给出Extraction
            Models明确的定义，但是它主要的功能就是特征提取和特征转换，将原始数据更好地用隐藏层的一些节点表征出来，最后使用线性模型将所有节点aggregation。这种方法使我们能够更清晰地抓住数据的本质，从而建立最佳的机器学习模型。</p>

        <p>下图所示的就是我们介绍过的所有Extraction Models，除了这四节课讲的内容之外，还包括之前介绍的Adaptive/Gradient Boosting模型。因为之前笔记中都详细介绍过，这里就不再一一总结了。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b8b6e0efdf58024d1935912caed898b8.jpg" alt="这里写图片描述" title="" /></p>

        <p>除了各种Extraction Models之外，我们这四节课还介绍了不同的Extraction Techniques。下图所示的是对应于不同的Extraction Models的Extraction
            Techniques。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/3e9a5453688cb41618142facd57a8827.jpg" alt="这里写图片描述" title="" /></p>

        <p>最后，总结一下这些Extraction Models有什么样的优点和缺点。从优点上来说：</p>

        <ul>
            <li>
                <p><strong>easy：机器自己完成特征提取，减少人类工作量</strong></p>
            </li>
            <li>
                <p><strong>powerful：能够处理非常复杂的问题和特征提取</strong></p>
            </li>
        </ul>

        <p>另一方面，从缺点上来说：</p>

        <ul>
            <li>
                <p><strong>hard：通常遇到non-convex的优化问题，求解较困难，容易得到局部最优解而非全局最优解</strong></p>
            </li>
            <li>
                <p><strong>overfitting：模型复杂，容易造成过拟合，需要进行正则化处理</strong></p>
            </li>
        </ul>

        <p>所以说，Extraction Models是一个非常强大的机器学习工具，但是使用的时候也要小心处理各种可能存在的问题。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f202f9f6fa633b151c2e3bdce978a3ea.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="总结" class="sigil_not_in_toc"><strong>总结</strong></h3>

        <p>本节课主要介绍了Matrix Factorization。从电影推荐系统模型出发，首先，我们介绍了Linear Network。它从用户ID编码后的向量中提取出有用的特征，这是典型的feature
            extraction。然后，我们介绍了基本的Matrix Factorization算法，即alternating least squares，不断地在用户和电影之间交互地做linear
            regression进行优化。为了简化计算，提高运算速度，也可以使用SGD来实现。事实证明，SGD更加高效和简单。同时，我们可以根据具体的问题和需求，对固有算法进行一些简单的调整，来获得更好的效果。最后，我们对已经介绍的所有Extraction
            Models做个简单的总结。Extraction Models在实际应用中是个非常强大的工具，但是也要避免出现过拟合等问题。</p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习技法》课程</p>

        <p><strong>更多AI资源请关注公众号：红色石头的机器学习之路（ID：redstonewill）</strong> <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d23a928080958aa7b233a744be9e2b19.jpg" alt="这里写图片描述" title="" /></p>
    </div>

    <h1 class="title-article">16（完结） -- Finale</h1>
    <div class="markdown_views">
        <blockquote>
            <p>红色石头的个人网站：<a href="http://redstonewill.com/" rel="nofollow">redstonewill.com</a></p>
        </blockquote>

        <p>上节课我们主要介绍了Matrix Factorization。通过电影推荐系统的例子，介绍Matrix
            Factorization其实是一个提取用户特征，关于电影的线性模型。反过来也可以看出是关于用户的线性模型。然后，我们使用SGD对模型进行最佳化。本节课我们将对机器学习技法课程介绍过的所有内容做个总结，分成三个部分：Feature
            Exploitation Techniques，Error Optimization Techniques和Overfitting Elimination Techniques。</p>

        <h3 id="feature-exploitation-techniques" class="sigil_not_in_toc"><strong>Feature Exploitation Techniques</strong></h3>

        <p>我们在本系列课程中介绍的第一个特征提取的方法就是kernel。Kernel运算将特征转换和计算内积这两个步骤合二为一，提高了计算效率。我们介绍过的kernel有：Polynormial Kernel、Gaussian
            Kernel、Stump Kernel等。另外，我们可以将不同的kernels相加（transform union）或者相乘（transform
            combination），得到不同的kernels的结合形式，让模型更加复杂。值得一提的是，要成为kernel，必须满足Mercer
            Condition。不同的kernel可以搭配不同的kernel模型，比如：SVM、SVR和probabilistic SVM等，还包括一些不太常用的模型：kernel ridge
            regression、kernel logistic
            regression。使用这些kernel模型就可以将线性模型扩展到非线性模型，kernel就是实现一种特征转换，从而能够处理非常复杂的非线性模型。顺便提一下，因为PCA、k-Means等算法都包含了内积运算，所以它们都对应有相应的kernel版本。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/df83b1b00bc8d81c3173c3f1002c9c8b.jpg" alt="这里写图片描述" title="" /></p>

        <p>Kernel是我们利用特征转换的第一种方法，那利用特征转换的第二种方法就是Aggregation。我们之前介绍的所有的hypothesis都可以看成是一种特征转换，然后再由这些g组合成G。我们介绍过的分类模型（hypothesis）包括：Decision
            Stump、Decision Tree和Gaussian
            RBF等。如果所有的g是已知的，就可以进行blending，例如Uniform、Non-Uniform和Conditional等方式进行aggregation。如果所有的g是未知的，可以使用例如Bagging、AdaBoost和Decision
            Tree的方法来建立模型。除此之外，还有probabilistic SVM模型。值得一提的是，机器学习中很多模型都是类似的，我们在设计一个机器学习模型时，应该融会贯通。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/f59cd8244f85696aaf7798f2e5a87a30.jpg" alt="这里写图片描述" title="" /></p>

        <p>除此之外，我们还介绍了利用提取的方式，找出潜藏的特征（Hidden Features）。一般通过unsupervised learning的方法，从原始数据中提取出隐藏特征，使用权重表征。相应的模型包括：Neural
            Network、RBF Network、Matrix Factorization等。这些模型使用的unsupervised
            learning方法包括：AdaBoost、k-Means和Autoencoder、PCA等。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/17b3e93dc4ab9da827ccf5fc60d19c69.jpg" alt="这里写图片描述" title="" /></p>

        <p>另外，还有一种非常有用的特征转换方法是维度压缩，即将高维度的数据降低（投影）到低维度的数据。我们介绍过的维度压缩模型包括：Decision Stump、Random Forest Tree
            Branching、Autoencoder、PCA和Matrix Factorization等。这些从高纬度到低纬度的特征转换在实际应用中作用很大。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/04d4a4d11f72a992a2219b7a82fddeae.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="error-optimization-techniques" class="sigil_not_in_toc"><strong>Error Optimization Techniques</strong></h3>

        <p>接下来我们将总结一下本系列课程中介绍过哪些优化技巧。首先，第一个数值优化技巧就是梯度下降（Gradient Descent），即让变量沿着其梯度反方向变化，不断接近最优解。例如我们介绍过的SGD、Steepest
            Descent和Functional GD都是利用了梯度下降的技巧。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/4e0e34a6a692dc23082ca6ceeccf7595.jpg" alt="这里写图片描述" title="" /></p>

        <p>而对于一些更复杂的最佳化问题，无法直接利用梯度下降方法来做，往往需要一些数学上的推导来得到最优解。最典型的例子是Dual SVM，还包括Kernel LogReg、Kernel
            RidgeReg和PCA等等。这些模型本身包含了很多数学上的一些知识，例如线性代数等等。除此之外，还有一些boosting和kernel模型，虽然本课程中没有提到，但是都会用到类似的数学推导和转换技巧。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/ba77fc7ea96f3017af2bfc36dfadfdce.jpg" alt="这里写图片描述" title="" /></p>

        <p>如果原始问题比较复杂，求解比较困难，我们可以将原始问题拆分为子问题以简化计算。也就是将问题划分为多个步骤进行求解，即Multi-Stage。例如probabilistic SVM、linear
            blending、RBF Network等。还可以使用交叉迭代优化的方法，即Alternating Optim。例如k-Means、alternating
            LeastSqr等。除此之外，还可以采样分而治之的方法，即Divide &amp; Conquer。例如decision tree。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/309a1eb5fe7131112799fd40073665d4.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="overfitting-elimination-techniques" class="sigil_not_in_toc"><strong>Overfitting Elimination Techniques</strong></h3>

        <p>Feature Exploitation Techniques和Error Optimization Techniques都是为了优化复杂模型，减小<img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />。但是<img
                src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/a8b61417c614fe3bc2af079fa6ed96cd.jpg" />太小有很可能会造成过拟合overfitting。因此，机器学习中，Overfitting
            Elimination尤为重要。</p>

        <p>首先，可以使用Regularization来避免过拟合现象发生。我们介绍过的方法包括：large-margin、L2、voting/averaging等等。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/8771af70a25a86b89e39bc263419ecbb.jpg" alt="这里写图片描述" title="" /></p>

        <p>除了Regularization之外，还可以使用Validation来消除Overfitting。我们介绍过的Validation包括：SV、OOB和Internal Validation等。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/7c01e72641489bfa90c387c597ecb49b.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="machine-learning-in-action" class="sigil_not_in_toc"><strong>Machine Learning in Action</strong></h3>

        <p>本小节介绍了林轩田老师所在的台大团队在近几年的KDDCup国际竞赛上的表现和使用的各种机器算法。融合了我们在本系列课程中所介绍的很多机器学习技法和模型。这里不再一一赘述，将相应的图片贴出来，读者自己看看吧。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/d4b6ba5eeea22b259bbfefb45d7bc19f.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/b6ebd3235b2f8187f12352603401a8c0.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0d16711d5a1dac409840a103a33902ef.jpg" alt="这里写图片描述" title="" /></p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/9763ed2201116b3cfa19defc70a4cef1.jpg" alt="这里写图片描述" title="" /></p>

        <p>ICDM在2006年的时候发布了排名前十的数据挖掘算法，如下图所示。其中大部分的算法我们在本系列的课程中都有过介绍。值得一提的是Naive
            Bayes算法本课程中没有涉及，贝叶斯模型在实际中应用还是挺广泛的，后续可能还需要深入学习一下。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/06eccedf5fa8cf5bd13cc773cfc7624b.jpg" alt="这里写图片描述" title="" /></p>

        <p>最后，我们将所有介绍过的机器学习算法和模型列举出来：</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/0c56352bd27de8a60eb893b2a17db369.jpg" alt="这里写图片描述" title="" /></p>

        <h3 id="总结" class="sigil_not_in_toc"><strong>总结</strong></h3>

        <p>本节课主要从三个方面来对机器学习技法课程做个总结：Feature Exploitation Techniques，Error Optimization Techniques和Overfitting
            Elimination Techniques。最后介绍了林轩田老师带领的台大团队是如何在历届KDDCup中将很多机器学习算法模型融合起来，并获得了良好的成绩。</p>

        <p><img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/dd578f03edce258306dd2922f313e3d7.jpg" alt="这里写图片描述" title="" /></p>

        <p><strong><em>注明：</em></strong></p>

        <p>文章中所有的图片均来自台湾大学林轩田《机器学习技法》课程、</p>

        <h3 id="写在最后的话" class="sigil_not_in_toc"><strong>写在最后的话</strong></h3>

        <p>历时近4个月，终于将台湾大学林轩田老师的《机器学习基石》和《机器学习技法》这两门课程学完了。突然的想法，开始写博客记录下学习历程，通过笔记的形式加深巩固了自己的理解。如果能对读者有些许帮助的话，那便是一大快事。笔者资历尚浅，博客中难免有疏漏和错误，欢迎各位批评指正。另外，鄙人不才，建立了一个QQ群，以便讨论与该课程相关或者其它的机器学习和深度学习问题。有兴趣的朋友可以加一下，QQ群号码是223490966（红色石头机器学习小站）。后续，笔者根据学习情况，可能还会推出一些课程笔记的博客。</p>

        <p>积跬步以致千里，积小流以成江海！</p>

        <p>最后，特别感谢林轩田老师！您的教学风格我很喜欢，深入浅出、寓教于乐。非常有幸能够学到您的课程！再次感谢！</p>

        <p><strong>更多AI资源请关注公众号：红色石头的机器学习之路（ID：redstonewill）</strong> <br />
            <img src="https://raw.githubusercontent.com/iOSDevLog/100-days-of-ai/master/r1-ml/day5-ntu-ml/Images/57b4b17488812254120e047dbdc47f91.jpg" alt="这里写图片描述" title="" /></p>
    </div>
</body>

</html>